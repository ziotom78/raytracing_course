<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Maurizio Tomasi maurizio.tomasi@unimi.it">
  <title>Lezione 5</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reset.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reveal.css">
  <style>
    .reveal .sourceCode {  /* see #7635 */
      /* overflow: visible; */
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/theme/white.css" id="theme">
  <link rel="stylesheet" href="./css/custom.css"/>
  <link rel="stylesheet" href="./css/asciinema-player.css"/>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Lezione 5</h1>
  <p class="subtitle">Calcolo numerico per la generazione di immagini
fotorealistiche</p>
  <p class="author">Maurizio Tomasi <a
href="mailto:maurizio.tomasi@unimi.it"
class="email">maurizio.tomasi@unimi.it</a></p>
</section>

<section id="modellizzazione-di-oggetti" class="slide level1">
<h1>Modellizzazione di oggetti</h1>
</section>
<section id="cornell-box" class="slide level1">
<h1>«Cornell box»</h1>
<p><img data-src="./media/cornell_box_physical_model_image11.jpg"
height="560" /></p>
</section>
<section id="cornell-box-1" class="slide level1">
<h1>«Cornell box»</h1>
<p><img data-src="./media/cornell-box-schema.svg" height="560" /></p>
</section>
<section class="slide level1">

<center>
<img data-src="./media/night-stand-photo.jpg" height="620" />
</center>
</section>
<section class="slide level1">

<center>
<img data-src="./media/night-stand-sketch.png" height="620" />
</center>
</section>
<section class="slide level1">

<center>
<img data-src="./media/night-stand-lines.png" height="620" />
</center>
</section>
<section class="slide level1">

<center>
<img data-src="./media/night-stand-vertexes.png" height="620" />
</center>
</section>
<section id="il-problema-geometrico" class="slide level1">
<h1>Il problema geometrico</h1>
<ul>
<li>Collocazione degli oggetti nello spazio?</li>
<li>Dove sta l’osservatore, e verso cosa sta guardando?</li>
<li>Superficie degli oggetti?</li>
</ul>
</section>
<section id="posizioni-e-trasformazioni" class="slide level1">
<h1>Posizioni e trasformazioni</h1>
<ul>
<li><p>La descrizione geometrica di un oggetto nello spazio fa
solitamente uso di trasformazioni.</p></li>
<li><p>Queste trasformazioni sono necessarie per collocare gli oggetti
che compongono la scena in modo che la loro posizione, il loro
orientamento e le loro dimensioni siano quelle desiderate.</p></li>
<li><p>Anche la posizione della telecamera viene specificata tramite
trasformazioni che ne identificano la posizione (dove sta
l’osservatore?) e l’orientamento (in che direzione sta
guardando?).</p></li>
</ul>
</section>
<section id="interazione-con-superfici" class="slide level1">
<h1>Interazione con superfici</h1>
<center>
<img data-src="./media/surface-normals-wikipedia.svg" />
</center>
<p>Il modo in cui un raggio di luce interagisce con una superficie
dipende dalla BRDF, che <a href="tomasi-ray-tracing-01a.html#/la-brdf">è
espressa in termini dell’angolo</a> <span class="math inline">\theta =
N_x \cdot \Psi</span> tra la direzione di incidenza <span
class="math inline">\Psi</span> e la normale <span
class="math inline">N_x</span> alla superficie nel punto <span
class="math inline">x</span>.</p>
</section>
<section id="codifica-della-geometria" class="slide level1">
<h1>Codifica della geometria</h1>
<p>Per risolvere l’equazione del rendering numericamente, il nostro
codice deve trattare correttamente una serie di quantità:</p>
<ul>
<li><strong>Punti</strong> nello spazio tridimensionale (posizioni dei
vertici del comodino);</li>
<li><strong>Vettori</strong> 3D (direzioni di propagazione della
luce);</li>
<li><strong>Normali</strong> (rappresentano l’inclinazione della
superficie in un punto);</li>
<li><strong>Matrici</strong> (codificano le trasformazioni).</li>
</ul>
<p>Ripassiamo quindi le proprietà di questi oggetti geometrici.</p>
</section>
<section id="ripasso-di-algebra-lineare" class="slide level1">
<h1>Ripasso di algebra lineare</h1>
</section>
<section id="spazi-vettoriali" class="slide level1">
<h1>Spazi vettoriali</h1>
<p>Uno spazio vettoriale <span class="math inline">V</span> su un campo
<span class="math inline">F</span> è un insieme non vuoto <span
class="math inline">V</span> di elementi, detti <em>vettori</em>,
associato a due operatori <span class="math inline">+: V \times V
\rightarrow V</span> e <span class="math inline">\cdot: F \times V
\rightarrow V</span> che soddisfano queste proprietà <span
class="math inline">\forall u, v, w \in V, \forall \alpha, \beta \in
F</span>:</p>
<ol>
<li><span class="math inline">+</span> è commutativo e associativo;</li>
<li>Esiste un vettore <span class="math inline">0</span> che è elemento
neutro per <span class="math inline">+</span>;</li>
<li><span class="math inline">\forall u \in V,\ \exist -u \in V: u +
(-u) = 0</span>;</li>
<li><span class="math inline">\alpha(\beta v) = (\alpha\beta) v,\quad
(\alpha + \beta) v = \alpha v + \beta v,\quad \alpha(v + u) = \alpha v +
\alpha u</span>;</li>
<li>Se <span class="math inline">1 \in F</span> è l’elemento neutro del
prodotto su <span class="math inline">F</span>, allora <span
class="math inline">1u = u</span>.</li>
</ol>
</section>
<section id="prodotto-interno" class="slide level1">
<h1>Prodotto interno</h1>
<p>Dato uno spazio vettoriale <span class="math inline">V</span> su
<span class="math inline">F</span>, il prodotto interno è un’operazione
<span class="math inline">\left&lt;\cdot, \cdot\right&gt;: V \times V
\rightarrow F</span> che gode delle seguenti proprietà <span
class="math inline">\forall u, v, w \in V, \forall \alpha \in
F</span>:</p>
<ol>
<li><span class="math inline">\left&lt;\alpha u, v\right&gt; = \alpha
\left&lt;u, v\right&gt;</span>;</li>
<li><span class="math inline">\left&lt;u + v, w\right&gt; = \left&lt;u,
w\right&gt; + \left&lt;v, w\right&gt;</span>;</li>
<li><span class="math inline">\left&lt;u, v\right&gt; =
\overline{\left&lt;v, u\right&gt;}</span>;</li>
<li><span class="math inline">\left&lt;u, u\right&gt; &gt; 0</span> se
<span class="math inline">u \not= 0</span>.</li>
</ol>
<p>Un esempio è il classico prodotto scalare <span
class="math inline">\vec u \cdot \vec v = \left\|\vec
u\right\|\,\left\|\vec v\right\|\,\cos\theta</span> su <span
class="math inline">\mathbb{R}^n</span>.</p>
</section>
<section id="norma-e-ortogonalità" class="slide level1">
<h1>Norma e ortogonalità</h1>
<ul>
<li><p>Dato un prodotto interno, si può definire la <em>norma</em> <span
class="math inline">\left\|\cdot\right\|: V \rightarrow F</span> in
questo modo:</p>
<p><span class="math display">
\left\|u\right\| = \sqrt{\left&lt;u, u\right&gt;},
</span></p>
<p>che è positiva definita, e si annulla solo se <span
class="math inline">u = 0</span>.</p></li>
<li><p>Si definiscono <em>ortogonali</em> due vettori <span
class="math inline">u</span> e <span class="math inline">v</span> se
vale che <span class="math inline">\left&lt;u, v\right&gt; =
0</span>.</p></li>
<li><p>Un vettore <span class="math inline">u</span> tale che <span
class="math inline">\left\|u\right\| = 1</span> si dice
<em>normalizzato</em>.</p></li>
</ul>
</section>
<section id="generatori" class="slide level1">
<h1>Generatori</h1>
<ul>
<li><p>Lo spazio generato da un insieme di vettori <span
class="math inline">\{v_i\}_{i=1}^N</span> è l’insieme</p>
<p><span class="math display">
\mathrm{Span}\left(\{v_i\}_{i=1}^N\right) = \left\{\sum_{i=1}^N \alpha_i
v_i \forall \alpha_i \in F\right\}.
</span></p></li>
<li><p>Nel caso di <span class="math inline">\mathbb{R}^3</span>:</p>
<ol>
<li>Lo spazio generato da <span class="math inline">\vec v</span> è la
retta passante per 0 e allineata con <span class="math inline">\vec
v</span>.</li>
<li>Lo spazio generato da due vettori <span class="math inline">\vec
v</span> e <span class="math inline">\vec w</span> non paralleli è il
piano passante per l’origine su cui giacciono <span
class="math inline">\vec v</span> e <span class="math inline">\vec
w</span>. (V. slide seguente).</li>
</ol></li>
</ul>
</section>
<section id="esempio-piano-generato" class="slide level1">
<h1>Esempio: piano generato</h1>
<p><embed width="640px" height="640px" src="pd-images/00f3275659d41f402c8917f3e0c922c173bd007c.html"
data-im_fname="vector_generators" /></p>
</section>
<section id="basi-12" class="slide level1">
<h1>Basi (1/2)</h1>
<ul>
<li><p>I vettori <span class="math inline">\{v_i\}_{i=1}^N</span> si
dicono <em>linearmente indipendenti</em> se l’uguaglianza</p>
<p><span class="math display">
\sum_{i=1}^N \alpha_i v_i = 0
</span></p>
<p>vale solo se <span class="math inline">\alpha_i = 0\ \forall
i=1\ldots N</span>.</p></li>
<li><p>Un insieme di vettori <span
class="math inline">\left\{v_i\right\}_{i=1}^N</span> è detto
<em>base</em> di <span class="math inline">B</span> se sono linearmente
indipendenti e generano <span class="math inline">V</span>, ossia</p>
<p><span class="math display">
\mathrm{Span}\left(\{v_i\}_{i=1}^N\right) = V.
</span></p></li>
</ul>
</section>
<section id="basi-22" class="slide level1">
<h1>Basi (2/2)</h1>
<ul>
<li><p>Se <span class="math inline">V</span> ammette due basi <span
class="math inline">\left\{e_i\right\}_{i=1}^N</span> ed <span
class="math inline">\left\{f_i\right\}_{i=1}^M</span>, il numero di
elementi in entrambe è identico (<span class="math inline">N = M</span>)
ed è detto <em>dimensione</em> di <span class="math inline">V</span>.
(Ignoriamo in questo corso gli spazi infinito-dimensionali.)</p></li>
<li><p>Si definisce <em>base ortonormale</em> di uno spazio vettoriale
<span class="math inline">V</span> dotato di prodotto interno l’insieme
di vettori <span class="math inline">\left\{e_i\right\}_{i=1}^N</span>
tali che</p>
<p><span class="math display">
\left&lt;e_i, e_j\right&gt; = \delta_{ij}\quad\forall i, j = 1 \ldots N.
</span></p></li>
</ul>
</section>
<section id="rappresentazione-di-vettori" class="slide level1">
<h1>Rappresentazione di vettori</h1>
<ul>
<li><p>Data una base <span class="math inline">\{e_i\}_{i=1}^N</span>, è
sempre possibile scrivere <span class="math inline">v \in V</span>
come</p>
<p><span class="math display">
v = \sum_{i=1}^N \alpha_i e_i,
</span></p>
<p>dove <span class="math inline">\alpha_i \in F</span>. (Conseguenza
del fatto che la base genera lo spazio <span
class="math inline">V</span>).</p></li>
<li><p>Tale rappresentazione è sempre unica; se la base è ortonormale,
allora</p>
<p><span class="math display">\alpha_i = \left&lt;v,
e_i\right&gt;.</span></p></li>
<li><p>I vettori si rappresentano come matrici a una colonna: <span
class="math inline">v = (\alpha_1\ \alpha_2\ \ldots)^t</span>.</p></li>
</ul>
</section>
<section id="rappresentazione-di-vettori-1" class="slide level1">
<h1>Rappresentazione di vettori</h1>
<ul>
<li><p>Il fatto che <span class="math inline">\alpha_i = \left&lt;v,
e_i\right&gt;</span> vale <strong>solo</strong> se la base è
ortonormale!</p></li>
<li><p>Ad esempio, consideriamo sul piano <span
class="math inline">\mathbb{R}^2</span> la base <span
class="math inline">e_1 = (1, 0), e_2 = (1, 1)</span>. Il vettore <span
class="math inline">v = (4, 3)</span> si scompone risolvendo un sistema
lineare, e la soluzione è</p>
<p><span class="math display">
v = e_1 + 3 e_2 = \begin{pmatrix}1\\0\end{pmatrix} + 3
\begin{pmatrix}1\\1\end{pmatrix} = \begin{pmatrix}4\\3\end{pmatrix},
</span></p>
<p>ma <span class="math inline">\left&lt;v, e_1\right&gt; = 4</span> e
<span class="math inline">\left&lt;v, e_2\right&gt; = 7</span>.</p></li>
<li><p>Il nostro codice userà sempre basi ortonormali.</p></li>
</ul>
</section>
<section id="trasformazioni-lineari" class="slide level1">
<h1>Trasformazioni lineari</h1>
<ul>
<li><p>Una trasformazione lineare da uno spazio vettoriale <span
class="math inline">V</span> a uno spazio <span
class="math inline">W</span> è una funzione lineare <span
class="math inline">f: V \rightarrow W</span>:</p>
<p><span class="math display">
f(\alpha u + \beta v) = \alpha f(u) + \beta f(v).
</span></p></li>
<li><p>Dalla linearità ne segue che <span class="math inline">f(0) =
0</span>, perché</p>
<p><span class="math display">
f(0) = f(v - v) = f(v) - f(v) = 0\quad\forall v \in V.
</span></p></li>
</ul>
</section>
<section id="matrici-12" class="slide level1">
<h1>Matrici (1/2)</h1>
<ul>
<li><p>Una matrice <span class="math inline">M</span> è un insieme di
valori scalari <span class="math inline">\left\{m_{ij}\right\} \in
F</span> che rappresenta una trasformazione lineare <span
class="math inline">f: V \rightarrow W</span> secondo una coppia di basi
per <span class="math inline">V</span> e per <span
class="math inline">W</span>.</p></li>
<li><p>La matrice <span class="math inline">M</span> che rappresenta
<span class="math inline">f: V \rightarrow W</span> deve avere <span
class="math inline">n = N</span> colonne e <span class="math inline">m =
M</span> righe, dove <span class="math inline">N</span> è la dimensione
di <span class="math inline">V</span> e <span
class="math inline">M</span> è la dimensione di <span
class="math inline">W</span>.</p></li>
</ul>
</section>
<section id="matrici-22" class="slide level1">
<h1>Matrici (2/2)</h1>
<ul>
<li><p>Se si conosce il valore di <span class="math inline">f(e_i)\
\forall e_i</span>, si può calcolare <span class="math inline">f</span>
su qualsiasi vettore:</p>
<p><span class="math display">
f(v) = f\left(\sum_{i=1}^N \alpha_i e_i\right) =
\sum_{i=1}^N \alpha_i f(e_i).
</span></p></li>
<li><p>Il punto precedente si lega al fatto che la colonna <span
class="math inline">i</span>-esima della matrice <span
class="math inline">M</span> contiene la rappresentazione di <span
class="math inline">f(e_i)</span>, con <span
class="math inline">e_i</span> elemento <span
class="math inline">i</span>-esimo della c.d. <strong>base
canonica</strong> di <span class="math inline">V</span>: <span
class="math inline">e_1 = (1\ 0\ 0\ldots)^t, e_2 = (0\ 1\
0\ldots)^t</span>, etc.</p></li>
</ul>
</section>
<section id="primo-esempio" class="slide level1">
<h1>Primo esempio</h1>
<ul>
<li><p>Consideriamo la matrice in <span
class="math inline">\mathbb{R}^2</span></p>
<p><span class="math display">
M = \begin{pmatrix}3&amp;4\\2&amp;-1\end{pmatrix}
</span></p>
<p>e la base canonica <span class="math inline">e_1 = (1\ 0)^t, e_2 =
(0\ 1)^t</span>.</p></li>
<li><p>È facile vedere che la prima colonna di <span
class="math inline">M</span> è uguale a <span class="math inline">M
e_1</span> e la seconda a <span class="math inline">M e_2</span>:</p>
<p><span class="math display">
M e_1 = \begin{pmatrix}3&amp;4\\2&amp;-1\end{pmatrix}
\begin{pmatrix}1\\0\end{pmatrix} =
\begin{pmatrix}3\\2\end{pmatrix},\quad
M e_2 = \begin{pmatrix}3&amp;4\\2&amp;-1\end{pmatrix}
\begin{pmatrix}0\\1\end{pmatrix} = \begin{pmatrix}4\\-1\end{pmatrix}.
</span></p></li>
</ul>
</section>
<section id="secondo-esempio" class="slide level1">
<h1>Secondo esempio</h1>
<ul>
<li><p>Scriviamo la matrice <span class="math inline">R(\theta)</span>
che rappresenta una rotazione di <span class="math inline">\theta</span>
intorno all’origine del piano cartesiano <span
class="math inline">xy</span>.</p></li>
<li><p>Per quanto detto, è sufficiente calcolare <span
class="math inline">R(\theta) e_1</span> e <span
class="math inline">R(\theta) e_2</span>:</p>
<p><span class="math display">
R(\theta) e_1 = \begin{pmatrix}\cos\theta\\\sin\theta\end{pmatrix},
\quad
R(\theta) e_2 = \begin{pmatrix}\cos(\theta + 90^\circ)\\\sin(\theta +
90^\circ)\end{pmatrix} =
\begin{pmatrix}-\sin\theta\\\cos\theta\end{pmatrix},
</span></p>
<p>perché essi sono le colonne della matrice <span
class="math inline">R(\theta)</span>:</p>
<p><span class="math display">
R(\theta) =
\begin{pmatrix}\cos\theta&amp;-\sin\theta\\\sin\theta&amp;\cos\theta\end{pmatrix}.
</span></p></li>
</ul>
</section>
<section id="riflessioni" class="slide level1">
<h1>Riflessioni</h1>
<ul>
<li><p>Consideriamo ora un tipo particolare di trasformazione, detta
<em>riflessione</em>.</p></li>
<li><p>Punti, vettori ed angoli si trasformano in maniera intuitiva
rispetto alle riflessioni:</p>
<center>
<p><img data-src="./media/mirror.svg" height="380" /></p>
</center></li>
</ul>
</section>
<section id="pseudovettori" class="slide level1">
<h1>Pseudovettori</h1>
<ul>
<li><p>Consideriamo ora un’automobile che si allontana da noi, e la sua
copia riflessa.</p></li>
<li><p>Il momento angolare delle ruote <span
class="math inline">\vec\omega</span> <strong>non</strong> si trasforma
come un normale vettore nella riflessione: è uno
<em>pseudovettore</em>.</p>
<center>
<p><img data-src="./media/auto-angular-momentum.svg" height="380" /></p>
</center></li>
</ul>
</section>
<section id="pseudovettori-1" class="slide level1">
<h1>Pseudovettori</h1>
<ul>
<li><p>Il problema di <span class="math inline">\vec\omega</span> è che
è definito tramite il prodotto vettoriale: <span
class="math inline">\vec \omega = \vec r \times \vec p</span>, e il
risultato di un prodotto vettoriale è <em>sempre</em> uno
pseudovettore.</p></li>
<li><p>Questo si vede anche nel caso della legge di Ampère:</p>
<center>
<p><img data-src="./media/B-pseudovector.svg" height="380" /></p>
</center></li>
</ul>
</section>
<section id="trasformazioni" class="slide level1">
<h1>Trasformazioni</h1>
</section>
<section class="slide level1">

<center>
<img data-src="./media/raytracing-example.webp" />
</center>
</section>
<section id="tipi-di-trasformazioni" class="slide level1">
<h1>Tipi di trasformazioni</h1>
<ul>
<li><p>Con l’eccezione delle trasformazioni 3D→2D, implementeremo
t. <strong>invertibili</strong>.</p></li>
<li><p>Le trasformazioni che implementeremo saranno le seguenti:</p>
<ol>
<li>Trasformazione di scala (ingrandimento/rimpicciolimento);</li>
<li>Rotazione attorno ad un asse;</li>
<li>Traslazione (spostamento).</li>
</ol>
<center>
<p><img data-src="./media/transformations.svg" /></p>
</center></li>
</ul>
</section>
<section id="trasformazioni-di-scala" class="slide level1">
<h1>Trasformazioni di scala</h1>
</section>
<section id="proprietà-generali" class="slide level1">
<h1>Proprietà generali</h1>
<ul>
<li><p>Una trasformazione di scala è rappresentata da una matrice
diagonale <span class="math inline">M = \mathrm{diag}(s_1, s_2,
\ldots)</span> con <span class="math inline">s_i \not= 0\ \forall
i</span>:</p>
<p><span class="math display">
M = \begin{pmatrix}s_1&amp; 0&amp; \vdots\\0&amp; s_2&amp;
\vdots\\\ldots&amp; \ldots&amp;\end{pmatrix}.
</span></p></li>
<li><p>Trasformazioni di scala in cui <span class="math inline">s_i &lt;
0</span> sono anche dette <em>speculari</em> rispetto all’asse <span
class="math inline">i</span>-esimo (riflessione rispetto a uno
specchio).</p></li>
</ul>
</section>
<section id="esempio" class="slide level1">
<h1>Esempio</h1>
<ul>
<li><p>Un cerchio sul piano può essere trasformato in un ellisse tramite
una trasformazione di scala; nell’esempio qui sotto, <span
class="math inline">M = \mathrm{diag}(1/2, 1)</span>:</p>
<center>
<p><img
data-src="pd-images/2345170c00fa7298daf26892643d0caa499634fd.svg"
data-im_fname="scale-demo" /></p>
</center></li>
<li><p>Una riflessione rispetto all’asse <span
class="math inline">y</span> è rappresentata da <span
class="math inline">M = \mathrm{diag}(1, -1)</span>.</p>
<center>
<p><img
data-src="pd-images/1400c2f88fd287b117eb91e13d704bc3fdbd3780.svg"
data-im_fname="reflect-demo" /></p>
</center></li>
</ul>
</section>
<section id="trasformazioni-e-normali" class="slide level1">
<h1>Trasformazioni e normali</h1>
<ul>
<li><p>Già con questo tipo di trasformazioni abbiamo un
problema!</p></li>
<li><p>Le normali agli oggetti non si trasformano come dovrebbero:</p>
<center>
<p><img data-src="./media/normal-transformation.svg" /></p>
</center></li>
<li><p>Qual è la legge di trasformazione per le normali?</p></li>
</ul>
</section>
<section id="trasformazioni-e-normali-1" class="slide level1">
<h1>Trasformazioni e normali</h1>
<ul>
<li><p>Una normale <span class="math inline">\hat n</span> è definita in
termini del vettore tangente <span class="math inline">\hat
v</span>:</p>
<p><span class="math display">
\hat n^t \hat v = 0.
</span></p></li>
<li><p>Supponiamo di voler applicare la trasformazione <span
class="math inline">N</span> (invertibile) al vettore <span
class="math inline">\hat v</span>. Al vettore <span
class="math inline">\hat n</span> dovremo applicare una trasformazione
<span class="math inline">M</span> tale che</p>
<p><span class="math display">
\left(M \hat n\right)^t \left(N \hat v\right) = 0.
</span></p></li>
</ul>
</section>
<section id="trasformazioni-e-normali-2" class="slide level1">
<h1>Trasformazioni e normali</h1>
<ul>
<li><p>Sapendo che <span class="math inline">\left(A B\right)^t = B^t
A^t</span>, si ottiene che</p>
<p><span class="math display">
\left(M \hat n\right)^t \left(N \hat v\right) =
0\quad\Rightarrow\quad\hat n^t \left(M^t N\right) \hat v = 0.
</span></p></li>
<li><p>Sapendo già che <span class="math inline">\hat n^t \hat v =
0</span>, ne segue che l’equazione è vera se</p>
<p><span class="math display">
M^t N = \mathbb{1}\quad\Rightarrow\quad M = \left(N^{-1}\right)^t,
</span></p>
<p>dove abbiamo usato l’assunzione che la trasformazione <span
class="math inline">N</span> ammette un’inversa.</p></li>
</ul>
</section>
<section id="trattamento-delle-normali" class="slide level1">
<h1>Trattamento delle normali</h1>
<ul>
<li><p>Abbiamo visto che le normali si comportano in maniera diversa dai
vettori nel caso specifico delle trasformazioni di scala.</p></li>
<li><p>Il risultato che abbiamo ottenuto è però <em>generale</em>: non
vale solo per trasformazioni di scala, ma per qualsiasi trasformazione
invertibile <span class="math inline">N</span>.</p></li>
<li><p>In codici numerici è conveniente memorizzare in un tipo
(<code>struct</code>, <code>class</code>, <code>record</code>, etc.) che
rappresenta una trasformazione invertibile sia la matrice <span
class="math inline">N</span> corrispondente a una trasformazione che la
trasposta della sua inversa <span
class="math inline">\left(N^{-1}\right)^t</span>: si impiega più
memoria, ma i calcoli sono più rapidi.</p></li>
</ul>
</section>
<section id="rotazioni" class="slide level1">
<h1>Rotazioni</h1>
</section>
<section id="formalismo" class="slide level1">
<h1>Formalismo</h1>
<ul>
<li><p>Per definire una rotazione sul piano attorno all’origine è
sufficiente <strong>un</strong> grado di libertà.</p></li>
<li><p>Però per definire una rotazione in tre dimensioni intorno
all’origine sono necessari <strong>tre</strong> gradi di libertà: l’asse
di rotazione e l’angolo. (L’asse di rotazione è un vettore di lunghezza
unitaria, quindi ha solo due gradi di libertà).</p></li>
<li><p>Ci sono vari modi per rappresentare una rotazione, alcuni più
efficaci di altri a seconda del contesto: angoli di Eulero, angolo/asse,
matrici di rotazione, quaternioni. Noi ci concentreremo sulle matrici di
rotazione.</p></li>
</ul>
</section>
<section id="rotazioni-e-matrici" class="slide level1">
<h1>Rotazioni e matrici</h1>
<ul>
<li><p>In 2D, abbiamo già scritto la <a
href="./tomasi-ray-tracing-06a-geometry.html#/secondo-esempio">matrice
di rotazione attorno all’origine</a>:</p>
<p><span class="math display">
R(\theta) v =
\begin{pmatrix}\cos\theta&amp;-\sin\theta\\\sin\theta&amp;\cos\theta\end{pmatrix}
\begin{pmatrix}v_1\\v_2\end{pmatrix} =
\begin{pmatrix}v_1\cos\theta - v_2\sin\theta\\v_1\sin\theta +
v_2\cos\theta\end{pmatrix}.
</span></p>
<center>
<p><img
data-src="pd-images/8cbc38f2b926ce33c14510308bb08d45b8e11a70.svg"
data-im_fname="rotation-demo" /></p>
</center></li>
<li><p>In 2 dimensioni, vale che <span class="math inline">R(\alpha)
R(\beta) = R(\beta) R(\alpha) = R(\alpha + \beta)</span>.</p></li>
</ul>
</section>
<section id="rotazioni-in-3d" class="slide level1">
<h1>Rotazioni in 3D</h1>
<ul>
<li><p>In 3 dimensioni, le rotazioni possono essere notevolmente più
complesse, perché ci sono infiniti assi usabili per la rotazione intorno
all’origine!</p>
<center>
<video src="./media/rotating-cubes.mp4" width="960" height="360" controls loop autoplay/>
</center></li>
<li><p>In generale, una matrice <span class="math inline">R</span> in
<span class="math inline">\mathbb{R^n}</span> rappresenta una rotazione
se e solo se <span class="math inline">\det R = 1</span> e <span
class="math inline">R R^t = \mathbb{1}</span>, ossia se la trasposta
coincide con l’inversa.</p></li>
</ul>
</section>
<section id="composizione-di-rotazioni" class="slide level1">
<h1>Composizione di rotazioni</h1>
<ul>
<li><p>In 3D, la composizione di rotazioni <strong>non commuta</strong>
(a differenza del caso 2D).</p></li>
<li><p>I due dadi qui sotto subiscono due rotazioni <span
class="math inline">R_1</span> ed <span class="math inline">R_2</span>:
per il rosso la rotazione è <span class="math inline">R_1 R_2</span>,
per il verde è <span class="math inline">R_2 R_1</span>. Si vede che le
posizioni finali sono diverse:</p>
<center>
<video src="./media/rotation-commutativity.mp4" width="640" height="360" controls/>
</center></li>
</ul>
</section>
<section id="rotazioni-elementari" class="slide level1">
<h1>Rotazioni elementari</h1>
<ul>
<li><p>È facile scrivere le rotazioni attorno ai tre assi <span
class="math inline">\hat e_x</span>, <span class="math inline">\hat
e_y</span> ed <span class="math inline">\hat e_z</span>. Ad esempio, la
rotazione attorno a <span class="math inline">\hat e_z</span> è</p>
<p><span class="math display">
R_z(\theta) v =
\begin{pmatrix}\cos\theta&amp;-\sin\theta&amp;0\\\sin\theta&amp;\cos\theta&amp;0\\0&amp;0&amp;1\end{pmatrix}.
</span></p></li>
<li><p>È possibile scrivere una matrice <span
class="math inline">R_{\hat v}(\theta)</span> che descriva una rotazione
di un angolo θ attorno a un asse <span class="math inline">\hat v</span>
arbitrario; vedi la <a
href="https://en.wikipedia.org/wiki/Rotation_matrix#Basic_rotations">pagina
Wikipedia</a> per i dettagli.</p></li>
</ul>
</section>
<section id="angoli-di-eulero" class="slide level1">
<h1>Angoli di Eulero</h1>
<ul>
<li><p>Una rotazione generica <span class="math inline">R_{\hat
v}(\theta)</span> è sempre esprimibile come prodotto delle rotazioni
elementari <span class="math inline">R_x(\theta_x)</span>, <span
class="math inline">R_y(\theta_y)</span> e <span
class="math inline">R_z(\theta_z)</span> per adeguati valori di <span
class="math inline">\theta_x, \theta_y, \theta_z</span>.</p></li>
<li><p>Questa proprietà è alla base del formalismo delle rotazioni con
gli <a href="https://en.wikipedia.org/wiki/Euler_angles">angoli di
Eulero</a>, che però noi non useremo nel nostro codice.</p></li>
</ul>
</section>
<section id="traslazioni" class="slide level1">
<h1>Traslazioni</h1>
</section>
<section id="il-problema-delle-traslazioni" class="slide level1">
<h1>Il problema delle traslazioni</h1>
<ul>
<li><p>Una traslazione <span class="math inline">T_{\vec{k}}</span> è
una operazione che sposta un punto <span class="math inline">P</span> di
<span class="math inline">\vec{k}</span>:</p>
<p><span class="math display">
T_{\vec{k}} (P) = P + \vec{k}.
</span></p></li>
<li><p>Finora abbiamo utilizzato matrici per rappresentare
trasformazioni di scala e rotazioni. Purtroppo le matrici 3×3
<strong>non possono</strong> rappresentare traslazioni nello spazio
tridimensionale: una traslazione <span class="math inline">T</span> non
è un operatore lineare! Se lo fosse, allora varrebbe che</p>
<p><span class="math display">
T_{\vec{k}}(0) = 0\quad\forall\ \vec{k}.
</span></p></li>
</ul>
</section>
<section id="coordinate-omogenee" class="slide level1">
<h1>Coordinate omogenee</h1>
<ul>
<li><p>Fortunatamente è possibile un trucco, molto usato nella
<em>computer graphics</em>, che consiste nell’usare <strong>coordinate
omogenee</strong>.</p></li>
<li><p>Nelle coordinate omogenee si considera lo spazio <span
class="math inline">\mathbb{R}^4</span> anziché <span
class="math inline">\mathbb{R}^3</span>, e si scrivono i punti <span
class="math inline">P</span> e i vettori <span
class="math inline">\vec{v}</span> in modo diverso:</p>
<p><span class="math display">
P = \begin{pmatrix}p_x\\p_y\\p_z\\1\end{pmatrix}, \quad
\vec{v} = \begin{pmatrix}v_x\\v_y\\v_z\\0\end{pmatrix}.
</span></p></li>
</ul>
</section>
<section id="trasformazioni-omogenee" class="slide level1">
<h1>Trasformazioni omogenee</h1>
<ul>
<li><p>Una matrice <span class="math inline">M</span> si trasforma in
coordinate omogenee aggiungendo una riga e una colonna:</p>
<p><span class="math display">
M =
\begin{pmatrix}
m_{11}&amp;m_{12}&amp;m_{13}\\
m_{21}&amp;m_{22}&amp;m_{23}\\
m_{31}&amp;m_{32}&amp;m_{33}
\end{pmatrix}\ \rightarrow%
\ M_h =
\begin{pmatrix}
m_{11}&amp;m_{12}&amp;m_{13}&amp;0\\
m_{21}&amp;m_{22}&amp;m_{23}&amp;0\\
m_{31}&amp;m_{32}&amp;m_{33}&amp;0\\
0&amp;0&amp;0&amp;1
\end{pmatrix}
</span></p></li>
<li><p>Dalla forma a blocchi di <span class="math inline">M_h</span> è
immediato capire che l’applicazione di <span
class="math inline">M_h</span> a <span class="math inline">P</span> e a
<span class="math inline">\vec{v}</span> porta allo stesso risultato del
caso non-omogeneo in ℝ³.</p></li>
</ul>
</section>
<section id="traslazioni-1" class="slide level1">
<h1>Traslazioni</h1>
<ul>
<li><p>Nelle coordinate omogenee, l’operazione di traslazione lungo un
vettore <span class="math inline">\vec{k}</span> è lineare, e si
rappresenta così:</p>
<p><span class="math display">
T_{\vec{k}} =
\begin{pmatrix}
1&amp;0&amp;0&amp;k_x\\
0&amp;1&amp;0&amp;k_y\\
0&amp;0&amp;1&amp;k_z\\
0&amp;0&amp;0&amp;1
\end{pmatrix}
</span></p></li>
<li><p>L’operatore è ovviamente lineare, perché è in forma
matriciale.</p></li>
</ul>
</section>
<section id="proprietà" class="slide level1">
<h1>Proprietà</h1>
<ul>
<li><span class="math inline">T_{\vec{k}}^{-1} = T_{-\vec{k}}</span>: la
trasformazione inversa della traslazione lungo <span
class="math inline">\vec{k}</span> è la traslazione lungo <span
class="math inline">-\vec{k}</span>;</li>
<li><span class="math inline">T_{\vec{u}} T_{\vec{w}} = T_{\vec{u} +
\vec{w}}</span>: la composizione di due traslazioni è uguale alla
traslazione lungo la somma dei due vettori;</li>
<li><span class="math inline">T_{\vec{u}} T_{\vec{w}} = T_{\vec{w}}
T_{\vec{u}}</span>: le traslazioni sono operatori commutativi;</li>
<li><span class="math inline">T_{\vec{k}} \vec{v} = \vec{v}</span>: a
differenza dei punti, i vettori non vengono traslati.</li>
</ul>
</section>
<section id="rototraslazioni" class="slide level1">
<h1>Rototraslazioni</h1>
<ul>
<li><p>Comporre una traslazione <span
class="math inline">T_{\vec{k}}</span> e una rotazione <span
class="math inline">R(\theta)</span> dipende dall’ordine: il risultato
di <span class="math inline">T_{\vec{k}}\,R(\theta)</span> è diverso da
quello di <span class="math inline">R(\theta)\,T_{\vec{k}}</span>:</p>
<center>
<video width="640" height="360" src="./media/rototranslation.mp4" controls/>
</center></li>
<li><p>Si può verificare che le matrici omogenee implementano
correttamente questo comportamento.</p></li>
</ul>
</section>
<section id="numeri-di-versione" class="slide level1">
<h1>Numeri di versione</h1>
</section>
<section id="scopo-dei-numeri-di-versione" class="slide level1">
<h1>Scopo dei numeri di versione</h1>
<ul>
<li>Ogni programma dovrebbe avere un <strong>numero di versione</strong>
associato, che dice quanto sia aggiornato un programma.</li>
<li>Un utente può confrontare un numero di versione sul sito ufficiale
del programma con quello del programma installato sul proprio
computer.</li>
<li>Molti diversi approcci ai numeri di versione.</li>
</ul>
</section>
<section id="esempio-i-data-di-rilascio" class="slide level1">
<h1>Esempio I: data di rilascio</h1>
<ul>
<li>Ubuntu Linux: distribuzione Linux.</li>
<li>Il numero di versione è la data di rilascio nella forma
<code>anno.mese</code>, a cui si associa un soprannome come «Focal
fossa» (20.04).</li>
<li>Associato a un rigido calendario di rilascio (ogni 6 mesi).</li>
<li>Gli standard ISO del C++ seguono uno schema simile, usando solo
l’anno: C++11, C++14, C++17, C++20, …</li>
<li>Utile soprattutto se si segue un calendario rigido e regolare.</li>
</ul>
</section>
<section id="esempio-ii-numero-irrazionale" class="slide level1">
<h1>Esempio II: numero irrazionale</h1>
<ul>
<li><p>TeX: programma di tipografia digitale creato da Donald Knuth (per
digitare <em>The art of computer programming</em>, 1962–2019).</p></li>
<li><p>La versione è l’arrotondamento del valore di <span
class="math inline">\pi</span>, dove ogni versione successiva aggiunge
una cifra:</p>
<ul>
<li>3</li>
<li>3.1</li>
<li>3.14</li>
<li>3.141…</li>
</ul></li>
<li><p>METAFONT, il programma che gestisce i font di TeX, usa <span
class="math inline">e = 2.71828\ldots</span></p></li>
<li><p>Matematicamente affascinante, ma poco pratico!</p></li>
</ul>
</section>
<section id="esempio-iii-versioni-paridispari" class="slide level1">
<h1>Esempio III: versioni pari/dispari</h1>
<ul>
<li>Versioni indicate con <code>X.Y</code>, dove <code>X</code> è la
«major version» e <code>Y</code> la «minor version».</li>
<li>Se <code>Y</code> è pari, la versione è <strong>stabile</strong>
(es., <code>2.0</code>, <code>2.2</code>, <code>2.4</code>, …);
altrimenti è una versione di <strong>sviluppo</strong> (es.,
<code>2.1</code>, <code>2.3</code>, <code>2.5</code> …), non pronta per
essere usata dal pubblico generico ma solo dagli utenti più
smaliziati.</li>
<li><a href="https://nim-lang.org/">Nim</a>, <a
href="https://www.gtk.org/">Gtk+</a>, <a
href="https://www.gnome.org/">GNOME</a>, <a
href="http://lilypond.org/">Lilypond</a> seguono questo approccio.</li>
<li>Molto usato in passato, ora tende ad essere abbandonato:
l’esperienza ha dimostrato che le versioni dispari tendono spesso a
diventare «eterne».</li>
</ul>
</section>
<section id="esempio-iv-semantic-versioning" class="slide level1">
<h1>Esempio IV: <em>semantic versioning</em></h1>
<ul>
<li>Lo schema che useremo nel corso è il cosiddetto <a
href="https://semver.org/"><em>semantic versioning</em></a>, usato ad
esempio da Julia e Python, che usa lo schema <code>X.Y.Z</code>:
<ul>
<li><code>X</code> è la «major version»</li>
<li><code>Y</code> è la «minor version»</li>
<li><code>Z</code> è la «patch version»</li>
</ul></li>
<li>Le regole per assegnare valori a <code>X</code>, <code>Y</code> e
<code>Z</code> sono rigide, e consentono agli utenti di decidere se
valga la pena aggiornare un software o no.</li>
</ul>
</section>
<section id="semantic-versioning-12" class="slide level1">
<h1>Semantic versioning (1/2)</h1>
<ul>
<li>Si parte dalla versione <code>0.1.0</code>.</li>
<li>Ad ogni rilascio di una nuova versione, si segue una di queste
regole:
<ul>
<li>Si incrementa <code>Z</code> («patch number») se si sono solo
corretti dei bug;</li>
<li>Si incrementa <code>Y</code> («minor number») e si resetta
<code>Z</code> se si sono aggiunte funzionalità nuove;</li>
<li>Si incrementa <code>X</code> («major number») e si resettano
<code>Y</code> e <code>Z</code> se si sono aggiunte funzionalità che
rendono il programma <strong>incompatibile</strong> con l’ultima
versione rilasciata.</li>
</ul></li>
</ul>
</section>
<section id="semantic-versioning-22" class="slide level1">
<h1>Semantic versioning (2/2)</h1>
<ul>
<li>Nelle prime fasi di vita di un progetto, si rilasciano rapidamente
nuove versioni che sono usate da «beta testers»; non è importante
indicare quando si introducono incompatibilità, perché queste sono
frequenti ma gli utenti sono ancora pochi.</li>
<li>La versione <code>1.0.0</code> va rilasciata quando il programma è
pronto per essere usato da utenti generici.</li>
<li>Di conseguenza, le versioni precedenti alla <code>1.0.0</code>
seguono regole diverse:
<ul>
<li>Si incrementa <code>Z</code> se si correggono bug;</li>
<li>Si incrementa <code>Y</code> e si resetta <code>Z</code> in tutti
gli altri casi.</li>
</ul></li>
</ul>
</section>
<section id="esempio-13" class="slide level1">
<h1>Esempio (1/3)</h1>
<ul>
<li><p>Abbiamo scritto un programma che stampa
<code>Hello, world!</code>:</p>
<pre><code>$ ./hello
Hello, wold!</code></pre></li>
<li><p>La prima versione «ufficiale» che rilasciamo, dopo numerose
versioni beta (è un progetto complesso!), è ovviamente la
<code>1.0.0</code></p></li>
<li><p>Ci accorgiamo che il programma stampa <code>Hello, wold!</code>,
così correggiamo il problema e rilasciamo la versione <code>1.0.1</code>
(correzione di un bug).</p></li>
</ul>
</section>
<section id="esempio-23" class="slide level1">
<h1>Esempio (2/3)</h1>
<ul>
<li><p>Aggiungiamo una nuova funzionalità: se si passa un nome come
<code>Paperino</code> da riga di comando, il programma stampa
<code>Hello, Paperino!</code>. Senza argomenti, il programma scrive
ancora <code>Hello, world!</code>:</p>
<pre><code>$ ./hello
Hello, world!

$ ./hello Paperino
Hello, Paperino!</code></pre></li>
<li><p>Abbiamo aggiunto una funzionalità ma abbiamo preservato la
compatibilità (senza argomenti, il programma funziona ugualmente come la
versione <code>1.0.1</code>), quindi la nuova versione sarà la
<code>1.1.0</code>.</p></li>
</ul>
</section>
<section id="esempio-33" class="slide level1">
<h1>Esempio (3/3)</h1>
<ul>
<li><p>Decidiamo che è giunto il momento di introdurre
l’internazionalizzazione nel nostro codice
(<em>internationalization</em>, abbreviato in I18N)</p></li>
<li><p>Il codice verifica il valore della variabile d’ambiente
<code>$LANG</code> (usato sui sistemi Unix) e decide in che lingua
stampare il messaggio:</p>
<pre><code>$ ./hello Paperino     # …when I run it on a english-talking machine
Hello, Paperino!
$ LANG=it_IT.UTF-8 ./hello Pippo
Salve, Pippo!</code></pre></li>
<li><p>Il programma <strong>non è compatibile</strong> con la versione
<code>1.1.0</code>, perché su una macchina italiana ora stampa
<code>Salve, mondo!</code> anziché <code>Hello, world!</code></p></li>
<li><p>Devo quindi rilasciare la versione <code>2.0.0</code></p></li>
</ul>
</section>
<section id="punto-di-vista-di-un-utente" class="slide level1">
<h1>Punto di vista di un utente</h1>
<ol type="1">
<li>Se viene rilasciata una nuova «patch release» della versione che si
sta usando (es., <code>1.3.4</code> → <code>1.3.5</code>), l’utente
dovrebbe <strong>sempre</strong> aggiornare.</li>
<li>Se viene rilasciata una nuova «minor release» della versione che si
sta usando (es., <code>1.3.4</code> → <code>1.4.0</code>), l’utente
dovrebbe aggiornare solo se ritiene utili le nuove caratteristiche.</li>
<li>Una nuova «major release» (es., <code>1.3.4</code> →
<code>2.0.0</code>) dovrebbe essere installata solo da nuovi utenti, o
da chi è intenzionato ad aggiornare il modo in cui si usa il
programma.</li>
</ol>
</section>
    </div>
  </div>

  <script src="https://unpkg.com/reveal.js@^4//dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="https://unpkg.com/reveal.js@^4//plugin/notes/notes.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/search/search.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/zoom/zoom.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: true,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'bottom-right',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'default',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'slide',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'fade',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

       // Parallax background image
       parallaxBackgroundImage: './media/background.png', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1440,

        height: 810,

        // reveal.js plugins
        plugins: [
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script src="js/asciinema-player.js"></script>
    <script src="https://cdn.plot.ly/plotly-1.58.4.min.js"></script>
    <script type="text/javascript" src="./js/quantization.js"></script>
    </body>
</html>
