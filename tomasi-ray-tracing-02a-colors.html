<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Maurizio Tomasi maurizio.tomasi@unimi.it">
  <title>Lezione 2</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reset.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/theme/white.css" id="theme">
  <link rel="stylesheet" href="./css/custom.css"/>
  <link rel="stylesheet" href="./css/asciinema-player.css"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   var macros = [];
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      macros: macros,
      fleqn: false
     });
  }}});
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" />
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Lezione 2</h1>
  <p class="subtitle">Calcolo numerico per la generazione di immagini fotorealistiche</p>
  <p class="author">Maurizio Tomasi <a href="mailto:maurizio.tomasi@unimi.it" class="email">maurizio.tomasi@unimi.it</a></p>
</section>

<section id="lezione-precedente" class="slide level1">
<h1>Lezione precedente</h1>
<ul>
<li><p><strong>Radianza</strong> (flusso <span class="math inline">\Phi</span> in Watt normalizzato sulla superficie proiettata per unità di angolo solido): <span class="math display">
L = \frac{\mathrm{d}^2\Phi}{\mathrm{d}\Omega\,\mathrm{d}A^\perp}
  = \frac{\mathrm{d}^2\Phi}{\mathrm{d}\Omega\,\mathrm{d}A\,\cos\theta},
\qquad [L] = \mathrm{W}/\mathrm{m}^2/\mathrm{sr}.
</span></p></li>
<li><p>Equazione del rendering: <span class="math display">
\begin{aligned}
L(x \rightarrow \Theta) = &amp;L_e(x \rightarrow \Theta) +\\
&amp;\int_{\Omega_x} f_r(x, \Psi \rightarrow \Theta)\,L(x \leftarrow \Psi)\,\cos(N_x, \Psi)\,\mathrm{d}\omega_\Psi.
\end{aligned}
</span></p></li>
</ul>
</section>
<section id="codifica-del-colore" class="slide level1">
<h1>Codifica del colore</h1>
<ul>
<li><p>Le quantità <span class="math inline">\Phi</span>, <span class="math inline">L</span>, etc. sono tutte dipendenti dalla lunghezza d’onda <span class="math inline">\lambda</span> (radianza → <em>radianza spettrale</em>)</p></li>
<li><p>In codici numerici che simulano la propagazione della luce, dobbiamo risolvere due problemi:</p>
<ol type="1">
<li><p>Una funzione <span class="math inline">f(\lambda)</span> dipendente dalla lunghezza d’onda ha un numero infinito di gradi di libertà: come rappresentarla numericamente?</p></li>
<li><p>Nel nostro caso, la radianza viene percepita come un colore: ma come si specifica un colore quando si comanda un monitor o una stampante?</p></li>
</ol></li>
</ul>
</section>
<section class="slide level1">

<p><img data-src="./media/electromagnetic-spectrum.png" /></p>
</section>
<section id="emissioni-realistiche" class="slide level1">
<h1>Emissioni realistiche</h1>
<ul>
<li><p>Non basta <strong>un</strong> numero per codificare un colore: questo è vero solo per un corpo nero ideale (dove è sufficiente la temperatura <code>T</code>)!</p></li>
<li><p>Gli spettri di emissione di oggetti del mondo reale possono essere molto complessi (v. lezione precedente):</p>
<center>
<p><img data-src="./media/led-lighting-2.jpg" height="360" /></p>
</center></li>
</ul>
</section>
<section id="spd" class="slide level1">
<h1>SPD</h1>
<ul>
<li><p>Il termine <em>Spectral Power Distribution</em> (SPD) è un termine generico che indica la forma funzionale di una quantità dipendente da <span class="math inline">\lambda</span>: SPD della radianza, SPD del flusso, SPD dell’emittanza, etc.</p></li>
<li><p>I grafici della slide precedente sono di fatto rappresentazioni di diverse SPD.</p></li>
<li><p>La percezione che il nostro occhio ha di un colore dipende dalla SPD dell’irradianza che raggiunge i fotorecettori della retina sensibili al colore (<em>coni</em>).</p></li>
</ul>
</section>
<section id="percezione-del-colore" class="slide level1">
<h1>Percezione del colore</h1>
<ul>
<li><p>I fotorecettori presenti nell’occhio umano sono di due tipi:</p>
<ol type="1">
<li><p><strong>Bastoncelli</strong>: cellule fotorecettrici fortemente sensibili all’intensità della luce (~100 milioni per occhio)</p></li>
<li><p><strong>Coni</strong>: cellule fotorecettrici sensibili al colore della luce (~ 5 milioni per occhio)</p></li>
</ol></li>
<li><p>I bastoncelli non sono sensibili alla SPD, e sono usati soprattutto in condizioni di scarsa luminosità.</p></li>
<li><p>Ovviamente a noi oggi interessano i coni!</p></li>
</ul>
</section>
<section id="tipi-di-coni" class="slide level1">
<h1>Tipi di coni</h1>
<ul>
<li><p>Esistono tre tipi di coni:</p>
<ol type="1">
<li>Tipo S (<em>short</em>): sensibile al blu</li>
<li>Tipo M (<em>medium</em>): sensibile al verde</li>
<li>Tipo L (<em>long</em>): sensibile al rosso</li>
</ol></li>
<li><p>Ci sono più teorie che spiegano come il cervello combini le informazioni dei tre tipi di coni per rappresentare un colore.</p></li>
<li><p>Nel mondo animale c’è molta varietà: il <a href="https://www.nature.com/news/mantis-shrimp-s-super-colour-vision-debunked-1.14578">gambero mantide</a> possiede 12 tipi di coni!</p></li>
</ul>
</section>
<section class="slide level1">

<p><img data-src="./media/mantis-shrimp.jpg" /></p>
</section>
<section id="codifica-dei-colori" class="slide level1">
<h1>Codifica dei colori</h1>
<ul>
<li><p>Teoria tristimolare dei colori: è sempre possibile codificare il colore del segnale <span class="math inline">S(\lambda)</span> percepito dall’occhio umano usando tre quantità scalari legate alle risposte <span class="math inline">B_S(\lambda)</span>, <span class="math inline">B_M(\lambda)</span> e <span class="math inline">B_L(\lambda)</span> dei coni:</p>
<p><span class="math display">
\begin{aligned}
s &amp;= k \int_\lambda \mathrm{d}\lambda\,S(\lambda)\,B_S(\lambda),\\
m &amp;= k \int_\lambda \mathrm{d}\lambda\,S(\lambda)\,B_M(\lambda),\\
l &amp;= k \int_\lambda \mathrm{d}\lambda\,S(\lambda)\,B_L(\lambda).
\end{aligned}
</span></p></li>
</ul>
</section>
<section id="metamerismo-cromatico" class="slide level1">
<h1>Metamerismo cromatico</h1>
<ul>
<li><p>È possibile che due segnali diversi <span class="math inline">S_1(\lambda) \not= S_2(\lambda)</span> portino alla stessa terna <span class="math inline">(s, m, l)</span></p></li>
<li><p>In questo caso il colore percepito per i due segnali è indistinguibile all’occhio umano</p></li>
<li><p>Il fenomeno è detto <em>metamerismo cromatico</em>, e i due colori si dicono <em>metamerici</em></p></li>
<li><p>Il metamerismo dipende dal tipo di illuminazione (sole, lampada a fluorescenza, luce laser, etc.)</p></li>
</ul>
</section>
<section id="xyz-e-rgb" class="slide level1">
<h1>XYZ e RGB</h1>
<ul>
<li><p>Esistono varie codifiche di colore, basate su terne di quantità scalari: XYZ, HSV, HSL, RGB…</p></li>
<li><p>Codifiche molto usate sono RGB (monitor) e CYMK (stampanti)</p></li>
<li><p>In questo corso ci occuperemo solo della codifica RGB</p></li>
</ul>
</section>
<section id="sistema-rgb" class="slide level1">
<h1>Sistema RGB</h1>
<ul>
<li><p>La codifica RGB usa tre quantità scalari per identificare un colore: rosso, verde, blu (<strong>R</strong>ed, <strong>G</strong>reen, <strong>B</strong>lue).</p></li>
<li><p>Basato sulla sintesi <em>additiva</em> dei colori, che è perfetta per i monitor (le stampanti usano la sintesi <em>sottrattiva</em>, e usano la codifica CYMK).</p></li>
<li><p>Legato al funzionamento dei vecchi televisori a tubo catodico e replicato sui moderni schermi LED e LCD</p></li>
</ul>
<p><img data-src="./media/lcd-pixels-closeup.png" height="200" /></p>
</section>
<section id="emissione-rgb" class="slide level1">
<h1>Emissione RGB</h1>
<p>Esistono vari tipi di schermi (tubi catodici, LED, etc.), e gli spettri di emissione dei tre canali RGB possono essere diversi:</p>
<p><img data-src="./media/screen-emission.svg" height="400" /></p>
<p>Non spenderemo troppo tempo su questo per motivi di tempo.</p>
</section>
<section id="colori-rgb" class="slide level1" data-state="rgb-colors-1.0">
<h1 data-state="rgb-colors-1.0">Colori RGB</h1>
<table style="width:60%">
<tr>
<th>
Red
</th>
<th>
Green
</th>
<th>
Blue
</th>
</tr>
<tr>
<td id="val1Red">
</td>
<td id="val1Green">
</td>
<td id="val1Blue">
</td>
</tr>
<tr>
<td id="red" style="height:50px;background-color:red">
</td>
<td id="green" style="background-color:green">
</td>
<td id="blue" style="background-color:blue">
</td>
</tr>
<tr>
<td>
<input oninput="rgb1ChangeRed(this.value)" onchange="rgb1ChangeRed(this.value)" type="range" id="slideRed" name="slideRed" min="0" max="255" value="0">
</td>
<td>
<input oninput="rgb1ChangeGreen(this.value)" onchange="rgb1ChangeGreen(this.value)" type="range" id="slideGreen" name="slideGreen" min="0" max="255" value="0">
</td>
<td>
<input oninput="rgb1ChangeBlue(this.value)" onchange="rgb1ChangeBlue(this.value)" type="range" id="slideBlue" name="slideBlue" min="0" max="255" value="0">
</td>
</tr>
</table>
<div id="rgb1Change" style="margin:auto;width:50%;height:50px">

</div>
<script>
function roundComponent(value) {
    return Math.round(value * 1000) / 1000
}

function rgb1ChangeRed(value) {
    document.getElementById('val1Red').innerHTML = roundComponent(value / 255.0);
    rgb1ChangeAll();
}
function rgb1ChangeGreen(value) {
    document.getElementById('val1Green').innerHTML = roundComponent(value / 255.0);
    rgb1ChangeAll();
}
function rgb1ChangeBlue(value) {
    document.getElementById('val1Blue').innerHTML = roundComponent(value / 255.0);
    rgb1ChangeAll();
}
function rgb1ChangeAll() {
    var r = Math.round(document.getElementById('val1Red').innerHTML * 255);
    var g = Math.round(document.getElementById('val1Green').innerHTML * 255);
    var b = Math.round(document.getElementById('val1Blue').innerHTML * 255);
    document.getElementById('rgb1Change').style.backgroundColor = 
        "rgb(" + r.toString() + "," + g.toString() + "," + b.toString() + ")";
}

document.addEventListener('rgb-colors-1.0', function() {
    document.getElementById('val1Red').innerHTML = 0;
    document.getElementById('val1Green').innerHTML = 0;
    document.getElementById('val1Blue').innerHTML = 0;
    rgb1ChangeAll();
});
</script>
</section>
<section id="da-l_lambda-a-rgb" class="slide level1">
<h1>Da <span class="math inline">L_\lambda</span> a RGB</h1>
<ul>
<li><p>Equazione del rendering espressa per <span class="math inline">L_\lambda</span> <span class="math display">
\begin{aligned}
L_\lambda(x \rightarrow \Theta) = &amp;L_{e,\lambda}(x \rightarrow \Theta) +\\
&amp;\int_{\Omega_x} f_{r,\lambda}(x, \Psi \rightarrow \Theta)\,L_\lambda(x \leftarrow \Psi)\,\cos(N_x, \Psi)\,\mathrm{d}\omega_\Psi.
\end{aligned}
</span></p></li>
<li><p>Vogliamo convertire l’equazione in <span class="math inline">L_\lambda</span> in tre equazioni che forniscano <span class="math inline">R</span>, <span class="math inline">G</span>, <span class="math inline">B</span>.</p></li>
</ul>
</section>
<section class="slide level1">

<p>Se <span class="math inline">f_{r,\lambda} = f_{r, X}</span> è costante nella banda <span class="math inline">X(\lambda)</span>, allora</p>
<p><span class="math display">
\begin{aligned}
L_\lambda(x \rightarrow \Theta) = &amp;L_{e,\lambda}(x \rightarrow \Theta) +\\
&amp;\int_{\Omega_x} f_{r,\lambda}(x, \Psi \rightarrow \Theta)\,L_\lambda(x \leftarrow \Psi)\,\cos(N_x, \Psi)\,\mathrm{d}\omega_\Psi\\
\int_0^\infty X(\lambda)\,L_\lambda(x \rightarrow \Theta)\,\mathrm{d}\lambda = &amp;\int_0^\infty X(\lambda)\,L_{e,\lambda}(x \rightarrow \Theta)\,\mathrm{d}\lambda +\\
&amp;\iint\mathrm{d}\lambda\,\mathrm{d}\omega_\Psi\,X(\lambda)\,L_\lambda(x \leftarrow \Psi) f_{r,X}(x, \Psi \rightarrow \Theta)\,\cos(N_x, \Psi)\\
L_X(x \rightarrow \Theta) = &amp;L_{X,e}(x \rightarrow \Theta) +\\
&amp;\int_{\Omega_x} f_{r,X}(x, \Psi \rightarrow \Theta)\,L_X(x \leftarrow \Psi)\,\cos(N_x, \Psi)\,\mathrm{d}\omega_\Psi.
\end{aligned}
</span></p>
</section>
<section id="equazione-del-rendering" class="slide level1">
<h1>Equazione del rendering</h1>
<ul>
<li><p>Se indichiamo con <span class="math inline">R</span>, <span class="math inline">G</span> e <span class="math inline">B</span> la radianza integrata e convertita nel sistema RGB, l’equazione del rendering si traduce in un sistema di tre equazioni identiche, che si possono riscrivere come una equazione vettoriale su <span class="math inline">\vec c = (R, G, B)</span>: <span class="math display">
\begin{aligned}
\vec c(x \rightarrow \Theta) = &amp;\vec c_{e}(x \rightarrow \Theta) +\\
    &amp;\int_{\Omega_x} f_{r,R}(x, \Psi \rightarrow \Theta)\,\vec c(x \leftarrow \Psi)\,\cos(N_x, \Psi)\,\mathrm{d}\omega_\Psi.\\
\end{aligned}
</span></p></li>
<li><p>Questo ovviamente vale solo se la BRDF <span class="math inline">f_r</span> è una funzione costante all’interno delle tre risposte in banda!</p></li>
</ul>
</section>
<section id="visualizzazione-su-dispositivi" class="slide level1">
<h1>Visualizzazione su dispositivi</h1>
</section>
<section id="funzionamento-di-un-monitor" class="slide level1">
<h1>Funzionamento di un monitor</h1>
<ul>
<li>Un monitor visualizza le immagini tramite una matrice di punti (<em>pixel</em>: <em>picture element</em>)</li>
<li>Ogni punto è comandato tramite una terna RGB di valori</li>
<li>I valori possibili spaziano in un intervallo limitato</li>
<li>Il realismo nell’emissione di <span class="math inline">L</span> da parte di un monitor è quindi in genere impossibile</li>
</ul>
</section>
<section class="slide level1">

<center>
<img data-src="./media/monitor-in-dark-room.jpg" />
</center>
</section>
<section id="codifica-rgb-di-colori" class="slide level1">
<h1>Codifica RGB di colori</h1>
<ul>
<li><p>Oggi tutti i monitor e le schede grafiche supportano la cosiddetta «codifica a 16 milioni di colori»</p></li>
<li><p>Una terna RGB viene codificata da un computer usando tre valori interi a 8 bit; ad esempio, in C++ si potrebbe usare un tipo come il seguente:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> RGB <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint8_t</span> r<span class="op">,</span> g<span class="op">,</span> b<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div></li>
<li><p>Il numero totale di combinazioni RGB è <span class="math inline">2^8 \times 2^8 \times 2^8 = 2^{24} = 16\,777\,216</span>.</p></li>
</ul>
</section>
<section id="colori-rgb-1" class="slide level1" data-state="rgb-colors">
<h1 data-state="rgb-colors">Colori RGB</h1>
<table style="width:60%">
<tr>
<th>
Red
</th>
<th>
Green
</th>
<th>
Blue
</th>
</tr>
<tr>
<td id="valRed">
</td>
<td id="valGreen">
</td>
<td id="valBlue">
</td>
</tr>
<tr>
<td id="red" style="height:50px;background-color:red">
</td>
<td id="green" style="background-color:green">
</td>
<td id="blue" style="background-color:blue">
</td>
</tr>
<tr>
<td>
<input oninput="rgbChangeRed(this.value)" onchange="rgbChangeRed(this.value)" type="range" id="slideRed" name="slideRed" min="0" max="255" value="0">
</td>
<td>
<input oninput="rgbChangeGreen(this.value)" onchange="rgbChangeGreen(this.value)" type="range" id="slideGreen" name="slideGreen" min="0" max="255" value="0">
</td>
<td>
<input oninput="rgbChangeBlue(this.value)" onchange="rgbChangeBlue(this.value)" type="range" id="slideBlue" name="slideBlue" min="0" max="255" value="0">
</td>
</tr>
</table>
<div id="rgbChange" style="margin:auto;width:50%;height:50px">

</div>
<script>
function rgbChangeRed(value) {
    document.getElementById('valRed').innerHTML = value;
    rgbChangeAll();
}
function rgbChangeGreen(value) {
    document.getElementById('valGreen').innerHTML = value;
    rgbChangeAll();
}
function rgbChangeBlue(value) {
    document.getElementById('valBlue').innerHTML = value;
    rgbChangeAll();
}
function rgbChangeAll() {
    var r = document.getElementById('valRed').innerHTML;
    var g = document.getElementById('valGreen').innerHTML;
    var b = document.getElementById('valBlue').innerHTML;
    document.getElementById('rgbChange').style.backgroundColor = "rgb(" + r + "," + g + "," + b + ")";
}

document.addEventListener('rgb-colors', function() {
    document.getElementById('valRed').innerHTML = 0;
    document.getElementById('valGreen').innerHTML = 0;
    document.getElementById('valBlue').innerHTML = 0;
    rgbChangeAll();
});
</script>
</section>
<section id="comportamento-dei-monitor" class="slide level1">
<h1>Comportamento dei monitor</h1>
</section>
<section id="non-linearità-dei-monitor" class="slide level1">
<h1>Non-linearità dei monitor</h1>
<ul>
<li><p>La potenza emessa dai punti di uno schermo non varia linearmente.</p></li>
<li><p>La relazione tra il livello di emissione richiesto <span class="math inline">I</span> e il flusso <span class="math inline">\Phi</span> effettivamente emesso da un pixel è di solito nella forma <span class="math display">
\Phi \propto \left(\frac{I}{I_\text{max}}\right)^\gamma\ \text{per ciascuna delle bande R, G, B},
</span></p>
<p>dove <span class="math inline">I \in [0, I_\text{max}]</span>, e <span class="math inline">\gamma</span> è un parametro caratteristico del dispositivo.</p></li>
<li><p>Nei monitor moderni ovviamente <span class="math inline">I_\text{max} = 255</span>, e <span class="math inline">I</span> è un numero <em>intero</em>.</p></li>
</ul>
</section>
<section id="andamento-di-gamma" class="slide level1">
<h1>Andamento di <span class="math inline">\gamma</span></h1>
<p><img data-src="pd-images/60e312ab1ab2799c680c8bfa9ba1211cb7b85136.svg" data-im_fname="gamma-curve" /></p>
</section>
<section id="calibrazione-dei-monitor" class="slide level1">
<h1>Calibrazione dei monitor</h1>
<p><img data-src="./media/checkered-pattern.svg" /></p>
<p><span class="math display">
\text{value} = \left(\frac12\right)^\gamma \quad\Rightarrow\quad \gamma = \frac{\log 1/2}{\log(\text{value})}
</span></p>
</section>
<section id="calibrazione-dei-monitor-1" class="slide level1" data-state="monitor-calibration-state">
<h1 data-state="monitor-calibration-state">Calibrazione dei monitor</h1>
<table>
<tr>
<td>
<canvas id="monitor-calibration" width="300px" height="300px" style="image-rendering: pixelated">
</canvas>
</td>
<td>
<canvas id="gamma-plot" width="300px" height="300px">
</canvas>
</td>
</tr>
</table>
<div class="slidecontainer">
<input type="range" min="0.0" max="1.0"
    value="0.5" step="0.01" class="slider" id="gamma-slider">
<p id="gamma-value">
</p>
</div>
<script>
var checker_canvas_width;
var checker_canvas_height;
var checker_canvas_ctx;

var gamma_canvas_width;
var gamma_canvas_height;
var gamma_canvas_ctx;

var gamma_slider = document.getElementById("gamma-slider");
var gamma_value = document.getElementById("gamma-value");
var black_white_checkers;
gamma_value.innerHTML = gamma_slider.value;

function calc_gamma(val05) {
    return Math.log(0.5) / Math.log(val05);
}

function redraw_gamma() {
  var val = (gamma_slider.value * 255.0).toFixed(0);

  // Grey border around the image
  checker_canvas_ctx.fillStyle = `rgb(${val}, ${val}, ${val})`;
  checker_canvas_ctx.fillRect(0, 0, checker_canvas_width, checker_canvas_height);

  // Checkered image
  var cornerx = (checker_canvas_width - black_white_checkers.width) / 2;
  var cornery = (checker_canvas_height - black_white_checkers.height) / 2;
  checker_canvas_ctx.drawImage(black_white_checkers,
                               cornerx, cornery);

  // Gamma plot
  gamma_canvas_ctx.clearRect(0, 0, gamma_canvas_width, gamma_canvas_height);

  var gamma = calc_gamma(gamma_slider.value * 1.0);
  const numOfPoints = 30;
  gamma_canvas_ctx.beginPath();
  gamma_canvas_ctx.moveTo(0, gamma_canvas_height);
  for(i = 1; i <= numOfPoints; i++) {
    gamma_canvas_ctx.lineTo(gamma_canvas_height * i / numOfPoints,
                            gamma_canvas_height * (1.0 - Math.pow(i * 1.0 / numOfPoints, gamma)));
  }
  gamma_canvas_ctx.stroke();
}

function refresh_gamma_text(val) {
  var gamma = calc_gamma(val);
  gamma_value.innerHTML = `Value: ${val.toFixed(2)} (${(val * 255.0).toFixed(0)}), γ: ${gamma.toFixed(2)}`;
  redraw_gamma();
}

gamma_slider.oninput = function() {
  refresh_gamma_text(this.value * 1.0);
}

document.addEventListener('monitor-calibration-state', function() {
  var canvas = document.getElementById("monitor-calibration");
  checker_canvas_ctx = canvas.getContext("2d");
  checker_canvas_width = canvas.width;
  checker_canvas_height = canvas.height;

  canvas = document.getElementById("gamma-plot");
  gamma_canvas_ctx = canvas.getContext("2d");
  gamma_canvas_width = canvas.width;
  gamma_canvas_height = canvas.height;

  black_white_checkers = new Image();
  black_white_checkers.src = "./media/black-white-checkers.png";
  black_white_checkers.addEventListener("load", redraw_gamma, false);

  refresh_gamma_text(0.5);
});
</script>
</section>
<section id="risposta-dei-monitor" class="slide level1">
<h1>Risposta dei monitor</h1>
<ul>
<li>Quindi, quando abbiamo un colore espresso come terna RGB di numeri reali, per visualizzare il colore su un monitor occorre effettuare la conversione usando il fattore <span class="math inline">\gamma</span></li>
<li>Il colore RGB convertito con <span class="math inline">\gamma</span> è una «<a href="https://en.wikipedia.org/wiki/SRGB">terna sRGB</a>».</li>
<li>La conversione <strong>non è lineare</strong>, com’è evidente dalla sua espressione analitica</li>
<li>Quanto abbiamo visto per la conversione <span class="math inline">L_\lambda \rightarrow (R, G, B)</span> non si applica quindi a sRGB: non possiamo scrivere l’equazione del rendering direttamente nello spazio sRGB!</li>
</ul>
</section>
<section id="conversione-da-rgb-a-srgb" class="slide level1">
<h1>Conversione da RGB a sRGB</h1>
<ul>
<li>Una semplice approssimazione per la conversione da RGB, <span class="math inline">(R, G, B)</span>, a sRGB, <span class="math inline">(r, g, b)</span>, è la seguente: <span class="math display">
\begin{aligned}
r &amp;= \left[k\,R^\gamma\right],\\
g &amp;= \left[k\,G^\gamma\right],\\
b &amp;= \left[k\,B^\gamma\right],\\
\end{aligned}
</span> dove <span class="math inline">[\cdot]</span> è indica l’arrotondamento a intero, e <span class="math inline">k</span> è una costante di normalizzazione.</li>
<li>Determinare un «buon» valore per <span class="math inline">k</span> è critico!</li>
</ul>
</section>
<section id="determinazione-di-k" class="slide level1">
<h1>Determinazione di <span class="math inline">k</span></h1>
<ul>
<li>Se i valori R, G e B fossero compresi nell’intervallo <span class="math inline">[0, 1]</span>, allora basterebbe porre <span class="math inline">k = 255</span>.</li>
<li>Ma l’intervallo dei possibili valori di R, G e B è <span class="math inline">[0, \infty)</span>:
<ul>
<li>Dipende dall’unità di misura usata per <span class="math inline">L_\lambda</span>;</li>
<li>Dipende dalla scena</li>
</ul></li>
<li>Esistono alcuni standard di colore (come il CIE XYZ) che fissano una normalizzazione di riferimento (colore standard, temperatura di corpo nero…)</li>
<li>Vediamo ora come salvare immagini in un file</li>
</ul>
</section>
<section id="immagini-hdr-e-ldr" class="slide level1">
<h1>Immagini HDR e LDR</h1>
</section>
<section id="da-rgb-a-srgb" class="slide level1">
<h1>Da RGB a sRGB</h1>
<ul>
<li><p>I file più comunemente usati per le immagini (PNG, Jpeg, TIFF…) usano tutti la codifica sRGB</p></li>
<li><p>Se vogliamo che il nostro programma produca immagini facili da fruire, dobbiamo quindi convertire il risultato dell’equazione del rendering da RGB a sRGB.</p></li>
<li><p>Il <em>tone mapping</em> è il processo attraverso cui si converte un’immagine RGB in un’immagine sRGB, dove per <em>immagine</em> si intende una matrice di colori RGB.</p></li>
</ul>
</section>
<section id="tipi-di-immagini" class="slide level1">
<h1>Tipi di immagini</h1>
<p>Ci sono due categorie di immagini che sono rilevanti per questo corso:</p>
<dl>
<dt>Immagini LDR (Low-Dynamic Range)</dt>
<dd>Codificano i colori usando il sistema sRGB: le tre componenti R, G, B sono quindi numeri interi, solitamente nell’intervallo 0–255. Tutti i formati grafici più diffusi (JPEG, PNG, GIF, etc.) appartengono a questo tipo.
</dd>
<dt>Immagini HDR (High-Dynamic Range)</dt>
<dd>Codificano i colori usando il sistema RGB o sRGB, ma le tre componenti R, G, B sono numeri floating-point e coprono quindi un grande intervallo dinamico; per visualizzarle occorre quindi applicare il <em>tone mapping</em>. Esempi di questo formato sono OpenEXR e PFM.
</dd>
</dl>
</section>
<section id="funzionamento-del-nostro-codice" class="slide level1">
<h1>Funzionamento del nostro codice</h1>
<p><img data-src="pd-images/b49768aa9c1402356f8c4c87303cd56f2462f0c5.svg" data-im_fname="course-workflow" /></p>
</section>
<section id="codifica-di-immagini-raster" class="slide level1">
<h1>Codifica di immagini raster</h1>
<ul>
<li><p>Sia le immagini LDR che HDR sono codificate tramite una matrice di colori; ogni colore è solitamente una terna RGB.</p></li>
<li><p>Il file ha solitamente questo contenuto:</p>
<dl>
<dt>Header</dt>
<dd>Specifica il formato dell’immagine, le dimensioni della matrice, e a volte anche altri parametri utili (es., la data e l’ora dello scatto, le coordinate del GPS, il valore di <span class="math inline">\gamma</span> del dispositivo che ha catturato l’immagine, etc.).
</dd>
<dt>Matrice dei colori</dt>
<dd>L’ordine in cui sono salvate le righe/colonne, e anche l’ordine in cui sono salvate le componenti R, G, B (RGB/BGR) varia a seconda del formato.
</dd>
</dl></li>
</ul>
</section>
<section class="slide level1">

<center>
<img data-src="./media/image-save-order.svg" />
</center>
</section>
<section id="esempio-il-formato-ppm" class="slide level1">
<h1>Esempio: il formato PPM</h1>
<ul>
<li><p>Formato LDR, molto diffuso sui sistemi Unix.</p></li>
<li><p>Potete leggerlo e scriverlo usando <a href="http://netpbm.sourceforge.net/">NetPBM</a> o <a href="https://imagemagick.org/index.php">ImageMagick</a>. Il secondo è il più diffuso, e può essere installato sotto Ubuntu con</p>
<pre class="text"><code>$ sudo apt install imagemagick</code></pre>
<p>Potete convertire immagini col comando</p>
<pre class="text"><code>$ convert input.png output_p6.ppm                  # Formato P6
$ convert input.jpg -compress none output_p3.ppm   # Formato P3</code></pre></li>
<li><p>PPM è un formato pensato per essere scritto e letto facilmente.</p></li>
</ul>
</section>
<section id="file-ppm-p3" class="slide level1">
<h1>File PPM (P3)</h1>
<ul>
<li><p>Un file PPM è un file di testo, apribile con qualsiasi editor.</p></li>
<li><p><strong>Header</strong>:</p>
<ol type="1">
<li>I due caratteri <code>P3</code>;</li>
<li>Numero di colonne e di righe, in formato testo e separate da uno spazio;</li>
<li>Valore massimo per ciascuna delle componenti R, G, B (solitamente 255).</li>
</ol></li>
<li><p><strong>Matrice dei colori</strong>: le terne R, G, B devono essere riportate come numeri interi partendo dall’angolo in alto a sinistra a quello in basso a destra, procedendo riga per riga.</p></li>
</ul>
</section>
<section id="esempio-p3" class="slide level1">
<h1>Esempio (P3)</h1>
<pre class="text"><code>P3
3 2
255
255   0   0
  0 255   0
  0   0 255
255 255   0
255 255 255
  0   0   0</code></pre>
<center>
<img data-src="./media/tiny-image-6pixels.png" />
</center>
</section>
<section id="file-pfm" class="slide level1">
<h1>File PFM</h1>
<ul>
<li><p>È un tipo di file che si ispira a PPM, ma è un formato HDR</p></li>
<li><p><strong>Molto</strong> importante per questo corso!</p></li>
<li><p>Non è così ben supportato: sotto Ubuntu esiste solo <code>pftools</code>, che si installa con</p>
<pre class="text"><code>$ sudo apt install pftools</code></pre></li>
<li><p>Noi scriveremo i nostri tool che permetteranno di convertire file PFM in PPM, quindi <code>pftools</code> non sarà necessario</p></li>
</ul>
</section>
<section id="struttura-di-un-file-pfm" class="slide level1">
<h1>Struttura di un file PFM</h1>
<ul>
<li><p>Come i file PPM in formato P6, anche i file PFM sono parzialmente di testo e parzialmente binari.</p></li>
<li><p><strong>Header</strong>:</p>
<ol type="1">
<li>I due caratteri <code>PF</code>, più il carattere <code>0x0a</code> (ritorno a capo);</li>
<li><code>ncol nrows</code> (colonne e righe), seguito da ritorno a capo <code>0x0a</code>;</li>
<li>Il valore <code>-1.0</code>, seguito da <code>0x0a</code>.</li>
</ol></li>
<li><p><strong>Matrice dei colori</strong>: le terne R, G, B devono essere scritte come sequenze di numeri a 32 bit (quindi <strong>non</strong> testo!), da sinistra a destra e dal <strong>basso all’alto</strong> (diverso da PPM!).</p></li>
</ul>
</section>
<section id="codifica-binaria" class="slide level1">
<h1>Codifica binaria</h1>
</section>
<section id="codifica-binaria-1" class="slide level1">
<h1>Codifica binaria</h1>
<ul>
<li><p>I file binari sono il tipo più semplice: consistono di una sequenza di byte (ossia, 8 bit scritti in sequenza).</p></li>
<li><p>Ogni byte può contenere un valore intero nell’intervallo 0–255</p></li>
<li><p>Per stampare il contenuto di un file binario potete usare il comando <code>xxd</code> (sotto Ubuntu, installatelo con <code>sudo apt install xxd</code>):</p>
<pre class="text"><code>$ xxd file.bin</code></pre>
<p>(Su altri sistemi operativi potreste avere <code>hexdump</code> anziché <code>xxd</code>).</p></li>
<li><p>Salvare dati in un file binario vuol dire scrivere una sequenza di numeri binari sul disco fisso, memorizzati come byte.</p></li>
</ul>
</section>
<section class="slide level1">

<p><asciinema-player src="./cast/binary-files-73x19.cast" cols="73" rows="19" font-size="medium"></asciinema-player></p>
</section>
<section id="da-binario-a-decimale" class="slide level1">
<h1>Da binario a decimale</h1>
<ul>
<li><p>Per ragionare sui valori dei byte si usa la numerazione binaria, che ovviamente usa come base il numero 2:</p>
<pre><code>0  → 0
1  → 1
2  → 10
3  → 11
4  → 100
…</code></pre></li>
<li><p>Per un numero <code>dcba</code> espresso in una base <span class="math inline">B</span>, il suo valore è</p>
<p><span class="math display">
\text{value} = a \times B^0 + b \times B^1 + c \times B^2 + d \times B^3.
</span></p>
<p>Quindi il valore binario <code>100</code> corrisponde a <span class="math inline">0 \times 2^0 + 0 \times 2^1 + 1\times 2^2 = 4.</span></p></li>
</ul>
</section>
<section id="ordine-dei-bit-in-un-byte" class="slide level1">
<h1>Ordine dei bit in un byte</h1>
<ul>
<li><p>C’è sempre un’ambiguità di fondo nel raggruppamento dei bit in byte, e sta nel loro ordine.</p></li>
<li><p>Se un byte è formato dalla sequenza di bit <code>0011 0101</code>, esistono due modi per interpretarlo:</p>
<p><span class="math display">
\begin{aligned}
2^2 + 2^3 + 2^5 + 2^7 &amp;= 172,\\
2^5 + 2^4 + 2^2 + 2^0 &amp;= 53.
\end{aligned}
</span></p></li>
</ul>
</section>
<section id="endianness-dei-bit" class="slide level1">
<h1>«Endianness» dei bit</h1>
<ul>
<li><p>L’ordine dei bit in un byte è detto in gergo <em>bit-endianness</em>, termine tratto dai <em>Viaggi di Gulliver</em> (1726), di J. Swift:</p>
<ol type="1">
<li>La codifica <em>big-endian</em> parte dalla potenza <em>maggiore</em> («big»);</li>
<li>La codifica <em>little-endian</em> parte dalla potenza <em>minore</em> («little»).</li>
</ol></li>
<li><p>Le CPU Intel e AMD oggi usate nei personal computer usano tutte la codifica <em>little-endian</em>.</p></li>
<li><p>La codifica <em>big-endian</em> è stata molto usata in passato; oggi è impiegata in alcune CPU ARM.</p></li>
</ul>
</section>
<section id="salvare-dati-in-binario" class="slide level1">
<h1>Salvare dati in binario</h1>
<ul>
<li><p>Salvare una variabile in forma binaria non è in generale semplice!</p></li>
<li><p>In C++ ad esempio, il programma seguente <em>non</em> salva il valore di <code>x</code> in binario:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;fstream&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> x<span class="op">{</span><span class="dv">138</span><span class="op">};</span>  <span class="co">// 138 &lt; 256, so the value fits in *one* byte</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>ofstream<span class="op"> </span>outf<span class="op">{</span><span class="st">&quot;file.bin&quot;</span><span class="op">};</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  outf <span class="op">&lt;&lt;</span> x<span class="op">;</span> <span class="co">// Ouch! It writes *three* bytes: &#39;1&#39;, &#39;3&#39;, &#39;8&#39;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p>Il valore <code>138</code> è stato salvato in <em>forma testuale</em>. (Se includete <code>&lt;cstdint&gt;</code> e cambiate il tipo di <code>x</code> da <code>int</code> a <code>uint8_t</code>, il valore viene salvato come binario!)</p></li>
</ul>
</section>
    </div>
  </div>

  <script src="https://unpkg.com/reveal.js@^4//dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="https://unpkg.com/reveal.js@^4//plugin/notes/notes.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/search/search.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/zoom/zoom.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: true,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'bottom-right',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: false,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'default',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'slide',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'fade',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

       // Parallax background image
       parallaxBackgroundImage: './media/background.png', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1440,

        height: 810,

        // reveal.js plugins
        plugins: [
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script src="js/asciinema-player.js"></script>
    <script src="https://cdn.plot.ly/plotly-1.58.4.min.js"></script>
    <script type="text/javascript" src="./js/quantization.js"></script>
    </body>
</html>
