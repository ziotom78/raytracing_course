<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Maurizio Tomasi maurizio.tomasi@unimi.it">
  <title>Lezione 12</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reset.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reveal.css">
  <style>
    .reveal .sourceCode {  /* see #7635 */
      /* overflow: visible; */
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/theme/white.css" id="theme">
  <link rel="stylesheet" href="./css/custom.css"/>
  <link rel="stylesheet" href="./css/asciinema-player.css"/>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Lezione 12</h1>
  <p class="subtitle">Analisi lessicale</p>
  <p class="author">Maurizio Tomasi <a
href="mailto:maurizio.tomasi@unimi.it"
class="email">maurizio.tomasi@unimi.it</a></p>
</section>

<section id="interpretare-file-di-testo" class="slide level1">
<h1>Interpretare file di testo</h1>
</section>
<section id="contesto-del-problema" class="slide level1">
<h1>Contesto del problema</h1>
<ul>
<li><p>Finora abbiamo creato immagini fotorealistiche modificando il
comando <code>demo</code> del nostro raytracer.</p></li>
<li><p>Dovreste aver ormai riscontrato tutti una certa farraginosità
nella procedura! Tutte le volte che abbiamo voluto modificare
l’immagine, occorreva compiere queste azioni:</p>
<ol>
<li>Modificare il codice nel <code>main</code>;</li>
<li>Ricompilare;</li>
<li>Eseguire il codice e controllare il risultato.</li>
</ol></li>
<li><p>Questo approccio potrebbe non essere sostenibile: di fatto
obblighiamo gli utenti a scrivere codice nel linguaggio di
programmazione che abbiamo usato!</p></li>
</ul>
</section>
<section id="obbiettivo" class="slide level1">
<h1>Obbiettivo</h1>
<ul>
<li><p>Il nostro obbiettivo è di definire un <em>formato</em> per la
descrizione delle scene, e di scrivere del codice per
interpretarlo.</p></li>
<li><p>Una volta implementato, l’utente userà un comune editor come
Emacs o Visual Studio Code per creare un file, chiamato ad es.
<code>scene.txt</code>, ed eseguirà il programma così:</p>
<pre><code>./myprogram render scene.txt</code></pre>
<p>e gli oggetti <code>Shape</code> e <code>Material</code> saranno
creati in memoria basandosi su quanto specificato in
<code>scene.txt</code>. A differenza del comando <code>demo</code> però,
è facile modificare <code>scene.txt</code>.</p></li>
<li><p>Quello che ci aspetta è di fatto l’implementazione di un
<em>compilatore</em>!</p></li>
</ul>
</section>
<section id="categorie-di-utenti" class="slide level1">
<h1>Categorie di utenti</h1>
<ul>
<li><p>Nel caso in cui il linguaggio usato sia Julia o Python, che
ammette un uso interattivo, la soluzione migliore sarebbe quella di
definire le scene direttamente sulla REPL (o in un notebook
Jupyter/Pluto)!</p></li>
<li><p>Ma nel caso di programmi scritti in C#, Nim o Rust, una soluzione
del genere non è ovviamente percorribile.</p></li>
<li><p>(Questo è vero a maggior ragione per quelli di voi che forniscono
a ogni nuova <em>release</em> del codice i binari: in quel caso, i
vostri utenti potrebbero non avere neppure i compilatori
installati!)</p></li>
</ul>
</section>
<section id="valore-didattico-dellesercizio" class="slide level1">
<h1>Valore didattico dell’esercizio</h1>
<p>Implementare un compilatore è un’attività didatticamente molto
utile:</p>
<ol type="1">
<li><p>La teoria dei compilatori insegna come affrontare un problema
complesso (la compilazione) scomponendolo in una serie di problemi
semplici che vanno risolti in sequenza: ciò è molto istruttivo!</p></li>
<li><p>Capirete meglio la sintassi dei linguaggi usati in questo
corso.</p></li>
<li><p>Intuirete perché in certi casi i compilatori producono errori
fuorvianti.</p></li>
<li><p>In caso di errori di sintassi, dovrete fornire all’utente
informazioni chiare e precise (es., «alla riga NN manca una
parentesi»).</p></li>
<li><p>Creare nuovi linguaggi può essere molto divertente!</p></li>
</ol>
</section>
<section id="tipi-di-linguaggi" class="slide level1">
<h1>Tipi di linguaggi</h1>
<dl>
<dt><em>General-purpose languages</em></dt>
<dd>
Questi sono i «linguaggi di programmazione» che conoscete bene (C++,
Python, etc.). Sono chiamati <em>general-purpose</em> perché non sono
pensati per un dominio specifico, potendo essere usati per creare
videogiochi, sistemi operativi, librerie numeriche, applicazioni
grafiche, etc.
</dd>
<dt><em>Domain-specific languages</em> (DSL)</dt>
<dd>
Si tratta di linguaggi che risolvono un problema molto specifico, e la
cui sintassi è pensata per esprimere il problema nel modo più naturale
possibile.
</dd>
</dl>
<p>Nel nostro caso dovremo definire un DSL e implementare un compilatore
per esso. Il nostro sarà un approccio con <em>molta</em> pratica e quel
tanto che basta di teoria.</p>
</section>
<section id="dsl-in-linguaggi-general-purpose" class="slide level1">
<h1>DSL in linguaggi <em>general-purpose</em></h1>
<ul>
<li><p>Non dovreste stupirvi del fatto che oggi inventeremo un nuovo
«linguaggio» per il nostro programma: è un’attività più comune di quanto
si pensi (anche se i fisici non lo fanno quasi mai ☹).</p></li>
<li><p>È talmente comune che alcuni linguaggi <em>general-purpose</em>
prevedono la possibilità di definire DSL <strong>al proprio
interno</strong>: sono i linguaggi cosiddetti «metaprogrammabili» (es.,
<a
href="https://gigamonkeys.com/book/practical-a-simple-database.html">Common
LISP</a>, <a
href="https://docs.julialang.org/en/v1/manual/metaprogramming/">Julia</a>,
<a
href="https://www.raywenderlich.com/2780058-domain-specific-languages-in-kotlin-getting-started">Kotlin</a>,
<a href="https://forum.nim-lang.org/t/2380">Nim</a>…).</p></li>
</ul>
</section>
<section id="linguaggi-per-la-definizione-di-scene-3d"
class="slide level1">
<h1>Linguaggi per la definizione di scene 3D</h1>
</section>
<section id="panoramica" class="slide level1">
<h1>Panoramica</h1>
<ul>
<li><p>A noi non interessano database né circuiti elettrici né pagine
HTML: siamo interessati alla definizione di scene 3D.</p></li>
<li><p>Per definire il nostro linguaggio dovremmo innanzitutto farci
un’idea di cosa faccia la «concorrenza».</p></li>
<li><p>Vediamo quindi come tre <em>renderer</em> permettono di
specificare le scene che sono fornite come input: DBKTrace, POV-Ray e
YafaRay. Ovviamente tutti questi programmi funzionano da linea di
comando come farà il nostro:</p>
<pre><code>$ program input_file</code></pre></li>
</ul>
</section>
<section id="dkbtrace" class="slide level1">
<h1>DKBTrace</h1>
<ul>
<li>Nel 1986 David K. Buck rilasciò DKBTrace, un ray-tracer che usava
l’algoritmo di <em>point-light tracing</em>.</li>
<li>Scritto in C.</li>
<li>Il programma funzionava solo sul <a
href="https://en.wikipedia.org/wiki/Amiga">Commodore Amiga</a>, un
vecchio microcomputer molto usato all’epoca per la grafica.</li>
<li>Lo sviluppatore abbandonò ben presto DKBTrace per lavorare a POV-Ray
(che vedremo tra poco).</li>
</ul>
</section>
<section id="file-di-input" class="slide level1">
<h1>File di input</h1>
<pre class="text"><code>{ DKBTrace example file }
INCLUDE &quot;colors.dat&quot;
INCLUDE &quot;shapes.dat&quot;
INCLUDE &quot;textures.dat&quot;

VIEW_POINT
    LOCATION  &lt;0 0 0&gt;
    DIRECTION &lt;0 0 1&gt;
    UP        &lt;0 1 0&gt;
    RIGHT     &lt;1.33333 0 0&gt;
END_VIEW_POINT

OBJECT
    SPHERE
        &lt;0 0 3&gt; 1
    END_SPHERE
    TEXTURE
        COLOUR Red
    END_TEXTURE
END_OBJECT

OBJECT
    SPHERE
        &lt;0 0 0&gt; 1
    END_SPHERE
    TEXTURE
        COLOUR White
    END_TEXTURE
    TRANSLATE &lt;2 4 -3&gt;
    LIGHT_SOURCE
    COLOUR White
END_OBJECT</code></pre>
</section>
<section id="pov-ray" class="slide level1">
<h1><a href="http://povray.org/">POV-Ray</a></h1>
<ul>
<li><p>POV-Ray risolve l’equazione del rendering usando il
<em>point-light tracing</em> (ma che nel manuale di POV-Ray viene
chiamato semplicemente <em>raytracing</em>), esattamente come
DKBTrace.</p></li>
<li><p>La prima versione è stata rilasciata nel 1991; al momento la
versione più recente è la 3.7.0 (rilasciata nel 2013). La versione 3.8 è
in fase di preparazione.</p></li>
<li><p>In origine era stato scritto in C, e poi <a
href="https://github.com/POV-Ray/povray/tree/3.7-stable">riscritto in
C++</a>.</p></li>
<li><p>A partire dalla versione 3.0 implementa l’algoritmo <a
href="https://en.wikipedia.org/wiki/Radiosity_(computer_graphics)"><em>radiosity</em></a>
per simulare sorgenti diffuse in maniera simile al
path-tracing.</p></li>
</ul>
</section>
<section id="file-di-input-1" class="slide level1">
<h1>File di input</h1>
<div class="sourceCode" id="cb4"><pre
class="sourceCode povray"><code class="sourceCode povray"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">// POV-Ray example file</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">#include</span> <span class="st">&quot;colors.inc&quot;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="va">background</span> <span class="op">{</span> <span class="at">color</span> Cyan <span class="op">}</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#declare </span><span class="fu">tex </span><span class="op">=</span> <span class="at">texture</span> <span class="op">{</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">pigment</span> <span class="op">{</span> <span class="at">color</span> Yellow <span class="op">}</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="va">camera</span> <span class="op">{</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  <span class="va">location</span> <span class="op">&lt;</span><span class="fl">0</span><span class="op">,</span> <span class="fl">2</span><span class="op">,</span> <span class="op">-</span><span class="fl">3</span><span class="op">&gt;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  <span class="va">look_at</span>  <span class="op">&lt;</span><span class="fl">0</span><span class="op">,</span> <span class="fl">1</span><span class="op">,</span>  <span class="fl">2</span><span class="op">&gt;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="wa">sphere</span> <span class="op">{</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">&lt;</span><span class="fl">0</span><span class="op">,</span> <span class="fl">1</span><span class="op">,</span> <span class="fl">2</span><span class="op">&gt;,</span> <span class="fl">2</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  <span class="at">texture</span> <span class="op">{</span> tex <span class="op">}</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="wa">light_source</span> <span class="op">{</span> <span class="op">&lt;</span><span class="fl">2</span><span class="op">,</span> <span class="fl">4</span><span class="op">,</span> <span class="op">-</span><span class="fl">3</span><span class="op">&gt;</span> <span class="at">color</span> White <span class="op">}</span></span></code></pre></div>
</section>
<section class="slide level1">

<center>
<img data-src="media/mtpiano.webp" height="720" />
</center>
</section>
<section id="yafaray" class="slide level1">
<h1><a href="http://www.yafaray.org/">YafaRay</a></h1>
<ul>
<li><p>Scritto in C++ (repository su <a
href="https://github.com/YafaRay">GitHub</a>).</p></li>
<li><p>Risolve l’equazione del rendering usando un algoritmo di
<em>path-tracing</em>.</p></li>
<li><p>Può essere usato in <a
href="https://www.blender.org/">Blender</a> come «motore» per il
rendering.</p></li>
<li><p>Il formato delle scene è <a
href="https://en.wikipedia.org/wiki/XML">XML</a>.</p></li>
</ul>
</section>
<section id="file-di-input-2" class="slide level1">
<h1>File di input</h1>
<div class="sourceCode" id="cb5"><pre
class="sourceCode xml"><code class="sourceCode xml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>&lt;<span class="kw">scene</span>&gt;</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>&lt;<span class="kw">shader</span><span class="ot"> type=</span><span class="st">&quot;generic&quot;</span><span class="ot"> name=</span><span class="st">&quot;Default&quot;</span>&gt;</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">attributes</span>&gt;</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        &lt;<span class="kw">color</span><span class="ot"> r=</span><span class="st">&quot;0.750000&quot;</span><span class="ot"> g=</span><span class="st">&quot;0.750000&quot;</span><span class="ot"> b=</span><span class="st">&quot;0.800000&quot;</span> /&gt;</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        &lt;<span class="kw">specular</span><span class="ot"> r=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> g=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> b=</span><span class="st">&quot;0.000000&quot;</span> /&gt;</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        &lt;<span class="kw">reflected</span><span class="ot"> r=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> g=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> b=</span><span class="st">&quot;0.000000&quot;</span> /&gt;</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        &lt;<span class="kw">transmitted</span><span class="ot"> r=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> g=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> b=</span><span class="st">&quot;0.000000&quot;</span> /&gt;</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    &lt;/<span class="kw">attributes</span>&gt;</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>&lt;/<span class="kw">shader</span>&gt;</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>&lt;<span class="kw">transform</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    m00=</span><span class="st">&quot;8.532125&quot;</span><span class="ot"> m01=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> m02=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> m03=</span><span class="st">&quot;0.000000&quot;</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="ot">    m10=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> m11=</span><span class="st">&quot;8.532125&quot;</span><span class="ot"> m12=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> m13=</span><span class="st">&quot;0.000000&quot;</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="ot">    m20=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> m21=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> m22=</span><span class="st">&quot;8.532125&quot;</span><span class="ot"> m23=</span><span class="st">&quot;0.000000&quot;</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="ot">    m30=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> m31=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> m32=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> m33=</span><span class="st">&quot;1.000000&quot;</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>&gt;</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>&lt;<span class="kw">object</span><span class="ot"> name=</span><span class="st">&quot;Plane&quot;</span><span class="ot"> shader_name=</span><span class="st">&quot;Default&quot;</span> &gt;</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">attributes</span>&gt;</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    &lt;/<span class="kw">attributes</span>&gt;</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">mesh</span>&gt;</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        &lt;<span class="kw">include</span><span class="ot"> file=</span><span class="st">&quot;.\Meshes\Plane.xml&quot;</span> /&gt;</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    &lt;/<span class="kw">mesh</span>&gt;</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>&lt;/<span class="kw">object</span>&gt;</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>&lt;/<span class="kw">transform</span>&gt;</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>&lt;<span class="kw">light</span><span class="ot"> type=</span><span class="st">&quot;pathlight&quot;</span><span class="ot"> name=</span><span class="st">&quot;path&quot;</span><span class="ot"> power=</span> <span class="st">&quot;1.000000&quot;</span><span class="ot"> depth=</span><span class="st">&quot;2&quot;</span><span class="ot"> samples=</span><span class="st">&quot;16&quot;</span> </span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="ot">       use_QMC=</span><span class="st">&quot;on&quot;</span><span class="ot"> cache=</span><span class="st">&quot;on&quot;</span><span class="ot">  cache_size=</span><span class="st">&quot;0.008000&quot;</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a><span class="ot">       angle_threshold=</span><span class="st">&quot;0.200000&quot;</span><span class="ot">  shadow_threshold=</span><span class="st">&quot;0.200000&quot;</span> &gt;</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>&lt;/<span class="kw">light</span>&gt;</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>&lt;<span class="kw">camera</span><span class="ot"> name=</span><span class="st">&quot;Camera&quot;</span><span class="ot"> resx=</span><span class="st">&quot;1024&quot;</span><span class="ot"> resy=</span><span class="st">&quot;576&quot;</span><span class="ot"> focal=</span><span class="st">&quot;1.015937&quot;</span> &gt;</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">from</span><span class="ot"> x=</span><span class="st">&quot;0.323759&quot;</span><span class="ot"> y=</span><span class="st">&quot;-7.701275&quot;</span><span class="ot"> z=</span><span class="st">&quot;2.818493&quot;</span> /&gt;</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">to</span><span class="ot"> x=</span><span class="st">&quot;0.318982&quot;</span><span class="ot"> y=</span><span class="st">&quot;-6.717273&quot;</span><span class="ot"> z=</span><span class="st">&quot;2.640400&quot;</span> /&gt;</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">up</span><span class="ot"> x=</span><span class="st">&quot;0.323330&quot;</span><span class="ot"> y=</span><span class="st">&quot;-7.523182&quot;</span><span class="ot"> z=</span><span class="st">&quot;3.802506&quot;</span> /&gt;</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>&lt;/<span class="kw">camera</span>&gt;</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>&lt;<span class="kw">filter</span><span class="ot"> type=</span><span class="st">&quot;dof&quot;</span><span class="ot"> name=</span><span class="st">&quot;dof&quot;</span><span class="ot"> focus=</span><span class="st">&quot;7.97854234329&quot;</span><span class="ot"> near_blur=</span><span class="st">&quot;10.000000&quot;</span></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a><span class="ot">        far_blur=</span><span class="st">&quot;10.000000&quot;</span><span class="ot"> scale=</span><span class="st">&quot;2.000000&quot;</span>&gt;</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>&lt;/<span class="kw">filter</span>&gt;</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>&lt;<span class="kw">filter</span><span class="ot"> type=</span><span class="st">&quot;antinoise&quot;</span><span class="ot"> name=</span><span class="st">&quot;Anti Noise&quot;</span><span class="ot"> radius=</span><span class="st">&quot;1.000000&quot;</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a><span class="ot">        max_delta=</span><span class="st">&quot;0.100000&quot;</span>&gt;</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>&lt;/<span class="kw">filter</span>&gt;</span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>&lt;<span class="kw">background</span><span class="ot"> type=</span><span class="st">&quot;HDRI&quot;</span><span class="ot"> name=</span><span class="st">&quot;envhdri&quot;</span><span class="ot"> exposure_adjust=</span><span class="st">&quot;1&quot;</span>&gt;</span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">filename</span><span class="ot"> value=</span><span class="st">&quot;Filename.HDR&quot;</span> /&gt;</span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>&lt;/<span class="kw">background</span>&gt;</span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>&lt;<span class="kw">render</span><span class="ot"> camera_name=</span><span class="st">&quot;Camera&quot;</span><span class="ot"> AA_passes=</span><span class="st">&quot;2&quot;</span><span class="ot"> AA_minsamples=</span><span class="st">&quot;2&quot;</span></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a><span class="ot">        AA_pixelwidth=</span><span class="st">&quot;1.500000&quot;</span><span class="ot"> AA_threshold=</span><span class="st">&quot;0.040000&quot;</span></span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a><span class="ot">        raydepth=</span><span class="st">&quot;5&quot;</span><span class="ot"> bias=</span><span class="st">&quot;0.300000&quot;</span><span class="ot"> indirect_samples=</span><span class="st">&quot;1&quot;</span></span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a><span class="ot">        gamma=</span><span class="st">&quot;1.000000&quot;</span><span class="ot"> exposure=</span><span class="st">&quot;0.000000&quot;</span><span class="ot"> background_name=</span><span class="st">&quot;envhdri&quot;</span>&gt;</span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">outfile</span><span class="ot"> value=</span><span class="st">&quot;butterfly2.tga&quot;</span>/&gt;</span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">save_alpha</span><span class="ot"> value=</span><span class="st">&quot;on&quot;</span>/&gt;</span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a>&lt;/<span class="kw">render</span>&gt;</span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a>&lt;/<span class="kw">scene</span>&gt;</span></code></pre></div>
</section>
<section class="slide level1">

<center>
<img data-src="media/yafray-example.webp" />
</center>
</section>
<section id="il-nostro-formato" class="slide level1">
<h1>Il «nostro» formato</h1>
</section>
<section id="definire-il-formato" class="slide level1">
<h1>Definire il formato</h1>
<ul>
<li><p>Ci aspetta ora un compito molto eccitante: definire il nostro
formato!</p></li>
<li><p>Potremmo ispirarci a formati molto semplici, come ad esempio il
Wavefront OBJ che avevamo descritto <a
href="./tomasi-ray-tracing-10a-other-shapes.html#wavefront-obj">tempo
fa</a>: ogni riga contiene una lettera (<code>v</code>, <code>f</code>,
<code>n</code>, etc.) seguita da una sequenza di numeri.</p></li>
<li><p>Ad esempio, potremmo definire una BRDF diffusiva (<code>d</code>)
con colore <span class="math inline">(0.3, 0.7, 0.5)</span> associata a
una sfera (<code>s</code>) centrata in <span class="math inline">(1, 3,
6)</span> di raggio <span class="math inline">r = 2</span> con un codice
del genere:</p>
<pre class="text"><code>d 0.3 0.7 0.5
s 1 3 6 2</code></pre>
<p>Ma non sarebbe affatto leggibile! Proviamo a pensare a qualcosa di
più elegante.</p></li>
</ul>
</section>
<section id="come-implementare-il-formato" class="slide level1">
<h1>Come implementare il formato</h1>
<ul>
<li><p>Un buon formato non deve essere ambiguo, e deve anche essere
facile da imparare.</p></li>
<li><p>Anziché usare lettere come <code>s</code> o <code>d</code> per
indicare diverse entità (sfera o BRDF diffusiva), useremo stringhe di
caratteri (<code>sphere</code> e <code>diffuse</code>)</p></li>
<li><p>La scrittura <code>s 1 3 6 2</code> non è chiara, perché non si
distingue il raggio dalle coordinate. Ispirandoci alla sintassi di
Python e Julia, indicheremo punti e vettori con le parentesi angolari,
ad es. <code>[1, 3, 6]</code>.</p></li>
<li><p>Implementeremo anche la possibilità di associare un nome agli
oggetti: in questo modo potremo fare riferimento a BRDF create in
precedenza (es., <code>green_matte</code>) quando definiamo nuove
<code>Shape</code>.</p></li>
</ul>
</section>
<section id="cosa-includere" class="slide level1">
<h1>Cosa includere</h1>
<ul>
<li><p>Il nostro formato serve per descrivere una scena, non per fare
rendering!</p></li>
<li><p>Per questo scopo, bisogna pensare a una sintassi per
specificare:</p>
<ul>
<li>Osservatori;</li>
<li>Forme (sfere, piani, e qualsiasi altro oggetto voi abbiate
implementato);</li>
<li>Trasformazioni;</li>
<li>Vettori;</li>
<li>BRDF, materiali e pigmenti;</li>
<li>Colori;</li>
<li>Numeri.</li>
</ul></li>
</ul>
</section>
<section id="scelte-da-compiere" class="slide level1">
<h1>Scelte da compiere</h1>
<ul>
<li><p>Dobbiamo definire una sintassi per creare oggetti, e ovviamente
ci sono varie possibilità. Ad esempio, per definire una sfera potremmo
usare una qualsiasi di queste quattro sintassi:</p>
<pre class="text"><code>sphere [1 3 6] 2
sphere([1, 3, 6], 2)
create sphere with center [1, 3, 6] and radius 2</code></pre></li>
<li><p>La scelta dell’una o dell’altra sintassi è in linea di principio
completamente nelle nostre mani!</p></li>
<li><p>Per Pytracer ho scelto la sintassi che ora illustro.</p></li>
</ul>
</section>
<section id="esempio-di-formato" class="slide level1">
<h1>Esempio di formato</h1>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Declare a floating-point variable named &quot;clock&quot;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="bu">float</span> clock(<span class="dv">150</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Declare a few new materials. Each of them includes a BRDF and a pigment</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co"># (the emitted radiance). We can split a definition over multiple lines</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co"># and indent them as we like</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>material sky_material(</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    diffuse(image(<span class="st">&quot;sky-dome.pfm&quot;</span>)),</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    uniform(<span class="op">&lt;</span><span class="fl">0.7</span>, <span class="fl">0.5</span>, <span class="dv">1</span><span class="op">&gt;</span>)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>material ground_material(</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    diffuse(checkered(<span class="op">&lt;</span><span class="fl">0.3</span>, <span class="fl">0.5</span>, <span class="fl">0.1</span><span class="op">&gt;</span>,</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>                      <span class="op">&lt;</span><span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.5</span><span class="op">&gt;</span>, <span class="dv">4</span>)),</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    uniform(<span class="op">&lt;</span><span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span><span class="op">&gt;</span>)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>material sphere_material(</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    specular(uniform(<span class="op">&lt;</span><span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span><span class="op">&gt;</span>)),</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    uniform(<span class="op">&lt;</span><span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span><span class="op">&gt;</span>)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Define a few shapes</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>sphere(sphere_material, translation([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>]))</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a><span class="co"># The language is flexible enough to permit spaces before &quot;(&quot;</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>plane (ground_material, identity)</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Here we use the &quot;clock&quot; variable! Note that vectors are notated using</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a><span class="co"># square brackets ([]) instead of angular brackets (&lt;&gt;) like colors, and</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a><span class="co"># that we can compose transformations through the &quot;*&quot; operator</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>plane(sky_material, translation([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">100</span>]) <span class="op">*</span> rotation_y(clock))</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Define a perspective camera, with some transformation, aspect</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a><span class="co"># ratio, and eye-screen distance</span></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>camera(perspective, rotation_z(<span class="dv">30</span>) <span class="op">*</span> translation([<span class="op">-</span><span class="dv">4</span>, <span class="dv">0</span>, <span class="dv">1</span>]), <span class="fl">1.0</span>, <span class="fl">1.0</span>)</span></code></pre></div>
</section>
<section id="come-interpretare-il-formato" class="slide level1">
<h1>Come interpretare il formato?</h1>
<ul>
<li><p>Da un punto di vista puramente concettuale, il compito che ci
aspetta non è poi così diverso da quello di leggere un file
PFM…</p></li>
<li><p>…con la differenza però che il file di input che consideriamo ora
è molto più complesso e «duttile» del formato PFM!</p></li>
<li><p>Questa maggiore versatilità comporta molti più rischi di errore:
è facile per l’utente che crea una scena dimenticarsi una virgola, o
confondere la notazione <code>&lt;&gt;</code> (colori) con
<code>[]</code> (vettori). Dobbiamo quindi prestare grande cura alla
segnalazione degli errori all’utente!</p></li>
<li><p>Per interpretare questo tipo di file occorre procedere per
gradi.</p></li>
</ul>
</section>
<section id="paragone-coi-compilatori" class="slide level1">
<h1>Paragone coi compilatori</h1>
<ul>
<li><p>Il lavoro che ci aspetta è simile alla scrittura di un
compilatore vero e proprio. Ad esempio, il comando <code>g++</code>
legge in input file di testo fatti come il seguente:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="at">const</span> <span class="dt">char</span> <span class="op">*</span>argv<span class="op">[])</span> <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;The name of the program is &quot;</span> <span class="op">&lt;&lt;</span> argv<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>e produce in output un file eseguibile che contiene la sequenza di
istruzioni macchina corrispondenti a questo codice C++.</p></li>
<li><p>Nel nostro caso il codice deve costruire in memoria una serie di
variabili che contengono le <code>Shape</code>, la <code>Camera</code> e
i <code>Material</code> di cui è composta la scena.</p></li>
</ul>
</section>
<section id="terminologia" class="slide level1">
<h1>Terminologia</h1>
<p>Per chi lavora con interpreti/compilatori è prassi usare alcuni
termini della linguistica:</p>
<ul>
<li>L’analisi del <strong>lessico</strong> studia la tipologia delle
singole parole, e stabilisce ad esempio che la parola «invece» è
corretta, mentre «invecie» è sbagliata.</li>
<li>L’analisi della <strong>sintassi</strong> studia i rapporti tra gli
elementi di una espressione, e stabilisce ad esempio che un verbo non
può mai seguire un articolo («un mangeremmo»).</li>
<li>L’analisi della <strong>semantica</strong> studia il rapporto tra
una espressione come «la casa in fondo alla strada» e l’oggetto
extra-linguistico a cui si fa riferimento (appunto, quella particolare
casa in fondo alla strada).</li>
</ul>
</section>
<section id="linguaggi-informatici" class="slide level1">
<h1>Linguaggi informatici</h1>
<p>Nel caso di un «linguaggio» informatico come il nostro, la sua
analisi viene solitamente fatta seguendo lo stesso ordine della slide
precedente:</p>
<ol type="1">
<li>Un’analisi <strong>lessicale</strong>, in cui si verifica che le
singole «parole» siano scritte correttamente;</li>
<li>Un’analisi <strong>sintattica</strong>, in cui si considera come le
singole «parole» sono concatenate;</li>
<li>Un’analisi <strong>semantica</strong>, il cui risultato è l’insieme
di variabili in memoria del tipo corrispondente (nel nostro caso,
<code>Sphere</code>, <code>Plane</code>, <code>SpecularBRDF</code>,
etc.), come se fossero state dichiarate ed inizializzate direttamente
nel nostro codice sorgente.</li>
</ol>
</section>
<section id="workflow-di-un-compilatore" class="slide level1">
<h1>Workflow di un compilatore</h1>
<p><img
data-src="pd-images/1b97899d4af7f1e7b9e8c2b7c849aa0ed68fd812.svg"
data-im_fname="compiler-architecture" /></p>
<ul>
<li>Il <em>lexer</em> scompone il codice sorgente in elementi semplici,
chiamati <em>token</em>, e segnala gli errori di natura lessicale;</li>
<li>Il <em>parser</em> analizza la sequenza dei <em>token</em> per
legarli tra loro e comprenderne la sintassi e la semantica;</li>
<li>L’<em>AST builder</em> crea il cosiddetto <em>Abstract Syntax
Tree</em> (non usato nel nostro caso);</li>
<li>L’<em>optimizer</em> applica ottimizzazioni all’AST (non usato nel
nostro caso);</li>
<li>Dall’AST ottimizzato viene generato l’eseguibile (non usato nel
nostro caso).</li>
</ul>
</section>
<section id="esempio-analisi-lessicale" class="slide level1">
<h1>Esempio: analisi lessicale</h1>
<ul>
<li><p>Consideriamo la frase</p>
<pre><code>Il bambino mangia la mela</code></pre></li>
<li><p>Quello che farebbe un <em>lexer</em> della lingua italiana è
produrre questa lista:</p>
<ol type="1">
<li><code>Il</code>: articolo determinativo maschile singolare</li>
<li><code>bambino</code>: nome comune di persona maschile singolare</li>
<li><code>mangia</code>: voce del verbo mangiare, modo indicativo, tempo
presente, terza persona singolare…</li>
</ol></li>
</ul>
</section>
<section id="esempio-analisi-lessicale-1" class="slide level1">
<h1>Esempio: analisi lessicale</h1>
<ul>
<li><p>Consideriamo le prime righe dell’esempio mostrato poco fa:</p>
<pre class="text"><code># Declare a variable named &quot;clock&quot;
float clock(150)</code></pre></li>
<li><p>Il risultato dell’analisi lessicale delle linee sopra è la
produzione della lista di token seguente (da cui sono già rimossi spazi
bianchi e commenti):</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>[</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    KeywordToken(TOKEN_FLOAT), <span class="co"># A &quot;keyword&quot;, because &quot;float&quot; is a reserved word</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    IdentifierToken(<span class="st">&quot;clock&quot;</span>),  <span class="co"># An &quot;identifier&quot; is a variable name</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    SymbolToken(<span class="st">&quot;(&quot;</span>),</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    LiteralNumberToken(<span class="fl">150.0</span>),</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    SymbolToken(<span class="st">&quot;)&quot;</span>),</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div></li>
</ul>
</section>
<section id="esempio-analisi-sintattica" class="slide level1">
<h1>Esempio: analisi sintattica</h1>
<ul>
<li><p>Consideriamo la frase</p>
<pre><code>Il bambino mangia la mela</code></pre></li>
<li><p>L’analisi sintattica verifica che le concordanze siano corrette
(articolo/nome, nome/verbo…)</p></li>
<li><p>Determina quale è il soggetto e quale il complemento
oggetto</p></li>
</ul>
</section>
<section id="esempio-analisi-sintattica-1" class="slide level1">
<h1>Esempio: analisi sintattica</h1>
<ul>
<li><p>L’analisi sintattica parte dalla sequenza di token prodotta
dall’analisi lessicale:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># List of tokens for `float clock(150)`:</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>[</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    KeywordToken(TOKEN_FLOAT), IdentifierToken(<span class="st">&quot;clock&quot;</span>), SymbolToken(<span class="st">&quot;(&quot;</span>),</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    LiteralNumberToken(<span class="fl">150.0</span>), SymbolToken(<span class="st">&quot;)&quot;</span>),</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div></li>
<li><p>L’analisi sintattica deve verificare che la sequenza di token sia
corretta: se il primo token è la parola chiave <code>float</code>,
allora significa che stiamo definendo una variabile floating-point. È
quindi necessario che il token successivo contenga il nome della
variabile (deve essere un <em>identificatore</em>), seguito dal valore
numerico racchiuso tra le parentesi.</p></li>
</ul>
</section>
<section id="errori-di-sintassi" class="slide level1">
<h1>Errori di sintassi</h1>
<ul>
<li><p>Prendendo spunto da questo esempio, considerate il seguente
codice C++:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="cf">if</span><span class="op">;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;Enter a number: &quot;</span><span class="op">;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cin<span class="op"> &gt;&gt;</span> <span class="cf">if</span><span class="op">;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span><span class="cf">if</span> <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;The number is even</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span></code></pre></div></li>
<li><p>Questo codice sopra è perfettamente comprensibile da un essere
umano, ma il C++ lo vieta! (L’equivalente in Scheme sarebbe invece
ok).</p></li>
<li><p>L’errore è causato dal fatto che la sintassi del C++ richiede che
il tipo della variabile (<code>int</code>) sia seguito da un
<em>identificatore</em>, e non da una <em>keyword</em>
(<code>if</code>).</p></li>
</ul>
</section>
<section id="esempio-analisi-semantica" class="slide level1">
<h1>Esempio: analisi semantica</h1>
<pre class="text"><code># Declare a variable named &quot;clock&quot;
float clock(150)</code></pre>
<ul>
<li><p>Il risultato dell’analisi sintattica dice che l’istruzione
richiede di creare una variabile <code>clock</code> e di assegnarle il
valore <code>150.0</code>.</p></li>
<li><p>L’analisi semantica deve verificare che la definizione di questa
variabile non crei inconsistenze. Ad esempio, potrebbe verificare che
<code>clock</code> non fosse già stata definita in precedenza, e nel
caso scegliere una di queste possibilità:</p>
<ol type="1">
<li>Produrre un errore (è il caso del C++);</li>
<li>Aggiornare il valore della variabile <code>clock</code> anziché
definirne una nuova con lo stesso nome (è il caso del Python e di
Scheme).</li>
</ol></li>
</ul>
</section>
<section id="implementazione" class="slide level1">
<h1>Implementazione</h1>
</section>
<section id="funzionamento-del-lexer" class="slide level1">
<h1>Funzionamento del <em>lexer</em></h1>
<ul>
<li><p>Il <em>lexer</em> è la parte di codice che si occupa dell’analisi
lessicale.</p></li>
<li><p>Il suo compito è di leggere da uno <em>stream</em> (tipicamente
un file) e produrre in output una lista di <em>token</em>, classificati
secondo il loro tipo.</p></li>
<li><p>Per motivi di efficienza, i lexer <em>non</em> restituiscono una
lista di token, ma leggono i <em>token</em> uno alla volta,
restituendoli man mano che li interpretano, e si usano quindi così:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    token <span class="op">=</span> read_token()</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> token.eof():</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    …</span></code></pre></div></li>
</ul>
</section>
<section id="output-di-un-lexer" class="slide level1">
<h1>Output di un <em>lexer</em></h1>
<ul>
<li><p>Un <em>lexer</em> deve saper classificare i <em>token</em> a
seconda del loro tipo.</p></li>
<li><p>A seconda del linguaggio esistono vari tipi di token; nel nostro
caso abbiamo:</p>
<ol>
<li><em>Keyword</em>: una parola chiave del linguaggio, come
<code>sphere</code> e <code>diffuse</code>;</li>
<li><em>Identifier</em>: il nome di una variabile/tipo/funzione come
<code>clock</code>;</li>
<li><em>Numeric literal</em>: un numero come <code>150</code>,
possibilmente distinto tra <em>integer literal</em> e <em>floating-point
literal</em> (noi non faremo distinzione);</li>
<li><em>String literal</em>: una stringa di caratteri, solitamente
racchiusa tra <code>"</code> (doppi apici) o <code>'</code> (singoli
apici);</li>
<li><em>Symbol</em>: un carattere non alfanumerico, come <code>(</code>,
<code>+</code>, <code>,</code>, etc.) Non considereremo simboli composti
da più caratteri (es., <code>&gt;=</code> in C++).</li>
</ol></li>
</ul>
</section>
<section id="tipi-di-token" class="slide level1">
<h1>Tipi di <em>token</em></h1>
<ul>
<li><p>L’implementazione del tipo <code>Token</code> ci consente di
approfondire il sistema dei tipi dei linguaggi che abbiamo usato nel
corso.</p></li>
<li><p>Seguendo un approccio OOP, i diversi tipi di <em>token</em>
potrebbero essere classi derivate da un tipo base, <code>Token</code>
appunto: si costruisce quindi una gerarchia di classi.</p></li>
<li><p>Questa soluzione funziona, ed è ciò che ho usato in pytracer. Non
è però la soluzione più comoda!</p></li>
</ul>
</section>
<section class="slide level1">

<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Token:</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;A lexical token, used when parsing a scene file&quot;&quot;&quot;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> LiteralNumberToken(Token):</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;A token containing a literal number&quot;&quot;&quot;</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, value: <span class="bu">float</span>):</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.value <span class="op">=</span> value</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">str</span>(<span class="va">self</span>.value)</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SymbolToken(Token):</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;A token containing a symbol (e.g., a comma or a parenthesis)&quot;&quot;&quot;</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, symbol: <span class="bu">str</span>):</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>()</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.symbol <span class="op">=</span> symbol</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.symbol</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Etc.</span></span></code></pre></div>
</section>
<section id="tokens-e-gerarchie-di-classi" class="slide level1">
<h1><em>Tokens</em> e gerarchie di classi</h1>
<ul>
<li><p>Ci sono alcuni svantaggi nell’usare una gerarchia di classi:</p>
<ol>
<li>Il codice diventa molto verboso: si devono implementare tante
classi, tutte molto simili tra loro.</li>
<li>Le gerarchie di classi sono pensate per essere <em>estendibili</em>:
posso sempre definire una nuova classe derivata da <code>Token</code>.
Ma nel caso di un linguaggio, l’elenco dei tipi di token è fissato ed è
molto difficile che cambi.</li>
</ol></li>
<li><p>Il tipo più indicato per un <em>token</em> è un <em>sum
type</em>, chiamato anche <em>tagged union</em> o <em>object
variant</em>, che si contrappone ai <em>product type</em> che tutti voi
conoscete (probabilmente senza saperlo). Vediamo in cosa
consistono.</p></li>
</ul>
</section>
<section id="product-types" class="slide level1">
<h1><em>Product types</em></h1>
<ul>
<li><p>Le <code>struct</code>/<code>class</code> di linguaggi come C++,
Python e Julia sono <em>product types</em>, perché dal punto di vista
formale sono un <strong>prodotto cartesiano</strong> tra
insiemi.</p></li>
<li><p>Consideriamo questa definizione in C++:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MyStruct <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int32_t</span> a<span class="op">;</span> <span class="co">// Can be any value in the set I of all 32-bit signed integers</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint8_t</span> c<span class="op">;</span> <span class="co">// Can be any value in the set B of all 8-bit unsigned bytes</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Se l’insieme di tutti i valori assumibili da un <code>int32_t</code>
e da un <code>uint8_t</code> è denominato rispettivamente con <span
class="math inline">I</span> e <span class="math inline">B</span>,
allora una variabile <code>MyStruct var</code> è tale per cui <span
class="math inline">\mathtt{var} \in I \times B</span>.</p></li>
</ul>
</section>
<section id="sum-types" class="slide level1">
<h1><em>Sum types</em></h1>
<ul>
<li><p>Un <em>sum type</em> combina tra loro più tipi usando la
<em>somma insiemistica</em> (ossia l’unione <span
class="math inline">\cup</span>) anziché il prodotto
cartesiano.</p></li>
<li><p>Nel nostro esempio C++, i <em>sum types</em> si definiscono
tramite la parola chiave <code>union</code> (molto appropriata!):</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> MyUnion <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int32_t</span> a<span class="op">;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint8_t</span> c<span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div></li>
<li><p>In questo caso, la variabile <code>MyUnion var</code> è tale per
cui <span class="math inline">\mathtt{var} \in I \cup B</span>: puo
essere un <code>int32_t</code> <strong>oppure</strong> un
<code>uint8_t</code>, ma non entrambi.</p></li>
</ul>
</section>
<section id="uso-di-union" class="slide level1">
<h1>Uso di <code>union</code></h1>
<div class="sourceCode" id="cb21"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> MyUnion <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int32_t</span> a<span class="op">;</span>   <span class="co">// This takes 4 bytes</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint8_t</span> c<span class="op">;</span>   <span class="co">// This takes 1 byte</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="co">/* The size in memory of MyUnion is *not* 4+1 == 5, but it is max(4, 1) == 4</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="co"> *</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="co"> * &lt;-------a-------&gt;</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="co"> * +---+---+---+---+</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="co"> * | 1 | 2 | 3 | 4 |</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="co"> * +---+---+---+---+</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a><span class="co"> * &lt;-c-&gt;</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    MyUnion s<span class="op">;</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    s<span class="op">.</span>a <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>   <span class="co">// Integer</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> s<span class="op">.</span>a <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    s<span class="op">.</span>c <span class="op">=</span> <span class="dv">24</span><span class="bu">U</span><span class="op">;</span>  <span class="co">// This replaces the value 10 (signed) with the value (24) unsigned</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> s<span class="op">.</span>c <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="sum-types-e-token" class="slide level1">
<h1><em>Sum types</em> e <em>token</em></h1>
<ul>
<li><p>Un <em>token</em> è idealmente rappresentato da un <em>sum
type</em>. Supponiamo di avere per semplicità due soli tipi di token,
definiti in un codice C++:</p>
<ol>
<li><em>Literal number</em> (es., <code>150</code>), rappresentato in
memoria come un <code>float</code>;</li>
<li><em>Literal string</em> (es., <code>"filename.pfm"</code>),
rappresentato da <code>std::string</code>;</li>
</ol></li>
<li><p>Consideriamo ora una funzione <code>read_token(stream)</code> che
restituisce il token successivo letto da <code>stream</code>: può
restituire un <em>literal number</em> oppure un <em>literal
string</em>.</p></li>
<li><p>Se i numeri appartengono all’insieme <span
class="math inline">N</span> e le stringhe a <span
class="math inline">S</span>, allora è chiaro che il token
<code>t</code> è tale per cui <span class="math inline">\mathtt{t} \in N
\cup S</span>: può essere uno dei due tipi, ma non più tipi
contemporaneamente. È quindi logicamente un <em>sum type</em>!</p></li>
</ul>
</section>
<section id="sum-types-vs-gerarchie" class="slide level1">
<h1><em>Sum types</em> vs gerarchie</h1>
<ul>
<li><p>Una <code>union</code> racchiude all’interno di un’unica
definizione tutti i tipi:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> MyUnion <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int32_t</span> a<span class="op">;</span>   <span class="co">// This takes 4 bytes</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint8_t</span> c<span class="op">;</span>   <span class="co">// This takes 1 byte</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div></li>
<li><p>È più semplice da leggere e da capire di una gerarchia di
classi:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Value <span class="op">{};</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Int32Value <span class="op">:</span> Value <span class="op">{</span> <span class="dt">int32_t</span> a<span class="op">;</span> <span class="op">};</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> UInt8Value <span class="op">:</span> Value <span class="op">{</span> <span class="dt">uint8_t</span> c<span class="op">;</span> <span class="op">};</span></span></code></pre></div></li>
</ul>
</section>
<section id="sum-types-e-token-1" class="slide level1">
<h1><em>Sum types</em> e <em>token</em></h1>
<ul>
<li><p>Potremmo allora definire il tipo <code>Token</code> in C++ nel
modo seguente:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> Token <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">float</span> number<span class="op">;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>   <span class="bu">std::</span>string<span class="op"> </span>string<span class="op">;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div></li>
<li><p>Una volta assegnato un valore però non c’è modo di capire a quale
dei due insiemi <span class="math inline">N</span> o <span
class="math inline">S</span> appartenga l’elemento (le
<code>union</code> non sono <em>tagged</em>):</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>Token my_token<span class="op">;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>my_token <span class="op">=</span> read_token<span class="op">(</span>stream<span class="op">);</span>  <span class="co">// Read the next token from the stream</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>my_token<span class="op">.???)</span>   <span class="co">// How can I check if it is a &quot;literal number&quot; or a &quot;string&quot;?</span></span></code></pre></div></li>
</ul>
</section>
<section id="tagged-unions-in-cc" class="slide level1">
<h1><em>Tagged unions</em> in C/C++</h1>
<div class="sourceCode" id="cb26"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Kinds of tokens. Here we just consider two types</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="kw">class</span> TokenType <span class="op">{</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  LITERAL_NUMBER<span class="op">,</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  LITERAL_STRING<span class="op">,</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="co">// The sum type.</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> TokenValue <span class="op">{</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> number<span class="op">;</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>string<span class="op"> </span>string<span class="op">;</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// The default constructor and destructor are *mandatory* for unions to</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// be used in structs/classes</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>  TokenValue<span class="op">()</span> <span class="op">:</span> number<span class="op">(</span><span class="fl">0.0</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">~</span>TokenValue<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a><span class="co">// Here is the &quot;Token&quot; type! We just combine `TokenType` and `TokenValue`</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a><span class="co">// in a product type, which implements a proper &quot;tagged union&quot;.</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Token <span class="op">{</span></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>  TokenType type<span class="op">;</span>    <span class="co">// The &quot;tag&quot;</span></span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>  TokenValue value<span class="op">;</span>  <span class="co">// The &quot;union&quot;</span></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a>  Token<span class="op">()</span> <span class="op">:</span> type<span class="op">(</span>TokenType<span class="op">::</span>LITERAL_NUMBER<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> assign_number<span class="op">(</span><span class="dt">float</span> val<span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true" tabindex="-1"></a>      type <span class="op">=</span> TokenType<span class="op">::</span>LITERAL_NUMBER<span class="op">;</span></span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true" tabindex="-1"></a>      value<span class="op">.</span>number <span class="op">=</span> val<span class="op">;</span></span>
<span id="cb26-29"><a href="#cb26-29" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb26-30"><a href="#cb26-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-31"><a href="#cb26-31" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> assign_string<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op"> &amp;</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-32"><a href="#cb26-32" aria-hidden="true" tabindex="-1"></a>      type <span class="op">=</span> TokenType<span class="op">::</span>LITERAL_STRING<span class="op">;</span></span>
<span id="cb26-33"><a href="#cb26-33" aria-hidden="true" tabindex="-1"></a>      value<span class="op">.</span>string <span class="op">=</span> s<span class="op">;</span></span>
<span id="cb26-34"><a href="#cb26-34" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb26-35"><a href="#cb26-35" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb26-36"><a href="#cb26-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-37"><a href="#cb26-37" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb26-38"><a href="#cb26-38" aria-hidden="true" tabindex="-1"></a>  Token my_token<span class="op">;</span></span>
<span id="cb26-39"><a href="#cb26-39" aria-hidden="true" tabindex="-1"></a>  token<span class="op">.</span>assign_number<span class="op">(</span><span class="fl">150.0</span><span class="op">);</span></span>
<span id="cb26-40"><a href="#cb26-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="tagged-unions-in-cc-1" class="slide level1">
<h1><em>Tagged unions</em> in C/C++</h1>
<ul>
<li><p>L’esempio mostra che per implementare una <em>tagged union</em>
occorrono <em>tre</em> tipi:</p>
<ol>
<li>Il tipo <code>Token</code> contiene al suo interno il cosiddetto
<em>tag</em> (che indica se il token appartiene a <span
class="math inline">N</span> o a <span
class="math inline">S</span>);</li>
<li>Il tipo <code>TokenType</code> è il <em>tag</em>, ed un
<code>enum</code> (C) o <code>enum class</code> (C++);</li>
<li>Il tipo <code>TokenValue</code> è la <code>union</code> vera e
propria, che in C++ va corredata di un costruttore e un distruttore di
default per poter essere usata in <code>Token</code>.</li>
</ol></li>
<li><p>Tutto ciò è necessario in quei linguaggi che non supportano le
<em>tagged union</em> (vedi <a
href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/sum-types">questo
post</a> per una panoramica dei linguaggi che hanno questa
lacuna).</p></li>
<li><p>Nim supporta in maniera nativa i tag: vedete la sezione del
manuale <a
href="https://nim-lang.org/docs/manual.html#types-object-variants"><em>Object
variants</em></a></p></li>
</ul>
</section>
<section id="esaustività-dei-controlli" class="slide level1">
<h1>Esaustività dei controlli</h1>
<div class="sourceCode" id="cb27"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Let&#39;s assume we have four token types</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="kw">class</span> TokenType <span class="op">{</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  LITERAL_NUMBER<span class="op">,</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  LITERAL_STRING<span class="op">,</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  SYMBOL<span class="op">,</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  KEYWORD<span class="op">,</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print_token<span class="op">(</span><span class="at">const</span> Token <span class="op">&amp;</span> t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span><span class="op">(</span>t<span class="op">.</span>type<span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> TokenType<span class="op">::</span>LITERAL_NUMBER<span class="op">:</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> t<span class="op">.</span>value<span class="op">.</span>number<span class="op">;</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> TokenType<span class="op">::</span>LITERAL_STRING<span class="op">:</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> t<span class="op">.</span>value<span class="op">.</span>string<span class="op">;</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> TokenType<span class="op">::</span>SYMBOL<span class="op">:</span> <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> t<span class="op">.</span>value<span class="op">.</span>symbol<span class="op">;</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Oops! I forgot TokenType::KEYWORD, but not every compiler will produce a warning!</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="sum-types-fatti-bene" class="slide level1">
<h1><em>Sum types</em> fatti bene</h1>
<ul>
<li><p>Linguaggi come <a
href="https://wiki.haskell.org/Algebraic_data_type">Haskell</a>, i
derivati di ML (es., <a href="https://ocaml.org/">OCaml</a>, F#), <a
href="https://www.freepascal.org/docs-html/ref/refsu15.html">Pascal</a>,
<a
href="https://nim-lang.org/docs/tut2.html#object-oriented-programming-object-variants">Nim</a>,
<a
href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html">Rust</a>,
etc., consentono di definire <em>sum types</em> in maniera molto più
naturale.</p></li>
<li><p>Ad esempio, ecco come definire il tipo <code>Token</code> in
OCaml:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> token = </span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    | LiteralNumber <span class="kw">of</span> <span class="dt">float</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    | LiteralString <span class="kw">of</span> <span class="dt">string</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    | Symbol <span class="kw">of</span> <span class="dt">char</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    | Keyword <span class="kw">of</span> <span class="dt">string</span>;</span></code></pre></div>
<p>Non c’è bisogno di definire una lunga gerarchia di classi!</p></li>
</ul>
</section>
<section id="esaustività-in-ocaml" class="slide level1">
<h1>Esaustività in OCaml</h1>
<ul>
<li><p>In linguaggi come <a href="https://ocaml.org/">OCaml</a> e <a
href="https://fsharpforfunandprofit.com/posts/discriminated-unions/">F#</a>,
i controlli sui <em>sum types</em> sono esaustivi:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> print_token tok = <span class="kw">match</span> tok <span class="kw">with</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>   | LiteralNumber a -&gt; <span class="dt">print_float</span> a</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>   | LiteralString s -&gt; <span class="dt">print_string</span> s</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>   | Symbol c -&gt; <span class="dt">print_char</span> c;</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="co">(* Warning 8 [partial-match]: this pattern-matching is not exhaustive.</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="co"> * Here is an example of a case that is not matched:</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="co"> * Keyword _                                         *)</span></span></code></pre></div></li>
<li><p>I <em>sum types</em> rappresentano gerarchie di classi «rigide»,
dove c’è un solo antenato (<code>token</code>) e le classi figlie sono
note a priori: proprio il caso dei token! Linguaggi come <a
href="https://ocaml.org/">OCaml</a> sono infatti spesso usati per
scrivere compilatori (es., <a
href="http://www.fftw.org/fftw-paper-ieee.pdf">FFTW</a>, <a
href="https://www.reddit.com/r/rust/comments/18b808/is_the_original_ocaml_compiler_still_available/">Rust</a>).</p></li>
</ul>
</section>
<section id="sum-types-vs-gerarchie-1" class="slide level1">
<h1><em>Sum types</em> vs gerarchie</h1>
<ul>
<li><p>Un <em>sum type</em> come <code>union</code> in C/C++ è utile
quando il numero di tipi (<code>LiteralToken</code>,
<code>SymbolToken</code>, …) è limitato e non cambierà facilmente,
mentre il numero di <em>metodi</em> da applicare a quel tipo (es.,
<code>print_token</code>) può crescere indefinitamente.</p></li>
<li><p>Una gerarchia di classi è utile nel caso contrario: il numero di
tipi può crescere in numero potenzialmente illimitato, ma il numero di
metodi è in linea di principio limitato. Un buon esempio è
<code>Shape</code>: si possono definire infinite forme
(<code>Sphere</code>, <code>Plane</code>, <code>Cone</code>,
<code>Cylinder</code>, <code>Parabola</code>, etc.), ma il numero di
operazioni da fare è limitato (<code>ray_intersection</code>,
<code>is_point_inside</code>, etc.).</p></li>
</ul>
</section>
<section id="funzionamento-di-un-lexer" class="slide level1">
<h1>Funzionamento di un <em>lexer</em></h1>
</section>
<section id="funzionamento-di-un-lexer-1" class="slide level1">
<h1>Funzionamento di un <em>lexer</em></h1>
<ul>
<li><p>Il <em>lexer</em> legge i caratteri da uno stream, uno alla
volta, e decide quali <em>token</em> creare a seconda dei caratteri in
cui si imbatte.</p></li>
<li><p>Ad esempio, la lettura del carattere <code>"</code> (doppio
apice) in un codice C++ indica che si sta definendo una stringa di
caratteri:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">char</span> <span class="op">*</span> message <span class="op">=</span> <span class="st">&quot;error, you must specify an input file&quot;</span><span class="op">;</span></span></code></pre></div>
<p>Quando i lexer usati nei compilatori C++ trovano un carattere
<code>"</code>, essi continuano a leggere caratteri fino al successivo
<code>"</code>, che segnala la fine della stringa, e restituiscono un
token <em>string literal</em>.</p></li>
</ul>
</section>
<section id="ambiguità-nei-lexer" class="slide level1">
<h1>Ambiguità nei <em>lexer</em></h1>
<ul>
<li><p>Il caso di uno <em>string literal</em> è semplice da affrontare:
tutte le volte che ci si imbatte in un carattere <code>"</code>, si ha a
che fare con questo tipo di <em>token</em>.</p></li>
<li><p>Ma nella maggior parte dei casi un <em>lexer</em> deve affrontare
ambiguità. Ad esempio, un carattere <code>a</code>…<code>z</code> indica
che sta iniziando una <em>keyword</em> come <code>int</code>, oppure un
<em>identifier</em> come <code>iterations_per_minute</code>?</p>
<p>In questo caso si leggono caratteri finché appartengono alla lista
dei caratteri validi in un identificatore (solitamente lettere
maiuscole/minuscole, cifre e il carattere <code>_</code>), poi si
confronta la stringa letta con la lista di possibili <em>keyword</em>
ammesse dal linguaggio.</p></li>
</ul>
</section>
<section id="tornare-indietro" class="slide level1">
<h1>Tornare indietro</h1>
<ul>
<li><p>In un <em>lexer</em> (e vedremo che è così anche nei
<em>parser</em>) è comoda la possibilità di far sì che un carattere
appena letto dal file sia «dis-letto», ossia venga rimesso a posto:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> read_char(<span class="bu">file</span>)   <span class="co"># Suppose that this returns the character &quot;X&quot;</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>unread_char(<span class="bu">file</span>, c)  <span class="co"># Puts the &quot;X&quot; back into the file</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> read_char(<span class="bu">file</span>)   <span class="co"># Read the &quot;X&quot; again</span></span></code></pre></div>
<p>Questo equivale a leggere un carattere in anticipo (operazione di
<em>look ahead</em>), e permette di scrivere il <em>lexer</em> in
maniera più elegante.</p></li>
<li><p>L’operazione <code>unread_char</code> non altera il file:
memorizza soltanto il carattere <code>X</code> in una variabile, e la
restituisce alla successiva chiamata a <code>read_char</code>.</p></li>
</ul>
</section>
<section id="uso-di-unread_char" class="slide level1">
<h1>Uso di <code>unread_char</code></h1>
<ul>
<li><p>Perché <code>unread_char</code> è utile in un <em>lexer</em>?
Vediamo per esempio questa espressione Python:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="dv">15</span><span class="op">+</span><span class="dv">4</span></span></code></pre></div>
<p>che è composta dei <em>token</em> <code>15</code> (<em>numeric
literal</em>), <code>+</code> (<em>symbol</em>), <code>4</code>
(<em>numeric literal</em>).</p></li>
<li><p>Quando il <em>lexer</em> inizia il suo lavoro individua il
carattere <code>1</code>, e capisce che deve creare un token <em>numeric
literal</em>. A questo punto deve leggere i caratteri finché trova la
prima non-cifra, che è <code>+</code>. La lettura di <code>+</code>
segnala che l’intero è finito e va emesso un <em>literal number
token</em>; ma <code>+</code> va rimesso a posto, perché farà parte del
token successivo.</p></li>
</ul>
</section>
<section id="lettura-di-un-numeric-literal" class="slide level1">
<h1>Lettura di un <em>numeric literal</em></h1>
<div class="sourceCode" id="cb33"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>ch <span class="op">=</span> read_char()</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Very basic and ugly code! It does not interpret negative numbers!</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> ch.isdigit():</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We have a numeric literal here!</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    literal <span class="op">=</span> ch</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>        ch <span class="op">=</span> read_char()  <span class="co"># Read the next character</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> ch.isdigit():</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>            <span class="co"># We have got the next digit for the current numeric literal</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>            literal <span class="op">+=</span> ch</span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>            <span class="co"># The number has ended, so put the last character back in place</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.unread_char(ch)</span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>        value <span class="op">=</span> <span class="bu">int</span>(literal)</span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">ValueError</span>:</span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;invalid numeric literal </span><span class="sc">{</span>literal<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
</section>
    </div>
  </div>

  <script src="https://unpkg.com/reveal.js@^4//dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="https://unpkg.com/reveal.js@^4//plugin/notes/notes.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/search/search.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/zoom/zoom.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: true,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'bottom-right',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'default',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'slide',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'fade',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

       // Parallax background image
       parallaxBackgroundImage: './media/background.png', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1440,

        height: 810,

        // reveal.js plugins
        plugins: [
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script src="js/asciinema-player.js"></script>
    <script src="https://cdn.plot.ly/plotly-1.58.4.min.js"></script>
    <script type="text/javascript" src="./js/quantization.js"></script>
    </body>
</html>
