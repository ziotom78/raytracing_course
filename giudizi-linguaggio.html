<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Maurizio Tomasi &lt;maurizio.tomasi@unimi.it&gt;" />
  <title>Valutazioni degli studenti sui linguaggi usati</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="./css/github-pandoc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Valutazioni degli studenti sui linguaggi usati</h1>
<p class="author">Maurizio Tomasi &lt;<a
href="mailto:maurizio.tomasi@unimi.it">maurizio.tomasi@unimi.it</a>&gt;</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#a.a.-20222023" id="toc-a.a.-20222023">A.A. 2022–2023</a>
<ul>
<li><a href="#matteo-picciolini-java-2023-08-04"
id="toc-matteo-picciolini-java-2023-08-04">Matteo Picciolini (Java
2023-08-04)</a></li>
</ul></li>
<li><a href="#a.a.-20212022" id="toc-a.a.-20212022">A.A. 2021–2022</a>
<ul>
<li><a href="#eleonora-gatti-nim-2022-09-07"
id="toc-eleonora-gatti-nim-2022-09-07">Eleonora Gatti (Nim
2022-09-07)</a></li>
<li><a href="#anna-spanò-jacopo-fera-nim-2022-09-05"
id="toc-anna-spanò-jacopo-fera-nim-2022-09-05">Anna Spanò, Jacopo Fera
(Nim, 2022-09-05)</a></li>
<li><a href="#simone-boscolo-c-2022-08-16"
id="toc-simone-boscolo-c-2022-08-16">Simone Boscolo (C#,
2022-08-16)</a></li>
<li><a href="#francesco-andreetto-d-2022-08-13"
id="toc-francesco-andreetto-d-2022-08-13">Francesco Andreetto (D,
2022-08-13)</a></li>
<li><a href="#diana-barindelli-nim-2022-08-06"
id="toc-diana-barindelli-nim-2022-08-06">Diana Barindelli (Nim,
2022-08-06)</a></li>
<li><a href="#francesca-ferrero-matteo-di-mario-c-2022-08-04"
id="toc-francesca-ferrero-matteo-di-mario-c-2022-08-04">Francesca
Ferrero, Matteo Di Mario (C#, 2022-08-04)</a></li>
<li><a href="#matteo-baratto-nim-2022-08-03"
id="toc-matteo-baratto-nim-2022-08-03">Matteo Baratto (Nim,
2022-08-03)</a></li>
<li><a href="#andrea-rossoni-rust-2022-07-25"
id="toc-andrea-rossoni-rust-2022-07-25">Andrea Rossoni (Rust,
2022-07-25)</a></li>
</ul></li>
<li><a href="#a.a.-20202021" id="toc-a.a.-20202021">A.A. 2020–2021</a>
<ul>
<li><a href="#paolo-galli-julia-2022-02-05"
id="toc-paolo-galli-julia-2022-02-05">Paolo Galli (Julia,
2022-02-05)</a></li>
<li><a href="#elisa-legnani-c-2022-01-04"
id="toc-elisa-legnani-c-2022-01-04">Elisa Legnani (C++,
2022-01-04)</a></li>
<li><a href="#tommaso-armadillo-c-2021-06-23"
id="toc-tommaso-armadillo-c-2021-06-23">Tommaso Armadillo (C#,
2021-06-23)</a></li>
<li><a href="#matteo-foglieni-julia-2021-06-30"
id="toc-matteo-foglieni-julia-2021-06-30">Matteo Foglieni (Julia,
2021-06-30)</a></li>
<li><a href="#simone-pirota-c-2021-07-01"
id="toc-simone-pirota-c-2021-07-01">Simone Pirota (C++,
2021-07-01)</a></li>
<li><a href="#giacomo-rivolta-julia-2021-07-01"
id="toc-giacomo-rivolta-julia-2021-07-01">Giacomo Rivolta (Julia,
2021-07-01)</a></li>
<li><a href="#federico-pellegatta-c-2021-07-05"
id="toc-federico-pellegatta-c-2021-07-05">Federico Pellegatta (C++,
2021-07-05)</a>
<ul>
<li><a href="#scelta-del-linguaggio"
id="toc-scelta-del-linguaggio">Scelta del linguaggio</a></li>
<li><a href="#pareri-generali-sul-corso"
id="toc-pareri-generali-sul-corso">Pareri generali sul corso</a></li>
</ul></li>
<li><a href="#daniele-zambetti-julia-2021-07-07"
id="toc-daniele-zambetti-julia-2021-07-07">Daniele Zambetti (Julia,
2021-07-07)</a></li>
<li><a href="#matteo-zeccoli-marazzini-c-2021-07-09"
id="toc-matteo-zeccoli-marazzini-c-2021-07-09">Matteo Zeccoli Marazzini
(C++, 2021-07-09)</a></li>
<li><a href="#andrea-sala-c-2021-07-14"
id="toc-andrea-sala-c-2021-07-14">Andrea Sala (C#, 2021-07-14)</a></li>
<li><a href="#anna-pivetta-kotlin-2021-07-26"
id="toc-anna-pivetta-kotlin-2021-07-26">Anna Pivetta (Kotlin,
2021-07-26)</a></li>
</ul></li>
</ul>
</nav>
<h1 id="a.a.-20222023">A.A. 2022–2023</h1>
<h2 id="matteo-picciolini-java-2023-08-04">Matteo Picciolini (Java
2023-08-04)</h2>
<p>Per questo progetto ho scelto il linguaggio <em>Java</em>,
considerando diversi fattori che lo rendono una scelta vantaggiosa.
Innanzitutto, la vasta adozione e il supporto della comunità di
sviluppatori hanno reso <em>Java</em> una scelta ideale, poiché ho avuto
accesso a numerose risorse, librerie e strumenti che hanno semplificato
notevolmente il processo di sviluppo. Un altro elemento cruciale nella
mia scelta è stata la maturità e la stabilità di <em>Java</em>. Il
linguaggio ha una lunga storia nel mondo dello sviluppo software ed è
ampiamente utilizzato in ambiente lavorativo, il che significa che ha
subito molte ottimizzazioni nel corso degli anni. Questa scelta mi ha
permesso di acquisire competenze e conoscenze utili anche per il futuro,
poiché <em>Java</em> è uno dei linguaggi più richiesti nel settore
informatico.</p>
<p>All’inizio del corso sono stato indeciso tra scegliere <em>Java</em>
o <em>Kotlin</em>, poiché quest’ultimo ha una sintassi più moderna e
implementa alcune funzionalità avanzate che <em>Java</em> non possiede.
Ho comunque optato per <em>Java</em> per le motivazioni che ho
esplicitato sopra. Inoltre, visto che <em>Kotlin</em> si basa
sull’esperienza di <em>Java</em>, ho voluto imparare prima quest’ultimo
per capirne a pieno anche le criticità. Segnalo, in questo senso, due
gravi mancanze di <em>Java</em> che ho subito in particolar modo durante
il corso e che <em>Kotlin</em>, invece, risolve:</p>
<ol type="1">
<li><p><em>Nullable Type</em>: durante il corso viene spiegato come
utilizzare questi oggetti presenti ormai in tutti i moderni linguaggi di
programmazione, che però <em>Java</em> non implementa in modo nativo
(per esempio, i tipi di dato primitivi int, double, boolean, … non
possono essere nulli). Si tratta di un concetto che viene continuamente
utilizzato all’interno di un ray-tracer per descrivere, per esempio, la
mancata intersezione tra un raggio e una <code>Shape</code>. Trattare
alcune classi del progetto (come la classe <code>HitRecord</code>) con
un utilizzo limitato dei <em>Nullable Type</em>, o comunque prestando
molta attenzione ai valori nulli per evitare errori a runtime
(tipicamente <code>NullPointerExceptions</code>) ha richiesto uno sforzo
non indifferente. <em>Kotlin</em>, al contrario, permette l’utilizzo di
<em>Nullable Type</em>.</p></li>
<li><p>Overloading degli operatori: per un algoritmo di ray-tracing è
necessario far eseguire al compilatore una grandissima quantità di
operazioni, che diventano difficili da gestire se non è possibile fare
l’overloading di operatori (come +, <em>, o -). </em>Kotlin<em>, al
contrario di </em>Java*, implementa questa funzionalità.</p></li>
</ol>
<p>Inoltre, in generale, <em>Kotlin</em> offre una scrittura decisamente
più concisa e leggibile rispetto a <em>Java</em>, il che rende il codice
più facile da scrivere e mantenere. D’altro canto, <em>Java</em> è un
linguaggio più maturo rispetto a <em>Kotlin</em> e per questo gode di
una grande community di sviluppatori.</p>
<p>Qualora la scelta di qualcuno ricadesse sul linguaggio <em>Java</em>,
segnalo alcuni accorgimenti fondamentali:</p>
<ol type="1">
<li><p>L’utilizzo di una IDE appropriata semplifica tantissimo il lavoro
di scrittura del codice. Sotto consiglio del professore noi abbiamo
utilizzato il software IntelliJ IDEA di JetBrains (gratuita per gli
studenti UNIMI) che garantisce un ambiente di sviluppo costruito su
misura per <em>Java</em>. Può essere utilizzato anche per
<em>Kotlin</em>.</p></li>
<li><p>L’utilizzo di Gradle o di Maven per la compilazione già dalla
prima lezione. Altri strumenti di build e gestione di dipendenze per
progetti <em>Java</em> (anche molto comodi, come il compilatore interno
di IntelliJ) non sono supportati da GitHub per l’esecuzione di CI
Builds, necessari per andare avanti nel corso. Se iniziate con il
compilatore di IntelliJ, per utilizzare i CI Builds di GitHub sarete
costretti a convertire il codice in modo che Gradle o Maven possano
eseguire il build, e assicuriamo che non è un’esperienza
piacevole.</p></li>
</ol>
<p>Personalmente, durante il corso la verbosità di <em>Java</em> non mi
è dispiaciuta, anche se, con il senno di poi, la compattezza di
<em>Kotlin</em> in qualche modo incuriosisce… In ogni caso ritengo che
la scelta di <em>Java</em> sia stata ottima, anche perché, una volta
costruite le librerie in <em>Java</em>, queste possono essere utilizzate
anche da codice <em>Kotlin</em>, e questo mi permetterebbe di sfruttare
questo lavoro se mai in futuro vorrò imparare ad utilizzare
<em>Kotlin</em>. Al contrario, se le librerie fossero state scritte in
<em>Kotlin</em>, non avrei potuto utilizzarle in un codice
<em>Java</em>.</p>
<p>Per questo, e per come mi sono divertito ad utilizzare ed imparare
<em>Java</em>, mi sento di consigliarlo per questo corso a chi è
interessato ad imparare a gestire un progetto <em>Java</em>. In
generale, però, è da tener presente che, per le ragioni sopra esposte
(<em>Nullable Type</em> e Overloading degli operatori), <em>Java</em>
non è certamente il linguaggio migliore per questo tipo di progetto
(forse <em>Kotlin</em> lo è già di più, ma non saprei fino in
fondo…).</p>
<h1 id="a.a.-20212022">A.A. 2021–2022</h1>
<h2 id="eleonora-gatti-nim-2022-09-07">Eleonora Gatti (Nim
2022-09-07)</h2>
<p>Il linguaggio che ho scelto per il corso è NIM.</p>
<p>La mia idea era quella di scegliere un linguaggio che non fosse stato
scelto l’anno precedente e preferibilmente che non conoscevo. NIM è
stato il primo candidato poiché a prima vista mi è sembrato intuitivo e
dalla “guida” ai diversi linguaggi offerta dal prof. Tomasi mi è parso
avere un grande potenziale.</p>
<p>Io e il mio compagno di gruppo abbiamo iniziato ad avvicinarci a NIM
un paio di settimane prima dell’inizio del corso e ci siamo convinti
della nostra scelta: un linguaggio relativamente semplice da imparare,
con una sintassi simile al Python e soprattutto senza le grame dei
“;”.</p>
<p>Penso che la scelta di NIM ci sia stata utile per il corso.
Nonostante la complessità del codice che abbiamo dovuto scrivere, non
abbiamo quasi mai avuto grossi problemi a livello di linguaggio.</p>
<p>L’unica controindicazione che si può fare riguardo a NIM sono le
scarse risorse disponibili online. Essendo un linguaggio poco diffuso è
raro trovare qualcuno che abbia condiviso online problemi in cui ci si
può imbattere. Tuttavia, esiste una piccola community italiana piuttosto
attiva a cui abbiamo preso parte attraverso un canale Telegram e che ci
è stata di molto aiuto in un paio di occasioni.</p>
<p>Mi sento dunque di consigliare caldamente NIM come linguaggio per
questo corso. Inoltre imparare un nuovo linguaggio di programmazione è
divertente e stimolante e personalmente trovo soddisfacente conoscere un
linguaggio sconosciuto ai più.</p>
<h2 id="anna-spanò-jacopo-fera-nim-2022-09-05">Anna Spanò, Jacopo Fera
(Nim, 2022-09-05)</h2>
<p>Dopo aver seguito la presentazione del corso abbiamo deciso di
imparare un nuovo linguaggio. Alla fine la scelta è ricaduta su Nim a
causa della curiosità verso la sintassi che ricorda molto quella di
Python e poiché era stato presentato come uno dei linguaggi che riusciva
a raggiungere la velocità del C++.</p>
<p>Se dovessimo presentare i vantaggi che più ci hanno convinto di Nim:
sintassi, velocità e potenzialità del linguaggio. Infatti se si conosce
Python è facilissimo imparare Nim e se si vede codice Python è
facilissimo “tradurlo” in Nim, con il vantaggio che i programmi hanno
tempi di esecuzione bassissimi. Inoltre Nim presenta numerose
funzionalità che vi faranno risparmiare un sacco di tempo nella
scrittura di nuovo codice.</p>
<p>Qual è allora il più grande svantaggio di Nim? La documentazione e in
generale gli esempi che si possono trovare su Internet. Alcuni moduli
che userete hanno pagine descrittive ridotte all’osso, con esempi poco
chiarificatori e che vi potrebbero costringere a leggere direttamente il
codice sorgente. Inoltre alcuni warning del compilatore potrebbero
essere difficili da comprendere e le risposte nel forum di Nim
(scordatevi Stack overflow) potrebbero non aiutare troppo. Per fortuna
alla fine si riesce sempre a risolvere tutto e l’aiuto del prof dovrebbe
essere sufficiente.</p>
<p>Con il senno di poi sceglieremmo ancora e consiglieremmo vivamente
Nim perché si impara facilmente, regala grandi soddisfazioni e la
velocità e traducibilità dal Python lo rendono utile anche per il
futuro.</p>
<h2 id="simone-boscolo-c-2022-08-16">Simone Boscolo (C#,
2022-08-16)</h2>
<p>Ho seguito il corso di Immagini Fotorealistiche nell’anno accademico
2021-2022 e ho scelto di utilizzare il linguaggio C#. Le motivazioni
della scelta iniziale sono semplici: C++ è un linguaggio che tutti del
gruppo sapevamo usare e volevamo imparare ad usare un linguaggio che
migliorasse alcune criticità del C++. Inoltre ci sembrava potesse essere
utile lavorativamente parlando il linguaggio C#. Un’altra motivazione
che ci ha spinto a scegliere C# è stato il consiglio di un nostro amico
che aveva già seguito il corso l’anno precedente e ci aveva consigliato
C#. Ci siamo trovati molto bene ad utilizzare il linguaggio C# e rifarei
la scelta fatta. E’ un linguaggio totalmente object-oriented ed è molto
comodo perché ad esempio non ha bisogno di un Makefile. Consiglio
vivamente di utilizzare come IDE Jetbrains Rider, che è implementato
appositamente per C#. E’ un IDE con potenzialità grandissime, che guida
il programmatore nelle varie scelte e che aiuta a imparare il linguaggio
e a gestire il codice.</p>
<p>Inoltre, il nostro gruppo era composto da 3 persone. Consiglio di
formare gruppi di tre persone, in quanto si riesce a dividere meglio il
lavoro e la questione relativa ai conflitti è più interessante.</p>
<h2 id="francesco-andreetto-d-2022-08-13">Francesco Andreetto (D,
2022-08-13)</h2>
<p>Nella scelta iniziale del linguaggio io e il mio compagno abbiamo
adottato due criteri:</p>
<ol type="1">
<li><p>Affrontare un linguaggio nuovo per entrambi (escludendo dunque
<strong><em>C++</em></strong> e
<strong><em>Python</em></strong>);</p></li>
<li><p>Cimentarsi in qualcosa di stimolante, la cui complessità (possiby
not cumbersome) potesse risultare utile a comprendere e risolvere al
meglio i problemi che si possono riscontare scrivendo un codice vasto
come quello sviluppato in questo corso.</p></li>
</ol>
<p>Siamo rimasti molto colpiti dai linguaggi
<strong><em>Rust</em></strong> e <strong><em>D</em></strong> e, dopo
aver consultato la pagina di confronto tra linguaggi messa a
disposizione dal Prof. Tomasi, abbiamo deciso di escludere
<strong><em>Rust</em></strong> visto il livello di difficoltà del
linguaggio, forse eccessivo per il nostro obiettivo didattico.</p>
<p>Il <strong><em>D</em></strong> si è dimostrato un linguaggio
abbastanza comodo da imparare per via di molti elementi di sintassi
comuni al <strong><em>C++</em></strong> (punti e virgole, funzioni,
strutture, classi) con qualche eccezione ricorrente che si impara
facilmente. Sotto alcuni aspetti richiama anche la libertà di scrittura
intuitiva che si riscontra in <strong><em>Python</em></strong>, che può
risultare divertente.</p>
<p>Assolutamente nuovi per me i template e davvero interessante l’uso
dei <em>mixins</em> utilizzati nella definizione di operatori
<code>opBinary</code> (<code>+</code>, <code>-</code> , <code>*</code>,
<code>^</code>): l’eleganza del codice ne ha davvero giovato!</p>
<p>Sono da segnalare però un paio di aspetti, non necessariamente
negativi, ma di rilievo per chi volesse scegliere questo linguaggio per
il corso:</p>
<ul>
<li><p>La <strong>documentazione</strong>, nonostante il linguaggio sia
ben costruito e performante, non è vastissima: a parte la pagina di
<em>Dlang</em> comprensiva di forum piuttosto attivo (<a
href="https://dlang.org/">https://dlang.org/</a>) non sono presenti
molti esempi in rete: bisogna proprio un po’ attivarsi ;)</p></li>
<li><p>La gestione di <strong>file di testo</strong> all’interno del
codice non è intuitiva come per altri linguaggi proposti: soprattutto
all’inizio può causare non pochi dubbi e rallentare il lavoro. Nel
nostro caso, per questo motivo siamo rimasti indietro di una lezione che
abbiamo poi recuperato nelle successive settimane.</p></li>
</ul>
<p>Imparare ad utilizzare questo linguaggio è stato a posteriori utile,
interessante e divertente <del><em>a tratti</em></del> ma non so se lo
risceglierei: gli aspetti evidenziati sopra non mi hanno consentito di
godere sempre dell’esperienza del corso in serenità.</p>
<h2 id="diana-barindelli-nim-2022-08-06">Diana Barindelli (Nim,
2022-08-06)</h2>
<ol type="1">
<li><p><em>Perché avete scelto questo linguaggio? Quali altre
alternative avevate valutato, e perché le avete scartate?</em></p>
<p>Ho scelto Nim, in prima istanza perché volevo imparare un linguaggio
nuovo, escludendo quindi C++. Inoltre, il prof. Tomasi lo aveva
designato come linguaggio adatto per il corso e personalmente mi
incuriosiva la sua applicabilità per creare pagine HTML. Avevo preso in
considerazione anche Julia ma, valutando i pareri degli studenti
dell’anno scorso, non mi ero convinta del tutto e quindi ho optato per
seguire i consigli del professore.</p></li>
<li><p><em>Indipendentemente dal linguaggio scelto, quali sono stati i
criteri che vi hanno aiutato a decidere? Come li giudicate col senno di
poi?</em></p>
<p>Il principale criterio per la mia scelta è stato quello di voler
imparare un linguaggio nuovo. Per la scelta mi sono basata sulle
valutazioni degli altri studenti e sulla descrizione dei vari linguaggi
fornita dal prof. Tomasi. Entrambi mi sono stati di grande aiuto per la
scelta, anche se, nel mio caso, non c’era nessuno dell’anno precedente
che avesse usato Nim e, quindi, nessun giudizio a riguardo.</p></li>
<li><p><em>Alla luce del lavoro di questo semestre, pensate sia stata
una buona scelta?</em></p>
<p>Penso sia stata una buona scelta, in quanto non ho mai riscontrato
grossi problemi per quanto riguarda l’implementazione del codice. Un
grande svantaggio è la scarsissima documentazione disponibile, che,
soprattutto all’inizio, potrebbe creare qualche difficoltà. Detto ciò,
però, Nim è un linguaggio semplice da imparare (non ha una sintassi
pesante), versatile e veloce, adatto a questo corso.</p></li>
<li><p><em>Se tornaste indietro, rifareste questa scelta?
Perché?</em></p>
<p>Sì, o forse proverei con Julia… anche se gli svantaggi di un
linguaggio moderno si ripresenterebbero. In ogni caso, posso dire che
Nim “abbia fatto il suo dovere”, nel senso che ha permesso
un’implementazione lineare, senza grossi stravolgimenti, delle
funzionalità/classi ecc richieste a lezione.</p></li>
</ol>
<h2 id="francesca-ferrero-matteo-di-mario-c-2022-08-04">Francesca
Ferrero, Matteo Di Mario (C#, 2022-08-04)</h2>
<p>Nel momento in cui ci siamo ritrovati a dover scegliere un linguaggio
di programmazione per questo corso, abbiamo dovuto decidere se
sperimentarne uno nuovo o utilizzare il C++ già conosciuto.</p>
<p>Leggendo la presentazione dei linguaggi fatta dal professor Tomasi e
i commenti degli studenti dell’anno precedente, abbiamo notato come il
C# fosse una buona via di mezzo: molto simile al C++ nella sintassi ma
con complicazioni in meno e novità da esplorare. Il C# inoltre:</p>
<ul>
<li><p>È accompagnato da una documentazione molto bene fatta (fornita da
Microsoft), che unita ai tutorial e agli esempi di cui spesso è fornita
rende facile e immediata la consultazione, soprattutto quando (come è
capitato nelle esercitazioni) c’è stato bisogno di usare “sul campo”
strumenti e caratteristiche del linguaggio che ancora non
conoscevamo;</p></li>
<li><p>È molto ben integrato con l’IDE Rider: un ambiente di
programmazione (disponibile con licenza gratuita per gli studenti) che
oltre ad avere il supporto classico di altri IDE (per es. Git e GitHub),
è progettato e ottimizzato apposta per la programmazione in C#. Questo
ha facilitato molto la parte di programmazione e gestione del codice
durante il corso. Tra la varie funzionalità presenti, quella che più ci
ha aiutato è stata il debugger, che ci ha permesso di imparare
l’operazione di debugging (utilissima!!);</p></li>
<li><p>Non necessita di creare makefile e header file. Tutte le
operazioni di compilazione ed esecuzione del programma, dalla creazione
del progetto no alla produzione dell’applicazione eseguibile da linea di
comando, sono gestite dalla piattaforma .NET, distribuita da Microsoft e
scaricabile su tutti i sistemi operativi;</p></li>
<li><p>È un linguaggio molto diffuso, cercando su internet si trovano
praticamente sempre informazioni e soluzioni date da altri
utenti;</p></li>
<li><p>È spesso usato nella programmazione di videogiochi e entrambi
eravamo interessati a conoscerlo per magari poter in seguito esplorare
quell’ambito.</p></li>
</ul>
<p>Siamo totalmente soddisfatti della scelta che abbiamo fatto, imparare
questo nuovo linguaggio è stato intuitivo e stimolante, rifaremmo
sicuramente questa scelta.</p>
<p>Una nota riguardo al corso: eravamo un po’ spaventati prima di
iniziare, pensando avremmo fatto fatica a stare al passo di settimana in
settimana. In realtà il corso è organizzato molto bene e la mole di
lavoro è ben distribuita. Si imparano moltissime cose che non vengono
toccate da nessun altro corso, anche che riguardano ciò che sta intorno
ala creazione di un programma e lo sviluppo di un codice complesso (es.
utilizzo di Git e GitHub).</p>
<h2 id="matteo-baratto-nim-2022-08-03">Matteo Baratto (Nim,
2022-08-03)</h2>
<p>Ho scelto come linguaggio di programmazione Nim. L’idea era quella di
imparare un nuovo linguaggio ed inizialmente eravamo indecisi tra varie
opzioni tra le quali Nim, Julia e C#. Leggendo il pdf fornitoci dal
professor Tomasi, io e la mia compagna di gruppo ci siamo conviti ad
utilizzare Nim.</p>
<p>Nim è un linguaggio relativamente giovane ma non per questo meno
“potente”. Ciò che più mi ha incuriosito è stata la sintassi semplice,
intuitiva ma allo stesso tempo rigorosa, unita al fatto che Nim utilizza
i compilatori di C e C++ per andare a creare l’eseguibile finale: in
sintesi racchiude la facilità di scrittura di python insieme
all’efficienza e potenza di C++. In generale se si ha già avuto a che
fare con Python imparare Nim sarà un gioco da ragazzi!</p>
<p>Va tenuto in conto che Nim utilizza un approccio più procedurale
rispetto ad altri linguaggi Object Oriented (ad esempio metodi e
costruttori di una classe non sono interni ad essa ma funzioni
separate). Personalmente non mi sono trovato male e mi sono da subito
abituato, va chiaramente detto che comunque Nim supporta una
programmazione più OOP attraverso varie features come ad esempio il
<em>dynamic dispatch</em> oppure le <em>objects variants</em> (emtrambi
utili al fine del corso e facili da capire).</p>
<p>L’aspetto che più mi preoccupava era senz’ombra di dubbio la
giovinezza di Nim e di conseguenza l’eventuale mancanza di una community
ampia e di una documentazione esaustiva. In realtà il materiale che si
trova online sul sito ufficile integrato con i libri consigliati dal
professor Tomasi sono più che sufficienti per iniziare e nel caso si
riscontrassero problemi la community è attiva sia sul forum ufficiale
che su vari gruppi telegram.</p>
<p>In conclusione, penso che sia un ottimo linguaggio per svolgere il
corso: moderno, elegante e facile da imparare. Dovessi tornare indietro
sceglierei ancora Nim in quanto mi ha colpito positivamente e mi sono
divertito molto nell’impararlo.</p>
<h2 id="andrea-rossoni-rust-2022-07-25">Andrea Rossoni (Rust,
2022-07-25)</h2>
<p>Premesso che, opinione personale, lo spirito del corso è trasmettere
tutte quelle metodologie per costruire, collaborare, mantenere codice
sicuro e condiviso aka insegnare al fisico medio un po’ di
<strong>devops</strong> skills. E <strong>non</strong> risolvere un
problema complesso numericamente o imparare un nuovo linguaggio di
programmazione, che saranno comunque sia due piacevolissime
conseguenze.</p>
<p><strong><code>rust</code> è la scelta per ascendere a tale spirito
(ed oltre)!</strong></p>
<p>Potrei avvalorare la mia tesi pedantemente, elencando tutti i pregi
del linguaggio, toolchain e progetti/servizi associati. Ma così facendo,
potrei barare scrivendo solamente ciò che mi conviene. Un programmatore
di un qualunque altro linguaggio potrebbe fare lo stesso. Però
sicuramente non potrebbe dire che:</p>
<ul>
<li><p>è il linguaggio più amato dalla community di stack-overflow dal
<a
href="https://insights.stackoverflow.com/survey/2016#technology-most-loved-dreaded-and-wanted">2016</a>
ad <a
href="https://insights.stackoverflow.com/survey/2021#section-most-loved-dreaded-and-wanted-programming-scripting-and-markup-languages">oggi</a>
(chiamalo poco)</p></li>
<li><p>è il linguaggio candidato a diventare secondo per numero di righe
all’interno del <a
href="https://www.memorysafety.org/initiative/linux-kernel/">kernel
linux</a> dopo <code>C</code>¹</p></li>
</ul>
<p>Che sarà mai il kernel linux direte voi, bha non so diciamo che gira
su almeno ~1G di dispositivi!²</p>
<p>È quindi un linguaggio maturo a 360° per essere scelto in
applicazioni critiche che spaziano da browsers (mozilla sta riscrivendo
interi pezzi di firefox in <code>rust</code>, <a
href="https://servo.org/">servo</a> è un web-engine sperimentale) a
crypto libs (<code>openssl</code>-&gt;<a
href="https://github.com/rustls/rustls"><code>rustls</code></a>) fino al
kernel linux. Non potreste fare scelta migliore per capire come eccelle
nello sviluppo di software sicuro e condiviso.</p>
<p>Se invece il vostro obiettivo è capire qual è il miglior linguaggio
di programmazione per risolvere il problema numerico trattato durante il
corso. In tal caso <code>rust</code> non eccelle, non eccelle in
generale (al momento) per applicazioni numeriche, lo denota anche la
scarsa presenza di librerie di algebra lineare. L’ overhead richiesto a
volte per sopperire a certe limitazioni native del linguaggio
(assolutamente volute, fondative, rivendicate tra le sue feats, cit.
“son gli altri linguaggi che vi hanno abituato male!”) è notevole. Ad
esempio, spesso nel codice da sviluppare saranno necessari <em>abstract
methods</em> e <em>classes inheritance</em>, <code>rust</code> non ha
niente di tutto ciò. Ci sono due modi tuttavia, a mio parere un po’
troppo noiosi, per aggirare il problema:</p>
<ul>
<li><p>in <strong>heap</strong> usando <a
href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html"><code>Box&lt;dyn     _&gt;</code></a>
ed a cascata <a
href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html">lifetime
parameters</a></p></li>
<li><p>in <strong>stack</strong> usando <code>enum</code>, anche se un
po’ “abusati” in questa circostanza, si sono rivelati dei buoni
alleati</p></li>
</ul>
<blockquote>
<p>La gestione degli errori³ o dei null values attraverso l’utilizzo
degli <code>enum</code> è spettacolare! Ne sentirò sicuramente la
mancanza</p>
</blockquote>
<p>Ah, la distinzione netta tra <strong>heap</strong> e
<strong>stack</strong> non è casuale, è fondamentale in
<code>rust</code>. Un buon sviluppatore dovrebbe sempre tenerne conto,
quindi involontariamente<code>rust</code> fa di voi dei buoni
sviluppatori.</p>
<p>Cheers and may the 🦀 be with you!</p>
<p>¹ <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=8aebac82933ff1a7c8eede18cab11e1115e2062b">first
merge inside linux kernel</a>, where all began …</p>
<p>² senza troppo contare i dispositivi <strong>android</strong></p>
<p>³ <a href="https://github.com/dtolnay/thiserror">thiserror</a>
consigliatissima</p>
<h1 id="a.a.-20202021">A.A. 2020–2021</h1>
<h2 id="paolo-galli-julia-2022-02-05">Paolo Galli (Julia,
2022-02-05)</h2>
<p>Ho scelto Julia perché ne avevo sentito parlare da un po’ di persone
tra professori e studenti e la cosa mi aveva incuriosito. Le cose che ho
trovato maggiormente interessanti in fase di scelta sono state:</p>
<ul>
<li>il fatto che si ponga come un linguaggio pensato apposta per il
calcolo e l’ambiente scientifico;</li>
<li>il fatto che sia un linguaggio sia compilato che interpretato, cosa
che unisce per esempio la semplicità di uso di Python per dei conti e
analisi veloci da linea di comando interattiva (la REPL di Julia) e la
velocità di esecuzione simile a un codice C++ (proprio perché il codice
viene precompilato);</li>
<li>il fatto che sia un linguaggio nuovo.</li>
</ul>
<p>Avevo valutato anche C++ che già conoscevo in modo da approfondirlo,
ma alla fine ho preferito approfittare dell’occasione per imparare un
nuovo linguaggio in un modo che altrimenti mi sarebbe stato difficile,
ovvero un in progetto complesso ma guidato. Secondo me una cosa da
tenere presente (e che per me è stato uno dei principali impatti) è che
Julia è un linguaggio funzionale, non esiste il concetto di classe, cosa
che almeno nel mio caso mi ha costretto a ripensare a certi approcci al
problema. Inoltre, essendo un linguaggio che sotto certi versi ricorda
Python, se si conosce quest’ultimo viene spontaneo soprattutto
all’inizio approcciarsi in modo “pythonistico”, cosa da evitare poiché i
due linguaggi sono in realtà profondamente differenti. Una delle
difficoltà maggiori di Julia che ho trovato è che ci sono molti modi per
risolvere uno stesso problema (ad esempio usando cicli for,
broadcasting, map, …) e ognuno di questi può portare a performance
estremamente diversificate a causa di come il linguaggio e il suo
compilatore interpretano e ottimizzano ciò che c’è scritto: serve quindi
porre una buona quantità di attenzione e tempo nell’analisi delle
performance dei vari metodi e nell’ottimizzazione del codice. Ho trovato
però molto belli altri aspetti: l’eleganza del codice, il metodo di
typing, la potenzialità del multiple dispatch, il metaprogramming, …
tutte cose che permettono di liberare molto la creatività. Rifarei
questa scelta perché sviluppare con questo linguaggio è stato
divertente; a tratti complesso, ma divertente.</p>
<h2 id="elisa-legnani-c-2022-01-04">Elisa Legnani (C++, 2022-01-04)</h2>
<p>Ho scelto il C++ perché era un linguaggio che conoscevo già e volevo
rispolverare. Non mi sembrava di aver imparato ad usarlo con scioltezza
nei corsi precedenti, tanto che parte della sintassi di esempio mi era
nuova e mi aveva incuriosito. Non l’ho scelto tanto per comodità, quanto
per poterlo approfondire: nella descrizione dei linguaggi fornita dal
professore a inizio corso era chiaramente indicato quanto potesse
risultare complicato usarlo per questo progetto e quanto invece altri
linguaggi più recenti come Julia e Kotlin fossero più maneggevoli. E
questo è stato evidente fin dalle prime lezioni, durante le quali,
mentre altri imparavano un nuovo linguaggio, noi abbiamo faticato a
risolvere vari problemi, molti dei quali aventi a che fare con
l’utilizzo di librerie esterne e sistemi operativi diversi (io ho
lavorato con Linux e la mia compagna con MacOS), oppure ad implementare
test automatici da zero o ad imparare nuovi strumenti per la
compilazione. L’esperienza del professore e la vastità di risorse ed
esempi online ci hanno però aiutato molto in questo senso.</p>
<p>A posteriori posso dire che è grazie a questo corso che ho ottenuto
una buona familiarità con il C++ e con i suoi standard più recenti. Mi
sento solo ora in grado di scrivere autonomamente un programma complesso
usando questo linguaggio, ed è per questo che sono soddisfatta della
scelta che ho fatto. Avevo valutato come alternativa anche Julia, la cui
semplicità e possibile utilizzo nel campo dell’astrofisica (il
professore aveva presentato il linguaggio anche in una lezione di
Astronomia 1) mi avevano interessato. Tornando indietro rifarei la
stessa scelta, sono dell’idea che scontrarsi contro i problemi ed
imparare un metodo per risolverli sia importante nell’apprendimento di
qualsiasi materia.</p>
<p>A prescindere dal linguaggio scelto, il corso in generale è molto
utile:</p>
<ul>
<li>si impara a scrivere del codice per descrivere un fenomeno fisico
non banale in un unico grande progetto;</li>
<li>è fondamentale usare sistemi di controllo delle versioni quando si
scrive codice complesso, e prima di questo corso non avevo avuto modo di
approfondire l’argomento e di apprezzarne l’utilità;</li>
<li>non avevo mai scritto codice collaborando veramente con qualcun
altro;</li>
<li>è importante scrivere codice fruibile da altri - ora che sto
lavorando alla tesi mi accorgo che spesso il codice in ambito di ricerca
è poco documentato e/o testato e per questo difficile da
utilizzare.</li>
</ul>
<p>Esprimo anche un giudizio del tutto personale, ma credo anche
condiviso dagli altri studenti che hanno frequentato il corso. Si tratta
di un corso divertente. Oltre ad essere un utile strumento di debugging,
poter ottenere risultati visivi dopo vari mesi di duro lavoro di
programmazione dà una grande soddisfazione. Tanto che viene voglia di
implementare anche le parti facoltative, con il rischio di non finire
mai di continuare ad aggiustare e migliorare il programma.</p>
<h2 id="tommaso-armadillo-c-2021-06-23">Tommaso Armadillo (C#,
2021-06-23)</h2>
<p>All’inizio del corso mi sono trovato a dover scegliere un linguaggio
di programmazione. Personalmente volevo imparare un nuovo linguaggio,
per questo motivo ho escluso fin da subito il C++. Per prima cosa ho
letto il pdf scritto dal professor Tomasi in cui fa una panoramica su
diversi linguaggi consigliati, tra questi mi hanno colpito il C# e
Julia. Il primo per la sua sintassi molto simile al C++, ma al tempo
stesso molto più leggera e il secondo perchè mi ha dato l’impressione di
essere un linguaggio molto versatile e innovativo. Alla fine ho scelto
il C# sia perchè rispetto a Julia si trova più materiale online, sia
perchè il C# è molto utilizzato nell’industria videoludica (grazie al
motore grafico Unity) che è un qualcosa che mi ha sempre interessato e
che ho sempre voluto approfondire un po’.</p>
<p>Personalmente sono molto contento della scelta che ho fatto. Il C# è
un linguaggio estremamente versatile e facile da imparare se si conosce
già il C++. La sintassi è identica per tutti i costrutti principali,
tuttavia elimina tutte le difficoltà e le complicazioni del C++. Ad
esempio non c’è bisogno né di creare file <code>.h</code> né di dover
scrivere esplicitamente un <code>makefile</code> per compilare il
codice, ma è possibile compilare ed eseguire semplicemente con il
comando <code>dotnet run</code> (dotnet è il compilatore C# fornito
liberamente da Microsoft). C# è supportato egregiamente da Visual Studio
che permette con estrema facilità di avviare il debugger per risolvere
bug all’interno del codice. Il linguaggio inoltre non prevede poi
l’utilizzo di puntatori e reference come il C++, rendendolo molto più
facile e leggibile. Esistono poi molte librerie fornite direttamente da
Microsoft che permettono di ottenere risultati interessanti in
pochissimo tempo. Ad esempio è possibile parallelizzare l’esecuzione di
un ciclo <code>for</code> semplicemente facendo un include di una
libreria di sistema e sostituendo il <code>for</code> con
<code>Parallel.For</code>. Fare un’operazione del genere in C++ richiede
invece l’installazione di librerie esterne, che in generale è
un’operazione più lunga e che può portare a problemi nel caso in cui
altre persone vogliano utilizzare il nostro codice. Infine un’ultima
cosa da non sottovalutare, è il fatto che esiste una documentazione,
molto ben fatta, fornita direttamente da Microsoft ed essendo poi un
linguaggio molto diffuso su StackOverFlow si trovano parecchie risorse
utili.</p>
<h2 id="matteo-foglieni-julia-2021-06-30">Matteo Foglieni (Julia,
2021-06-30)</h2>
<p>Per quanto riguarda il mio messaggio per gli studenti del futuro, è
molto semplice: scegliete Julia; sarà molto faticoso all’inizio, ma ne
varrà la pena.</p>
<p>La scelta di Julia per me si è basata su due soli elementi: il pdf
reso disponibile dal professore su alcuni dei vari linguaggi che
consigliava e una lezione facoltativa di Astronomia 1 nella quale lui
stesso presentava un piccolo lavoretto computazionale fatto proprio con
Julia; un po’ poco forse con il senno di poi, diciamo che avevo posto
molta fiducia sull’opinione che il professore stesso ha su questo
linguaggio.</p>
<p>Le mie alternative erano C++ (per andare sul sicuro, anche se mi
immaginavo avrei dovuto tribolare parecchio, e un mio compagno che lo ha
scelto me lo ha infatti confermato) o C# (per “uscire dal seminato ma
senza esagerare”); ho scelto Julia per un elemento in particolare:
questo corso è una occasione più unica che rara a fisica di imparare un
linguaggio di programmazione nuovo (= diverso da C++ e Python).</p>
<p>A posteriori, risceglierei questo linguaggio con molta più
consapevolezza e sicurezza:</p>
<ol type="1">
<li>La sintassi di Julia è relativamente facile da imparare (soprattutto
se si ha una infarinatura di Python da lab astronomia o dalla tesi
triennale) ed intuitiva una volta che si entra nell’ottica giusta;</li>
<li>Il linguaggio è concepito per il calcolo scientifico, quindi anche
la scrittura “a mano” di una qualsiasi funzione ha una ottima
performance: le ottimizzazioni “serie” ovviamente vi sono da fare se uno
ha tempo ed è interessato, ma anche senza di esse il programma ha tempi
di esecuzione accettabilissimi; inoltre, avendo noi una formazione da
fisici, la mentalità di usare e implementare funzioni penso venga
proprio naturale;</li>
<li>Julia è un linguaggio modernissimo, quindi varie funzionalità che,
soprattutto verso la fine del corso, vanno rese nel programma (come i
<em>sum types</em> per i tokens, o la possibilità di scrivere codice
anche molto complesso per i costruttori) vengono supportate senza
problemi;</li>
<li>Il <em>multiple dispatch</em> è comodissimo, si adatta perfettamente
per le varie shapes da implementare;</li>
</ol>
<p>La scelta di Julia ha due principali problemi, che è bene sempre
tenere a mente:</p>
<ol type="1">
<li>Per quanto simile a Python, resta un linguaggio nuovo da imparare da
zero: soprattutto nelle fasi iniziali, ciò può essere molto frustrante,
dato che ci si imbatte spesso nel voler fare una cosa ma non sapere come
farla; se si vuole vedere il lato positivo, sicuramente si allenano
capacità di improvvisazione e perseveranza;</li>
<li>Come già detto nei pregi, Julia è un linguaggio molto moderno. Di
conseguenza, non di rado si presentano problemi nel codice che non si
riescono a capire e/o risolvere a causa di scarsa documentazione
(soprattutto nella prima parte del corso, vedi problema 1), o a causa di
veri e propri bug (mi sono capitati dei problemi con la funzione
<code>string</code> che ancora non ho capito). Inoltre, essendo ancora
relativamente poco diffuso (proprio perché neo-entrato nel panorama dei
linguaggi), cercare su internet il messaggio di errore ottenuto e/o
parole chiave sul problema riscontrato non assicura affatto che si
ottenga una soluzione (per C++ è invece praticamente impossible che
qualcun altro non abbia fatto la stessa domanda in precedenza)</li>
</ol>
<p>NB: terrei comunque a sottolineare che Julia è sotto pesante sviluppo
e improvements; potrebbe quindi anche essere che tra un anno questi
problemi di documentazione e bugs risultino risolti o comunque molto
mitigati.</p>
<p>In conclusione, se avete voglia di impegnarvi e investirci molto
tempo, Julia non vi deluderà di certo!</p>
<p>Ultimissima cosa: a prescindere dal linguaggio scelto, il corso
richiede notevole impegno: non rinunciate a Julia per vertere su C++
solo per evitare di faticare, potreste avere brutte sorprese.</p>
<h2 id="simone-pirota-c-2021-07-01">Simone Pirota (C++, 2021-07-01)</h2>
<ol type="1">
<li><p>Perché avete scelto questo linguaggio? Quali altre alternative
avevate valutato, e perché le avete scartate?</p>
<p>Io ho scelto il C++, principalmente perchè già lo conoscevo, e un po’
perchè la mia prima scelta (il linguaggio Rust) non era condivisa da
nessun altro studente.</p></li>
<li><p>Indipendentemente dal linguaggio scelto, quali sono stati i
criteri che vi hanno aiutato a decidere? Come li giudicate col senno di
poi?</p>
<p>Principalmente la scelta del linguaggio è stata basata sulla
curiosità e voglia di imparare un nuovo linguaggio di programmazione.
Questo potrebbe risultare un criterio che esclude il C++, in quanto è
già affrontato dai corsi di informatica della triennale, ma la grande
differenza rispetto a quei corsi è che in questo lo si vede non in
maniera didattica, ma dal punto di vista produttivo, come nella vita
vera.</p>
<p>Quindi, se avete voglia di imparare un nuovo linguaggio di
programmazione (magari anche il più esotico tra quelli proposti) e se
c’è un altro collega che vi segue non esitate; se invece come nel mio
caso siete l’unico pazzo del gruppo e siete “obbligati” a “ripiegare”
sul C++, non scoraggiatevi, perchè lo vedrete sotto tutta un’altra
luce.</p>
<p>Riassumendo, secondo me i criteri sono:</p>
<ul>
<li><p>voglia e curiosità di imparare un nuovo linguaggio</p></li>
<li><p>voglia di approfondire un linguaggio che già si conosce</p></li>
</ul></li>
<li><p>Alla luce del lavoro di questo semestre, pensate sia stata una
buona scelta?</p>
<p>È stata una buonissima scelta, perchè come accennato prima, ho
approfondito e imparato cose che in C++ manco sapevo si potessero fare,
e soprattutto sono molto più sicuro quando vado a spulciare la STL in
cerca di risposta, oppure se sto scrivendo una funzione/classe/etc etc o
la sto copiando da una risposta di stackoverflow, ho abbastanza senso
critico da capire se lo sto facendo nel migliore dei modi o
meno.</p></li>
<li><p>Se tornaste indietro, rifareste questa scelta? Perché?</p>
<p>Rifarei la stessa scelta, o meglio, invece di tuffarmi sul Rust,
sceglierei direttamente il C++, perchè credo sia indispensabile
conoscerlo e sbatterci la testa il più possibile finché siamo studenti
(se fosse per me riseguirei questo corso diverse volte, ogni volta con
un linguaggio diverso, sì, se te lo stai chiedendo, questo è davvero un
bel corso).</p></li>
</ol>
<h2 id="giacomo-rivolta-julia-2021-07-01">Giacomo Rivolta (Julia,
2021-07-01)</h2>
<ol type="1">
<li><p>Perché avete scelto questo linguaggio? Quali altre alternative
avevate valutato, e perché le avete scartate?</p>
<p>Noi abbiamo scelto il linguaggio Julia. Le possibilità che avevamo
erano:</p>
<ul>
<li><p>rispolverare il molto impolverato C++;</p></li>
<li><p>riprendere il Python (meno impolverato ma vietato!);</p></li>
<li><p>imparare un nuovo linguaggio, moderno e semplice da
usare.</p></li>
</ul>
<p>Visto che per riprendere in mano il C++ in maniera decente avrebbe
impiegato lo stesso tempo di imparare un nuovo linguaggio, abbiamo
deciso di impararne uno nuovo. Abbiamo scelto proprio Julia (suggeritoci
dal prof. Tomasi) perché ci è sembrato moderno, semplice, versatile e
veloce.</p></li>
<li><p>Indipendentemente dal linguaggio scelto, quali sono stati i
criteri che vi hanno aiutato a decidere? Come li giudicate col senno di
poi?</p>
<p>Come detto sopra, cercavamo un linguaggio moderno (consapevoli dei
rischi che comporta, cioè poca documentazione e molti problemi non
ancora risolti), semplice da imparare (cioè con una sintassi facile da
apprendere e non pesante), versatile e veloce.</p>
<p>Con il senno di poi direi che questi criteri e la scelta conseguente
sono stati azzeccati.</p></li>
<li><p>Alla luce del lavoro di questo semestre, pensate sia stata una
buona scelta?</p>
<p>Sì, penso che scegliere Julia sia stata una buona scelta, al di là di
un po’ di problemi “di gioventù” incontrati. Sicuramente la versatilità
di Julia (cito solo il <em>multiple dispatch</em>), la sua semplice
sintassi, la sua velocità e modernità lo hanno reso un’ottima scelta.
Sicuramente alcuni problemi riguardo a funzionalità non ancora
implementate e mancanza di documentazione (anche banalmente la
risoluzione di qualche problema su StackOverflow) verranno aggiustati
con il tempo.</p></li>
<li><p>Se tornaste indietro, rifareste questa scelta? Perché?</p>
<p>Sì, rifarei sia la scelta di scegliere Julia, sia quella di imparare
un nuovo linguaggio perché è sempre utile e interessante.</p></li>
</ol>
<h2 id="federico-pellegatta-c-2021-07-05">Federico Pellegatta (C++,
2021-07-05)</h2>
<h3 id="scelta-del-linguaggio">Scelta del linguaggio</h3>
<p>All’inizio del corso la mia intenzione era di imparare a programmare
in JavaScript, che già conoscevo in parte. Purtroppo però non ho trovato
un compagno che avesse lo stesso interesse e quindi ho dovuto ripiegare
sul sempiterno C++.</p>
<p>Con il senno di poi, avrei comunque preferito fare un piccolo sforzo
iniziale in più per imparare un linguaggio nuovo. Infatti, la scelta del
C++, se all’inizio mi sembrava la più comoda, in certi casi si è
rivelata piuttosto faticosa rispetto ad altri compagni che hanno deciso
di imparare un nuovo linguaggio. Probabilmente però non mi sarei
comunque buttato completamente in un nuovissimo linguaggio senza aver
dedicato qualche momento a “giocarci” prima di incominciare il
corso.</p>
<p>In ogni caso mi è stato utile la panoramica <em>A comparison between
a few programming languages</em> messa a disposizione dal Prof. Tomasi
sul sito Ariel del corso (nella sezione “Informazioni sul corso”).</p>
<h3 id="pareri-generali-sul-corso">Pareri generali sul corso</h3>
<p>Il corso è molto divertente e stimolante: anche per chi sceglierà il
C++ scoprirà un sacco di cose nuove (che probabilmente ve lo faranno
odiare!). Le lezioni sono interessanti e il materiale didattico
preparato dal Prof è eccellente. È molto soddisfacente avere un
risultato visivo dopo mesi di lavoro: l’appagamento e il risultato sono
direttamente proporzionali all’impegno durante i mesi di corso.</p>
<p>Nonostante nelle presentazioni del corso il Prof. Tomasi abbia
sottolineato che si hanno delle scadenze ogni settimana, il carico di
lavoro mi è sembrato in linea con quello richiesto da altri corsi di
laboratorio. Chiaramente è fondamentale che il lavoro sia finito di
settimana in settimana, ma se anche si arrivi all’esercitazione
successiva con qualche dettaglio non ancora implementato, o qualche cosa
ancora da sistemare, si può velocemente recuperare chiedendo aiuto al
Prof. Inoltre può capitare che alcune settimane ci sia un po’ più di
lavoro rispetto ad altre: l’importante è organizzarsi con il proprio
compagno di laboratorio.</p>
<p>In conclusione, ritengo che frequentare questo corso sia stata
un’ottima scelta che rifarei in futuro. Oltre a imparare ad utilizzare
strumenti come Git e GitHub per la programmazione in team, si implementa
un codice numerico complesso che approssimi un modello di un fenomeno
fisico non banale (cose non mostrate in altri corsi).</p>
<p>Puoi avere una panoramica del lavoro svolto e del risultato che io e
il mio compagno di laboratorio abbiamo ottenuto andando a sbirciare <a
href="https://github.com/federicopellegatta/raytracing">la nostra
repo</a>.</p>
<h2 id="daniele-zambetti-julia-2021-07-07">Daniele Zambetti (Julia,
2021-07-07)</h2>
<p>Ho scelto di utilizzare Julia come linguaggio di programmazione
perché mi era stato presentato velocemente durante una lezione di
Astronomia 1 sempre dal professor Tomasi e fin da subito mi era parso
molto comprensibile da leggere come linguaggio. La chiarezza con cui è
possibile esprimere formule matematiche complesse (praticamente con lo
stesso formalismo con cui si scriverebbero su un foglio di carta) è
sorprendente, inoltre la grande flessibilità con cui vengono gestiti i
tipi delle variabili è comodissima. Leggendo il materiale messo a
disposizione del professore mi ha convinto vedere che nonostante sia un
linguaggio formalmente così alto, abbia tempi di compilazione veramente
rapidi.</p>
<p>Un criterio forse banale con cui ho deciso di imparare da capo un
nuovo linguaggio è anche che l’unico linguaggio che conoscevo utile per
fare questo corso, il C++, non lo usavo da moltissimo tempo quindi la
fatica di riprendere la sintassi (rigidissima del C++) sarebbe stata di
poco inferiore alla fatica di iniziare da capo con un nuovo
linguaggio.</p>
<p>Sono molto soddisfatto della scelta fatta, sia perché Julia si è
rilevato un linguaggio flessibile e davvero innovativo, sia perché ho
imparato ad essere molto autonomo nella ricerca di documentazione e di
esempi (la community di Julia è abbastanza attiva) su come si utilizza
questo linguaggio.</p>
<p>In laboratorio il lavoro non è stato particolarmente rallentato dal
dover imparare qiuesto nuovo linguaggio soprattutto perché, come
suggerito dal professore, per prendere dimestichezza con la sintassi ho
svolto prima dell’inizio del corso una decina di esercizi proposti dal
sito <a href="https://projecteuler.net/">Project Euler</a>.</p>
<h2 id="matteo-zeccoli-marazzini-c-2021-07-09">Matteo Zeccoli Marazzini
(C++, 2021-07-09)</h2>
<p>Ho scelto il linguaggio C++ perché tra quelli suggeriti era l’unico
che avevo già utilizzato, e ne ho approfittato per studiarlo meglio
usandolo in un progetto complesso. Avevo valutato anche il linguaggio C,
che conosco meglio, ma ho dovuto scartarlo perché nessun altro l’aveva
considerato e non avrei potuto lavorare in gruppo.</p>
<p>Il criterio più importante è stata la familiarità con il linguaggio:
per affrontare un lavoro così complicato, ho pensato che fosse troppo
difficile utilizzare uno strumento mai visto in precedenza. Con il senno
di poi, credo che sia stato un criterio utile: utilizzare ad esempio
Julia sarebbe stato sicuramente stimolante, ma non credo che sarei
riuscito a lavorare in modo altrettanto proficuo. Sono soddisfatto della
scelta: l’alternativa che avevo considerato (il C) sarebbe stata
interessante da usare, ma avrebbe reso alcune cose molto più complicate
da gestire. Ad esempio, funzioni che prendono argomenti generici sono
più rigide e difficili da implementare, e nel corso ne abbiamo fatto
largo uso. Inoltre, sono contento perché ho avuto l’opportunità di
imparare ad utilizzare il C++ in un modo diverso rispetto a quello a cui
ero abituato: ho potuto usare strumenti più moderni come gli
<code>shared_ptr</code>, le <em>lambda functions</em>, le
<em>initializer list</em>. Alla luce di queste riflessioni, credo che
sceglierei nuovamente il C++, soprattutto perché ho potuto imparare ad
usarlo molto meglio rispetto a prima del corso.</p>
<h2 id="andrea-sala-c-2021-07-14">Andrea Sala (C#, 2021-07-14)</h2>
<p>Ho seguito il corso <em>Calcolo Numerico per la Generazione di
Immagini Fotorealistiche</em> nell’anno accademico 2020-2021 e ho scelto
di sviluppare il mio progetto in C#.</p>
<p>Quando ho letto la guida ai linguaggi di programmazioni redatta dal
Prof. Tomasi, sono subito rimasto incuriosito dal fatto che esistesse un
linguaggio simile al C++ ma che risolvesse alcune sue criticità. Così e
stato; i vantaggi del C# che ho sperimentato in prima persona sono:</p>
<ul>
<li>Uso più assennato dei punti e virgola</li>
<li>Linguaggio totalmente <em>object-oriented</em>: non c’è più quello
strano mix di funzioni definite al di fuori del main e classi contenenti
i loro methodi (in questo è molto utile la keyword
<code>static</code>)</li>
<li>Molto ben integrato con l’IDE Visual Studio Code</li>
<li>Non c’è bisogno di puntatori</li>
<li>È molto comodo usare alcune classi predefinite del linguaggio
(<code>List</code>, <code>Matrix4x4</code>, <code>Dictionary</code>,
…)</li>
<li>Non c’è bisogno di scrivere il <code>Makefile</code>, ma
compilazione ed esecuzione sono racchiuse nello stesso comando
<code>dotnet run</code></li>
<li>Gli errori sono documentati molto bene (codice <code>CS####</code>)
sul sito di Microsoft</li>
<li>Ereditarietà concepita in modo più lineare rispetto al C++</li>
<li>Parallelizzare il codice è molto molto semplice</li>
</ul>
<p>Ci sono anche (pochi) svantaggi nell’uso del C#. Ecco quelli che ho
riscontrato:</p>
<ul>
<li><p>Command Line Interface non facilissima da implementare; abbiamo
dovuto cercare un po’ di librerie diverse prima di trovarne una
soddisfacente</p></li>
<li><p>Quando si fa il parsing di un oggetto che può essere una delle
tante classi figlie di una certa classe madre, è scomodo chiamare un
datamembro presente in una sola delle classi figlie. Faccio un
esempio:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode csharp"><code class="sourceCode cs"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>Token tok <span class="op">=</span> <span class="fu">readToken</span><span class="op">();</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> <span class="op">(</span>tok <span class="op">==</span> SymbolToken<span class="op">)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">string</span> s <span class="op">=</span> tok<span class="op">.</span><span class="fu">symbol</span><span class="op">;</span> </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Questo codice non è ammesso dal C#! Anche se io sono sicuro che quel
token è un SymbolToken grazie al controllo, non posso accedere
direttamente al data membro <code>symbol</code>, ma devo fare un casting
un po’ scomodo:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode csharp"><code class="sourceCode cs"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>Token tok <span class="op">=</span> <span class="fu">readToken</span><span class="op">();</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> <span class="op">(</span>tok <span class="op">==</span> SymbolToken<span class="op">)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">string</span> s <span class="op">=</span> <span class="op">((</span>SymbolToken<span class="op">)</span>tok<span class="op">).</span><span class="fu">symbol</span><span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p>Leggermente meno performante del C++, ma per quello che ho fatto
durante il corso non ho avuto problemi di lentezza.</p></li>
</ul>
<h2 id="anna-pivetta-kotlin-2021-07-26">Anna Pivetta (Kotlin,
2021-07-26)</h2>
<p>Kotlin. La scelta di questo linguaggio da parte mia sinceramente non
è stata molto ragionata: ero curiosa di imparare un linguaggio nuovo e
ho scelto questo anche insieme al mio compagno di gruppo.</p>
<p>Il primo criterio per me è stato semplicemente che fosse un
linguaggio nuovo, inoltre sapevo che utilizzando Kotlin avrei avuto a
che fare con una bella IDE e mi sembra che anche imparare a
interfacciarsi con uno strumento del genere sia importante per qualcuno
a cui piace programmare.</p>
<p>Kotlin ha alcuni aspetti molto belli: per esempio la possibilità di
usare funzioni implicite rende il codice molto elegante. Inoltre,
esistono molte librerie che rendono alcuni passaggi molto semplici, per
esempio scrivere un’immagine ldr (png, jpeg…) è facilissimo in
Kotlin.</p>
<p>Ovviamente ci sono anche alcuni aspetti negativi, ne segnalo uno in
particolare. Se sceglierete Kotlin userete sicuramente la IDE
IntellijIDEA e il gestore di pacchetti gradle: sono entrambi strumenti
potenti e per certi versi molto comodi ma vanno usati con cautela e più
coscienza di quanto abbiamo fatto noi. IntellijIDEA vi offre
un’interfaccia grafica attraverso la quale potete dialogare con github
senza passare dalla linea di comando: questo è comodo ma bisogna fare
attenzione a cosa committate su github e cosa no. Ci sono alcuni file
che descrivono come è fatto il workspace o come sono le impostazioni di
gradle che se modificati possono crearvi alcuni impicci. Noi abbiamo
usato questi strumenti in modo un po’ sportivo, senza grande
consapevolezza di cosa stavamo facendo; sicuramente se farete qualche
ricerca iniziale su come funzionano gradle e intellijIDEA (non è
necessario un approfondimento esagerato, ma solo avere un minimo di
coscienza su questi strumenti) vi potrete risparmiare qualche
problema.</p>
<p>Complessivamente io sono contenta di aver scelto kotlin e rifarei
questa scelta: è un linguaggio molto elegante e gli strumenti che mette
a disposizione sono veramente tanti. Inoltre, la IDE intellijIDEA aiuta
veramente molto nella scrittura del codice.</p>
<p>In generale penso sia utile cimentarsi nell’imparare un linguaggio
nuovo e impratichirsi un po’ nella lettura della documentazione in vista
del futuro, anche per esempio del lavoro di tesi, dove spesso bisogna
utilizzare un linguaggio che non si conosce. Forse iniziare il corso non
conoscendo il linguaggio che si userà può sembrare una complicazione in
più, ma le esercitazioni delle prime settimane sono molto semplici e
avrete sicuramente il tempo di iniziare a familiarizzare con il vostro
linguaggio.</p>
</body>
</html>
