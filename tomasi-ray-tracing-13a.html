<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Maurizio Tomasi maurizio.tomasi@unimi.it">
  <title>Lezione 13</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reset.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reveal.css">
  <style>
    .reveal .sourceCode {  /* see #7635 */
      /* overflow: visible; */
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/theme/white.css" id="theme">
  <link rel="stylesheet" href="./css/custom.css"/>
  <link rel="stylesheet" href="./css/asciinema-player.css"/>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Lezione 13</h1>
  <p class="subtitle">Analisi sintattica e semantica – Conclusioni</p>
  <p class="author">Maurizio Tomasi <a
href="mailto:maurizio.tomasi@unimi.it"
class="email">maurizio.tomasi@unimi.it</a></p>
</section>

<section id="analisi-sintattica-e-semantica" class="slide level1">
<h1>Analisi sintattica e semantica</h1>
</section>
<section id="analisi-sintattica-e-semantica-1" class="slide level1">
<h1>Analisi sintattica e semantica</h1>
<ul>
<li><p>Nella scorsa lezione abbiamo visto come è possibile implementare
un’analisi lessicale di un file sorgente che definisce la scena
3D.</p></li>
<li><p>Il <em>lexer</em> che abbiamo implementato legge una sequenza di
caratteri da uno <em>stream</em> (un file) e produce come output una
sequenza di <em>token</em>.</p></li>
<li><p>Il compito di oggi è interpretare la sequenza di <em>token</em>
(analisi sintattica) e da questa costruire in memoria una serie di
oggetti di tipo <code>Shape</code>, <code>Material</code>, etc. (analisi
semantica).</p></li>
</ul>
</section>
<section id="analisi-sintattica" class="slide level1">
<h1>Analisi sintattica</h1>
<ul>
<li><p>La sintassi di un linguaggio è divisibile in categorie a seconda
delle peculiarità nella sua sintassi e nel modo in cui sono quindi
concatenati i token: <a
href="https://en.wikipedia.org/wiki/LL_parser">LL(n)</a>, <a
href="https://en.wikipedia.org/wiki/LR_parser">LR(n)</a>, <a
href="https://en.wikipedia.org/wiki/GLR_parser">GLR(n)</a>, <a
href="https://en.wikipedia.org/wiki/LALR_parser">LALR(n)</a>,
etc.</p></li>
<li><p>Ciascuna di queste famiglie richiede algoritmi specifici per
l’analisi sintattica, e purtroppo algoritmi che vanno bene per una
famiglia non vanno necessariamente bene per altre!</p></li>
<li><p>Il nostro linguaggio è di tipo LL(1), come il linguaggio <a
href="https://en.wikipedia.org/wiki/Pascal_(programming_language)">Pascal</a>,
e l’algoritmo corrispondente per analizzare la grammatica è tra i più
semplici.</p></li>
</ul>
</section>
<section id="come-affrontare-il-problema" class="slide level1">
<h1>Come affrontare il problema</h1>
<ul>
<li><p>Consideriamo questa definizione:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>material sky_material(</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    diffuse(image(<span class="st">&quot;sky-dome.pfm&quot;</span>)),</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    uniform(<span class="op">&lt;</span><span class="fl">0.7</span>, <span class="fl">0.5</span>, <span class="dv">1</span><span class="op">&gt;</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div></li>
<li><p>È una definizione che include elementi più complessi di un
<em>token</em>:</p>
<ol>
<li>Un materiale;</li>
<li>Una BRDF (<code>diffuse</code>);</li>
<li>Due pigmenti (<code>image</code> e <code>uniform</code>);</li>
<li>Un colore, indicato con <code>&lt;0.7, 0.5, 1&gt;</code>.</li>
</ol></li>
</ul>
</section>
<section id="approccio-top-down" class="slide level1">
<h1>Approccio <em>top-down</em></h1>
<ul>
<li><p>È però semplice scrivere una funzione che analizzi la definizione
di <code>sky_material</code> se essa può appoggiarsi su altre funzioni,
ciascuna delle quali analizza <em>un elemento soltanto</em>.</p></li>
<li><p>Definiamo quindi una funzione <code>parse_color</code> che si
occupa di interpretare una sequenza di <em>token</em> come un colore e
di restituire l’oggetto <code>Color</code> corrispondente, una funzione
<code>parse_pigment</code>, una funzione <code>parse_brdf</code>,
etc.</p></li>
<li><p>Queste funzioni avranno il compito di chiamarsi a vicenda, una
dentro l’altra, in modo che quelle più ad alto livello come
<code>parse_material</code> possano contare su quelle via via più
semplici come <code>parse_color</code>.</p></li>
</ul>
</section>
<section id="parse_color" class="slide level1">
<h1><code>parse_color</code></h1>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> expect_symbol(stream: InputStream, symbol: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Read a token from `stream` and check that it matches `symbol`.&quot;&quot;&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    token <span class="op">=</span> stream.read_token()</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(token, SymbolToken) <span class="kw">or</span> token.symbol <span class="op">!=</span> symbol:</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> parser_error(token, <span class="ss">f&quot;got &#39;</span><span class="sc">{</span>token<span class="sc">}</span><span class="ss">&#39; instead of &#39;</span><span class="sc">{</span>symbol<span class="sc">}</span><span class="ss">&#39;&quot;</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Don&#39;t bother returning the character: we were already expecting it</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> expect_number(stream: InputStream) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Read a token from `stream` and check that it is either a literal number or a variable.</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co">    Return the number as a ``float``.&quot;&quot;&quot;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    token <span class="op">=</span> input_file.read_token()</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(token, LiteralNumberToken):</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> token.value</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(token, IdentifierToken):</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        variable_name <span class="op">=</span> token.identifier</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> variable_name <span class="kw">not</span> <span class="kw">in</span> scene.float_variables:</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> GrammarError(token.location, <span class="ss">f&quot;unknown variable &#39;</span><span class="sc">{</span>token<span class="sc">}</span><span class="ss">&#39;&quot;</span>)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> scene.float_variables[variable_name]</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">raise</span> GrammarError(token.location, <span class="ss">f&quot;got &#39;</span><span class="sc">{</span>token<span class="sc">}</span><span class="ss">&#39; instead of a number&quot;</span>)</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a><span class="co"># This parses a list of tokens like &quot;&lt;0.7, 0.5, 1&gt;&quot;. Note that functions</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="co"># with name &quot;expect_*&quot; only read *one* token, while functions named</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a><span class="co"># &quot;parse_*&quot; read more than one token.</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_color(stream: InputStream) <span class="op">-&gt;</span> Color:</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    expect_symbol(stream, <span class="st">&quot;&lt;&quot;</span>)</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    red <span class="op">=</span> expect_number(stream)</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    expect_symbol(stream, <span class="st">&quot;,&quot;</span>)</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    green <span class="op">=</span> expect_number(stream)</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    expect_symbol(stream, <span class="st">&quot;,&quot;</span>)</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    blue <span class="op">=</span> expect_number(stream)</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>    expect_symbol(stream, <span class="st">&quot;&gt;&quot;</span>)</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create the &quot;Color&quot; object *immediately* (not something a real-world</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>    <span class="co"># compiler will do, but our case is simpler than a real compiler)</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Color(red, green, blue)</span></code></pre></div>
</section>
<section id="parse_pigment" class="slide level1">
<h1><code>parse_pigment</code></h1>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_pigment(stream: InputStream) <span class="op">-&gt;</span> Pigment:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Examples: uniform(&lt;0.7, 0.5, 1&gt;)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">#           checkered(&lt;0.3, 0.5, 0.1&gt;, &lt;0.1, 0.2, 0.5&gt;, 4)</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">#           image(&quot;bitmap.pfm&quot;)</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    keyword <span class="op">=</span> expect_keywords(stream, [</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        KeywordEnum.UNIFORM,</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        KeywordEnum.CHECKERED,</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        KeywordEnum.IMAGE,</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    expect_symbol(stream, <span class="st">&quot;(&quot;</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> keyword <span class="op">==</span> KeywordEnum.UNIFORM:</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> parse_color(stream)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> UniformPigment(color<span class="op">=</span>color)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> keyword <span class="op">==</span> KeywordEnum.CHECKERED:</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        color1 <span class="op">=</span> parse_color(stream)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        expect_symbol(stream, <span class="st">&quot;,&quot;</span>)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        color2 <span class="op">=</span> parse_color(stream)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        expect_symbol(stream, <span class="st">&quot;,&quot;</span>)</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        num_of_steps <span class="op">=</span> <span class="bu">int</span>(expect_number(stream))</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> CheckeredPigment(color1<span class="op">=</span>color1, color2<span class="op">=</span>color2, num_of_steps<span class="op">=</span>num_of_steps)</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> …: <span class="co"># Other pigments</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        …</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    expect_symbol(stream, <span class="st">&quot;)&quot;</span>)</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span></code></pre></div>
</section>
<section id="analisi-semantica-e-oltre" class="slide level1">
<h1>Analisi semantica e oltre</h1>
<ul>
<li><p>Il nostro «compilatore» è molto semplice, e non appena l’analisi
sintattica capisce che si sta definendo una
variabile/materiale/forma/osservatore crea immediatamente in memoria un
oggetto corrispondente (es., <code>Color</code>).</p></li>
<li><p>Compilatori più complessi creano in memoria una AST (Abstract
Syntax Tree), che è una rappresentazione del contenuto del file sorgente
molto comoda per fare un’analisi <em>semantica</em>. (Nel nostro caso,
analisi sintattica e semantica sono fuse insieme).</p></li>
<li><p>La AST viene poi passata come input alle fasi successive del
compilatore (ottimizzatore, generatore di codice, etc.); sono loro a
preoccuparsi di creare oggetti in memoria o salvare istruzioni in
linguaggio macchina su file.</p></li>
</ul>
</section>
<section id="tipi-di-grammatiche" class="slide level1">
<h1>Tipi di grammatiche</h1>
</section>
<section id="grammatiche-lln" class="slide level1">
<h1>Grammatiche LL(n)</h1>
<ul>
<li><p>In una grammatica LL(n), si analizzano i token «da sinistra a
destra», ossia nell’ordine in cui sono prodotti dal
<em>lexer</em>.</p></li>
<li><p>Il numero <span class="math inline">n</span> nella scrittura
LL(n) indica che per interpretare correttamente la sintassi servono
<span class="math inline">n</span> token di <em>look-ahead</em>: ossia,
si dà un’occhiata agli <span class="math inline">n</span> token
successivi per interpretare il token corrente (simile a come funziona
<code>unread_char</code> nel nostro <em>lexer</em>).</p></li>
<li><p>Di conseguenza, il nostro formato per descrivere le scene è di
tipo LL(1) perché:</p>
<ol>
<li>Si analizza la sintassi leggendo un token alla volta e procedendo in
ordine;</li>
<li>Può essere necessario controllare il tipo del token successivo a
quello corrente, ma non di più.</li>
</ol></li>
</ul>
</section>
<section id="perché-ll1" class="slide level1">
<h1>Perché LL(1)?</h1>
<ul>
<li><p>Spieghiamo ora in quali contesti è necessario usare il
<em>look-ahead</em>.</p></li>
<li><p>Consideriamo questa definizione:</p>
<pre><code>float clock(150)</code></pre>
<p>In questo caso <strong>non</strong> è necessario un
<em>look-ahead</em>:</p>
<ol>
<li>Il primo token è la <em>keyword</em> <code>float</code>, che indica
che si sta definendo una variabile;</li>
<li>So quindi che per forza i token successivi saranno
l’<em>identificatore</em>, il simbolo <code>(</code>, un <em>numeric
literal</em> e il simbolo <code>)</code>.</li>
</ol></li>
</ul>
</section>
<section id="dichiarazione-di-un-float" class="slide level1">
<h1>Dichiarazione di un <code>float</code></h1>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Read the first token of the next statement. Only a handful of</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co"># keywords are allowed at the beginning of a statement.</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>what <span class="op">=</span> expect_keywords(stream, [KeywordEnum.FLOAT, …])</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> what <span class="op">==</span> KeywordEnum.FLOAT:</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We are going to declare a new &quot;float&quot; variable</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Read the name of the variable</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    variable_name <span class="op">=</span> expect_identifier(stream)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Now we must get a &quot;(&quot;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    expect_symbol(stream, <span class="st">&quot;(&quot;</span>)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Read the literal number to associate with the variable</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    variable_value <span class="op">=</span> expect_number(stream, scene)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check that the statement ends with &quot;)&quot;</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    expect_symbol(stream, <span class="st">&quot;)&quot;</span>)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Done! Add the variable to the list</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    variable_table[variable_name] <span class="op">=</span> variable_value</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> …:  <span class="co"># Statements other than &quot;float …&quot; can be interpreted here</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    …</span></code></pre></div>
</section>
<section id="perché-ll1-1" class="slide level1">
<h1>Perché LL(1)?</h1>
<ul>
<li><p>Consideriamo invece queste due definizioni:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>plane(sky_material, translation([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">100</span>]))                        <span class="co"># Case #1</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>plane(sky_material, translation([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">100</span>]) <span class="op">*</span> rotation_y(clock))    <span class="co"># Case #2</span></span></code></pre></div></li>
<li><p>Ovviamente dobbiamo scrivere una funzione
<code>parse_plane</code> che al suo interno invoca una funzione
<code>parse_transformation</code>.</p></li>
<li><p>Però la trasformazione presenta un problema: dopo i caratteri
<code>…100])</code> non si può sapere se la trasformazione sia
terminata, oppure se segua il simbolo <code>*</code> (composizione di
trasformazioni): in quest’ultimo caso, <code>parse_transformation</code>
avrebbe ancora lavoro da fare!</p></li>
</ul>
</section>
<section class="slide level1">

<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Start from the identity matrix</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> Transformation()</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># For simplicity, let&#39;s consider just two kinds of transformations</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    transformation_kw <span class="op">=</span> expect_keywords(stream, [</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        KeywordEnum.TRANSLATION,</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        KeywordEnum.ROTATION_Y,</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> transformation_kw <span class="op">==</span> KeywordEnum.TRANSLATION:</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        expect_symbol(stream, <span class="st">&quot;(&quot;</span>)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        result <span class="op">*=</span> translation(parse_vector(stream, scene))</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        expect_symbol(stream, <span class="st">&quot;)&quot;</span>)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> transformation_kw <span class="op">==</span> KeywordEnum.ROTATION_Y:</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        expect_symbol(stream, <span class="st">&quot;(&quot;</span>)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        result <span class="op">*=</span> rotation_y(expect_number(stream, scene))</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        expect_symbol(stream, <span class="st">&quot;)&quot;</span>)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Peek the next token</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    next_kw <span class="op">=</span> stream.read_token()</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="kw">not</span> <span class="bu">isinstance</span>(next_kw, SymbolToken)) <span class="kw">or</span> (next_kw.symbol <span class="op">!=</span> <span class="st">&quot;*&quot;</span>):</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Pretend you never read this token and put it back!</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># This requires to alter the definition of `InputStream`</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># so that it holds the unread tokens as well as unread characters</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>        stream.unread_token(next_kw)</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span></span></code></pre></div>
</section>
<section id="grammatiche-ebnf" class="slide level1">
<h1>Grammatiche EBNF</h1>
</section>
<section id="descrivere-una-grammatica" class="slide level1">
<h1>Descrivere una grammatica</h1>
<ul>
<li><p>Per «grammatica» si intende l’insieme delle regole lessicali,
sintattiche e semantiche di un linguaggio.</p></li>
<li><p>Dal punto di vista dell’analisi sintattica, dovrebbe essere
evidente che un parser ha bisogno in ogni istante di sapere qual è la
lista di <em>token</em> ammissibili nel punto in cui è arrivato ad
interpretare il codice sorgente.</p></li>
<li><p>Nella teoria dei compilatori sono state inventate alcune
notazioni per descrivere la grammatica di linguaggi, che sono utilissime
nel momento in cui si implementa un <em>lexer</em> o un
<em>parser</em>.</p></li>
</ul>
</section>
<section id="grammatica-ebnf" class="slide level1">
<h1>Grammatica EBNF</h1>
<ul>
<li><p>La notazione che vedremo è detta <em>Extended Backus-Naur
Form</em> (EBNF), ed è il risultato del lavoro di molte persone, tra cui
<a href="https://en.wikipedia.org/wiki/Niklaus_Wirth">Niklaus Wirth</a>
(il creatore del linguaggio Pascal).</p></li>
<li><p>Non descriveremo EBNF in modo completo, ma la presenteremo solo
nella misura in cui serve ai nostri scopi. È utile comprenderla perché
spesso la documentazione dei linguaggi di programmazione contiene la
loro grammatica (ad esempio <a
href="https://nim-lang.org/docs/manual.html#syntax-grammar">Nim</a>, <a
href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure">C#</a>
e <a
href="https://kotlinlang.org/docs/reference/grammar.html">Kotlin</a>;
per Rust <a href="https://github.com/rust-lang/wg-grammar">ci stanno
lavorando</a>, mentre <a href="https://dlang.org/spec/grammar.html">il
manuale di D</a> usa una sintassi diversa).</p></li>
<li><p>Nella slide successiva è mostrata l’intera struttura sintattica
della nostra grammatica in formato EBNF.</p></li>
</ul>
</section>
<section id="ebnf-del-nostro-formato" class="slide level1">
<h1>EBNF del nostro formato</h1>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>scene :<span class="op">:=</span> declaration<span class="op">*</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>declaration :<span class="op">:=</span> float_decl <span class="op">|</span> plane_decl <span class="op">|</span> sphere_decl <span class="op">|</span> material_decl <span class="op">|</span> camera_decl</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>float_decl :<span class="op">:=</span> <span class="st">&quot;float&quot;</span> IDENTIFIER <span class="st">&quot;(&quot;</span> number <span class="st">&quot;)&quot;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>plane_decl :<span class="op">:=</span> <span class="st">&quot;plane&quot;</span> <span class="st">&quot;(&quot;</span> IDENTIFIER <span class="st">&quot;,&quot;</span> transformation <span class="st">&quot;)&quot;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>sphere_decl :<span class="op">:=</span> <span class="st">&quot;sphere&quot;</span> <span class="st">&quot;(&quot;</span> IDENTIFIER <span class="st">&quot;,&quot;</span> transformation <span class="st">&quot;)&quot;</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>material_decl :<span class="op">:=</span> <span class="st">&quot;material&quot;</span> IDENTIFIER <span class="st">&quot;(&quot;</span> brdf <span class="st">&quot;,&quot;</span> pigment <span class="st">&quot;)&quot;</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>camera_decl :<span class="op">:=</span> <span class="st">&quot;camera&quot;</span> <span class="st">&quot;(&quot;</span> camera_type <span class="st">&quot;,&quot;</span> transformation <span class="st">&quot;,&quot;</span> number <span class="st">&quot;,&quot;</span> number <span class="st">&quot;)&quot;</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>camera_type :<span class="op">:=</span> <span class="st">&quot;perspective&quot;</span> <span class="op">|</span> <span class="st">&quot;orthogonal&quot;</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>brdf :<span class="op">:=</span> diffuse_brdf <span class="op">|</span> specular_brdf</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>diffuse_brdf :<span class="op">:=</span> <span class="st">&quot;diffuse&quot;</span> <span class="st">&quot;(&quot;</span> pigment <span class="st">&quot;)&quot;</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>specular_brdf :<span class="op">:=</span> <span class="st">&quot;specular&quot;</span> <span class="st">&quot;(&quot;</span> pigment <span class="st">&quot;)&quot;</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>pigment :<span class="op">:=</span> uniform_pigment <span class="op">|</span> checkered_pigment <span class="op">|</span> image_pigment</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>uniform_pigment :<span class="op">:=</span> <span class="st">&quot;uniform&quot;</span> <span class="st">&quot;(&quot;</span> color <span class="st">&quot;)&quot;</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>checkered_pigment :<span class="op">:=</span> <span class="st">&quot;checkered&quot;</span> <span class="st">&quot;(&quot;</span> color <span class="st">&quot;,&quot;</span> color <span class="st">&quot;,&quot;</span> number <span class="st">&quot;)&quot;</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>image_pigment :<span class="op">:=</span> <span class="st">&quot;image&quot;</span> <span class="st">&quot;(&quot;</span> LITERAL_STRING <span class="st">&quot;)&quot;</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>color :<span class="op">:=</span> <span class="st">&quot;&lt;&quot;</span> number <span class="st">&quot;,&quot;</span> number <span class="st">&quot;,&quot;</span> number <span class="st">&quot;&gt;&quot;</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>transformation :<span class="op">:=</span> basic_transformation <span class="op">|</span> basic_transformation <span class="st">&quot;*&quot;</span> transformation</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>basic_transformation :<span class="op">:=</span> <span class="st">&quot;identity&quot;</span></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="st">&quot;translation&quot;</span> <span class="st">&quot;(&quot;</span> vector <span class="st">&quot;)&quot;</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="st">&quot;rotation_x&quot;</span> <span class="st">&quot;(&quot;</span> number <span class="st">&quot;)&quot;</span></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="st">&quot;rotation_y&quot;</span> <span class="st">&quot;(&quot;</span> number <span class="st">&quot;)&quot;</span></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="st">&quot;rotation_z&quot;</span> <span class="st">&quot;(&quot;</span> number <span class="st">&quot;)&quot;</span></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="st">&quot;scaling&quot;</span> <span class="st">&quot;(&quot;</span> vector <span class="st">&quot;)&quot;</span></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>number :<span class="op">:=</span> LITERAL_NUMBER <span class="op">|</span> IDENTIFIER</span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a>vector :<span class="op">:=</span> <span class="st">&quot;[&quot;</span> number <span class="st">&quot;,&quot;</span> number <span class="st">&quot;,&quot;</span> number <span class="st">&quot;]&quot;</span></span></code></pre></div>
</section>
<section id="spiegazione-di-ebnf" class="slide level1">
<h1>Spiegazione di EBNF</h1>
<ul>
<li><p>Il simbolo <code>::=</code> definisce un elemento della
grammatica, ad esempio:</p>
<pre><code>number ::= LITERAL_NUMBER | IDENTIFIER</code></pre></li>
<li><p>Il simbolo <code>|</code> rappresenta una serie di alternative
(<em>or</em> logico).</p></li>
<li><p>Il simbolo <code>*</code> denota zero o più ripetizioni
(<code>+</code> ne indica una o più):</p>
<pre><code>scene ::= declaration*</code></pre></li>
<li><p>Gli identificatori <code>MAIUSCOLI</code> identificano
<em>token</em>, quelli <code>minuscoli</code> altri elementi definiti
nella grammatica EBNF.</p></li>
<li><p>Sono possibili definizioni ricorsive:</p>
<pre><code>transformation ::= basic_transformation | basic_transformation &quot;*&quot; transformation</code></pre></li>
</ul>
</section>
<section id="gestione-degli-errori-di-un-compilatore"
class="slide level1">
<h1>Gestione degli errori di un compilatore</h1>
</section>
<section id="gestione-degli-errori" class="slide level1">
<h1>Gestione degli errori</h1>
<ul>
<li><p>Il nostro codice solleva una eccezione tutte le volte che viene
individuato un errore nel codice sorgente.</p></li>
<li><p>È in grado di segnalare la riga e la colonna del <em>token</em>
in corrispondenza del quale è stato trovato l’errore, e ciò è molto
utile!</p></li>
<li><p>Ma questo modello di esecuzione impone che al primo errore la
compilazione termini! I compilatori moderni come <code>g++</code> e
<code>clang++</code> invece proseguono la compilazione andando in cerca
anche degli errori successivi.</p></li>
<li><p>Per non fermarsi al primo errore occorre cercare un
<em>termination token</em>, ossia un <em>token</em> che sia usato per
terminare un comando: una volta trovato, si prosegue dal <em>token</em>
successivo.</p></li>
</ul>
</section>
<section id="termination-tokens" class="slide level1">
<h1><em>Termination tokens</em></h1>
<ul>
<li><p>Nel linguaggio C++, due <em>termination tokens</em> molto usati
sono il <code>;</code> (usato per terminare uno <em>statement</em>) e
<code>}</code> (usato per terminare un blocco di codice. Ad esempio:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>x <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    x <span class="op">*=</span> <span class="op">-</span><span class="fl">1.0</span>  <span class="co">// Error: missing &#39;;&#39;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>x <span class="op">/=</span> <span class="dv">1</span><span class="er">O</span> <span class="op">*</span> a<span class="op">;</span>       <span class="co">// Uh-oh, I wrote a capital &quot;o&quot; instead of &quot;0&quot;</span></span></code></pre></div></li>
<li><p>In un linguaggio come il nostro non è semplice individuare un
<em>termination token</em>; la cosa migliore sarebbe richiedere la
presenza di <code>;</code> alla fine di ogni <em>statement</em>, come
nel C++, oppure obbligare a concludere le definizioni con un ritorno a
capo (che sia codificato come un token
<code>TOKEN_NEWLINE</code>).</p></li>
</ul>
</section>
<section id="linguaggi-a-confronto" class="slide level1">
<h1>Linguaggi a confronto</h1>
</section>
<section id="complessità-di-un-compilatore" class="slide level1">
<h1>Complessità di un compilatore</h1>
<ul>
<li><p>La produzione di <em>liste</em> di errori anziché di un solo
errore alla volta è importante soprattutto in quei casi in cui il
compilatore è molto lento da eseguire. Questo è il caso del C++ e di
Rust.</p></li>
<li><p>Il nostro linguaggio sarà molto semplice da interpretare (non ha
una semantica complessa, e non richiede la creazione di una AST né
l’applicazione di un ottimizzatore): non vale quindi la pena
preoccuparsi di implementare questa funzionalità.</p></li>
<li><p>Però cogliamo l’occasione per capire perché possano esserci
grandi differenze nella velocità di compilazione di linguaggi!</p></li>
</ul>
</section>
<section id="complessità-del-c" class="slide level1">
<h1>Complessità del C++</h1>
<ul>
<li><p>La grande complessità del C++ è legata soprattutto ai
<code>template</code> e all’uso degli <em>header file</em>; rendiamoci
conto di questa difficoltà già guardando alcuni semplici
esempi.</p></li>
<li><p>Considerate questa definizione, che mostra la difficoltà di
interpretare <code>&gt;&gt;</code>:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;&gt;</span> matrix <span class="op">=</span> identity<span class="op">(</span><span class="dv">3</span><span class="op">);</span> <span class="co">// &gt;&gt; are *two* tokens</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> matrix<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span> <span class="co">// Here &gt;&gt; is *one* token</span></span></code></pre></div></li>
<li><p>È impossibile creare la sequenza di token corretta con
l’approccio che abbiamo seguito, che divide rigidamente il
<em>lexing</em> dal <em>parsing</em> (e infatti la prima riga non era
ammessa dallo standard C++ fino a pochi anni fa).</p></li>
</ul>
</section>
<section id="altre-difficoltà-dei-template" class="slide level1">
<h1>Altre difficoltà dei <code>template</code></h1>
<ul>
<li><p>I template C++ rendono complessa anche l’analisi sintattica:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="dt">bool</span> x86_64<span class="op">&gt;</span> <span class="kw">struct</span> MyStruct<span class="op">;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;&gt;</span> <span class="kw">struct</span> MyStruct<span class="op">&lt;</span><span class="kw">false</span><span class="op">&gt;</span> <span class="op">{</span> <span class="co">/* Fields valid on 32-bit machines */</span> <span class="op">};</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;&gt;</span> <span class="kw">struct</span> MyStruct<span class="op">&lt;</span><span class="kw">true</span><span class="op">&gt;</span> <span class="op">{</span> <span class="co">/* Fields valid on 64-bit machines */</span> <span class="op">};</span></span></code></pre></div></li>
<li><p>Si tratta in pratica di <em>due</em> strutture con lo stesso nome
(<code>MyStruct</code>). Questo può essere usato ad esempio nel codice
seguente:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>MyStruct<span class="op">&lt;</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">size_t</span><span class="op">)</span> <span class="op">&gt;</span> <span class="dv">4</span><span class="op">&gt;</span> A<span class="op">;</span>  <span class="co">// On 64-bit machines use the extended definition</span></span></code></pre></div>
<p>Ma a livello di sintassi, il termine <code>&gt;</code> rende tutto
complicato!</p></li>
</ul>
</section>
<section id="una-testimonianza-importante" class="slide level1">
<h1>Una testimonianza importante</h1>
<blockquote>
<p>I’ve become somewhat infamous about wanting to keep the language
[Rust] LL(1) but the fact is that today one can’t parse Rust very
easily, much less pretty-print (thus auto-format) it, and this is an
actual (and fairly frequent) source of problems. It’s easier to work
with than C++, but that’s fairly faint praise. I lost almost every
argument about this, from the <strong>angle brackets for type
parameters</strong> [emphasis added] to the pattern-binding ambiguity to
the semicolon and brace rules to … ugh I don’t even want to get into it.
The grammar is not what I wanted. Sorry.</p>
</blockquote>
<p style="text-align:right">
<a href="https://graydon2.dreamwidth.org/307291.html">Graydon Hoare</a>,
creatore del linguaggio Rust.
</p>
</section>
<section id="soluzioni-al-problema-12" class="slide level1">
<h1>Soluzioni al problema (1/2)</h1>
<ul>
<li><p>Quando sono stati introdotti i <em>template</em> in C++, è stata
una <a
href="https://keleshev.com/parsing-ambiguity-type-argument-v-less-than">pessima</a>
<a
href="https://stackoverflow.com/questions/7304699/what-are-all-the-syntax-problems-introduced-by-the-usage-of-angle-brackets-in-c">scelta</a>
usare come simboli <code>&lt;</code> e <code>&gt;</code>, perché (1)
erano già usati come operatori di confronto, e (2) esistevano già gli
operatori <code>&lt;&lt;</code> e <code>&gt;&gt;</code>.</p></li>
<li><p>C# soffre del medesimo problema, ma è meno grave (in C# i
<em>template</em> si chiamano <em>generics</em>):</p>
<ol type="1">
<li>Per distinguere tra il caso in cui <code>&gt;&gt;</code> va
interpretato come due token o come uno, la regola è che se il token
successivo è <code>(</code>, <code>)</code>, <code>]</code>,
<code>:</code>, <code>;</code>, <code>,</code>, <code>.</code>,
<code>?</code>, <code>==</code> oppure <code>!=</code>, allora va
interpretato come due token, altrimenti uno;</li>
<li>Dentro <code>&lt;&gt;</code> si possono solo indicare tipi, non
espressioni come <code>a &gt; b</code>.</li>
</ol></li>
<li><p>Pascal, Nim e Kotlin usano <code>shl</code> e <code>shr</code>
per questi operatori.</p></li>
</ul>
</section>
<section id="soluzioni-al-problema-22" class="slide level1">
<h1>Soluzioni al problema (2/2)</h1>
<ul>
<li><p>Il linguaggio D invece usa una <a
href="https://dlang.org/spec/template.html">sintassi diversa</a> per i
<em>template</em>, e nell’esempio precedente scriverebbe</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode d"><code class="sourceCode d"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>MyStruct<span class="op">!(</span>sizeof<span class="op">(</span><span class="bu">size_t</span><span class="op">)</span> <span class="op">&gt;</span> <span class="dv">4</span><span class="op">)</span> A<span class="op">;</span></span></code></pre></div>
<p>Questa sintassi è molto più semplice da analizzare!</p></li>
<li><p>Rust usa <code>&lt;&gt;</code> come il C++, ma per rimuovere
l’ambiguità richiede di scrivere <code>::&lt;</code> nelle
espressioni:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">//      Here you can use &lt;      Here you must use ::&lt;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co">//        ~~~~~~~~~~~~~           ~~~~~~~~~~~~~~~~~</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x<span class="op">:</span>    <span class="pp">foo::</span>Foo<span class="op">&lt;</span>Bar<span class="op">&gt;</span>     <span class="op">=</span>     <span class="pp">foo::Foo::</span><span class="op">&lt;</span>Bar<span class="op">&gt;</span>()<span class="op">;</span></span></code></pre></div></li>
</ul>
</section>
<section id="esempio-variabili" class="slide level1">
<h1>Esempio: variabili</h1>
<ul>
<li><p>Nel linguaggio Pascal le variabili si elencano dentro una
clausola <code>var</code>. Il nome della variabile viene per primo ed è
chiaramente separato dal tipo:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode pascal"><code class="sourceCode pascal"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    myvar : <span class="kw">Array</span> [<span class="dv">1</span>..<span class="dv">100</span>] <span class="kw">of</span> <span class="dt">Integer</span>;</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    other : <span class="dt">String</span>;</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    x     : <span class="dt">Real</span>;</span></code></pre></div></li>
<li><p>Questa sintassi è molto facile da interpretare: il Pascal è
infatti progettato per essere semplice e nel contempo veloce da
compilare.</p></li>
<li><p>Idee simili sono usate nei linguaggi Modula, Oberon, Ada, Nim e
Kotlin.</p></li>
</ul>
</section>
<section id="dichiarazioni-in-c" class="slide level1">
<h1>Dichiarazioni in C++</h1>
<ul>
<li><p>In C/C++ invece le dichiarazioni di variabili sono complicate,
perché l’identificatore che contiene il nome della variabile è messo in
mezzo al tipo:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> myvar<span class="op">[</span><span class="dv">100</span><span class="op">];</span>  <span class="co">/* More complicated: static const int * myvar[100] */</span></span></code></pre></div>
<p>che dichiara un array di 100 variabili di tipo
<code>int</code>.</p></li>
<li><p>I token che definiscono il tipo sono <code>int</code>,
<code>[</code>, <code>100</code> e <code>]</code>, e si trovano sia a
<em>sinistra</em> che a <em>destra</em> del nome della variabile: questo
per il programmatore è complicato! (Provate a interpretare il caso
<em>more complicated</em> da soli!)</p></li>
</ul>
</section>
<section id="il-caso-di-go" class="slide level1">
<h1>Il caso di Go</h1>
<ul>
<li><p>Il linguaggio <a href="https://golang.org/">Go</a>, che è
fortemente ispirato al C, rende più semplici le dichiarazioni usando una
notazione diversa, più simile al Pascal:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode go"><code class="sourceCode go"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> myvar <span class="op">[</span><span class="dv">100</span><span class="op">]</span><span class="dt">int</span></span></code></pre></div></li>
<li><p>La keyword <code>var</code> segnala al <em>parser</em> che si sta
dichiarando una variabile.</p></li>
<li><p>I token che definiscono il tipo sono riportati tutti insieme,
<em>dopo</em> l’identificatore che rappresenta il nome della
variabile.</p></li>
<li><p>La scrittura <code>[100]int</code> segue l’ordine naturale delle
parole: «un array di 100 valori <code>int</code>», ed è più facile da
leggere per il programmatore (in C bisogna leggere a ritroso, da destra
a sinistra).</p></li>
</ul>
</section>
<section id="testing-di-compilatori" class="slide level1">
<h1>Testing di compilatori</h1>
</section>
<section id="testing" class="slide level1">
<h1>Testing</h1>
<ul>
<li><p>La scrittura di test per un compilatore è una faccenda molto
complessa, perché il numero di possibili errori è praticamente
infinito!</p></li>
<li><p>Non è possibile avere test completamente esaustivi; bisogna avere
fantasia e prepararsi ad aggiungere molti nuovi test una volta che gli
utenti inizieranno ad usare il proprio programma. (In pytracer ho
implementato giusto il minimo sindacale, siete incoraggiati a scrivere
più test!)</p></li>
<li><p>Se siete curiosi, nella directory <a
href="https://github.com/llvm/llvm-project/tree/main/clang/test/Lexer"><code>clang/test/Lexer</code></a>
ci sono i file sorgente usati per i test del solo <em>lexer</em> di
Clang!</p></li>
</ul>
</section>
<section id="generazione-automatica-di-compilatori"
class="slide level1">
<h1>Generazione automatica di compilatori</h1>
</section>
<section id="generazione-automatica" class="slide level1">
<h1>Generazione automatica</h1>
<ul>
<li><p>Esistono strumenti per generare automaticamente <em>lexer</em> e
<em>parser</em>. Questi richiedono come file di input una grammatica
(solitamente nella forma EBNF), e producono in output codice sorgente
che interpreta la grammatica.</p></li>
<li><p>Due strumenti storicamente importanti sono <code>lex</code> e
<code>yacc</code>, che oggi sono disponibili nelle versioni open source
<a
href="https://en.wikipedia.org/wiki/Flex_(lexical_analyser_generator)">Flex</a>
e <a href="https://en.wikipedia.org/wiki/GNU_Bison">Bison</a> (generano
codice C/C++).</p></li>
<li><p><a
href="https://sqlite.org/src/doc/trunk/doc/lemon.html">Lemon</a> genera
codice C, ed è stato usato per scrivere il parser SQL usato in
SQLite.</p></li>
<li><p><a href="https://en.wikipedia.org/wiki/ANTLR">ANTLR</a> (C++, C#,
Java, Python) è la soluzione più completa e moderna.</p></li>
<li><p>Tenete però presente che la maggior parte della gente preferisce
scrivere <em>lexer</em> e <em>parser</em> a mano…</p></li>
</ul>
</section>
<section id="approfondimenti" class="slide level1">
<h1>Approfondimenti</h1>
<ul>
<li><p>Il libro di Wirth <a
href="https://people.inf.ethz.ch/wirth/CompilerConstruction/"><em>Compiler
Construction</em></a> (Addison-Wesley, 1996) è di una chiarezza
esemplare: in poche pagine come implementa un compilatore per il
linguaggio <a
href="https://en.wikipedia.org/wiki/Oberon_(programming_language)">Oberon</a>
(un linguaggio creato da Wirth come successore del Pascal).</p></li>
<li><p>Il testo «sacro» che illustra la teoria dei compilatori è il
cosiddetto <em>dragon book</em> di Aho, Sethi, Lam &amp; Ullman:
<em>Compilers – Principles, Techniques and Tools</em> (Pearson
Publishing, 2006).</p></li>
<li><p>Oggi i compilatori sono notevolmente più complessi a causa della
necessaria integrazione con gli ambienti di sviluppo (PyCharm, CLion,
IntelliJ IDEA, etc.). Guardate il video <a
href="https://www.youtube.com/watch?v=wSdV1M7n4gQ"><em>Anders Hejlsberg
on Modern Compiler Construction</em></a>: apprezzerete molto di più
quello che fanno le vostre IDE!</p></li>
</ul>
</section>
<section id="conclusioni-del-corso" class="slide level1">
<h1>Conclusioni del corso</h1>
</section>
<section id="conclusioni-del-corso-1" class="slide level1">
<h1>Conclusioni del corso</h1>
<ul>
<li><p>Siamo arrivati alla fine del corso!</p></li>
<li><p>Una volta implementato il <em>parser</em>, potrete rilasciare la
versione <code>1.0</code> del vostro programma, venderla alla Disney
Studios, fare un sacco di soldi e vivere da nababbi per il resto della
vostra vita!</p></li>
<li><p>Se invece avete intenzione di continuare a fare il mestiere del
«fisico», prima di concludere è bene rivedere cosa abbiamo imparato in
questo corso e come ciò vi possa essere utile in futuro, anche se questo
non prevederà il <em>rendering</em> di scene 3D…</p></li>
</ul>
</section>
<section id="le-abilità-più-importanti" class="slide level1">
<h1>Le abilità più importanti</h1>
<ul>
<li><p>Il codice va scritto poco alla volta, verificando con test ogni
nuova <em>feature</em>: non si scrive tutto un programma da cima a fondo
senza mai provarlo o compilarlo!</p></li>
<li><p>Automatizzate i test mediante <em>CI builds</em>.</p></li>
<li><p>Usate sistemi di controllo versione per monitorare i
cambiamenti.</p></li>
<li><p>Siate ordinati nell’uso di <em>issues</em>, <em>pull
requests</em>, file <code>CHANGELOG</code>, etc.</p></li>
<li><p>Decidete sin da subito quale licenza usare per rilasciare il
vostro codice.</p></li>
<li><p>Documentate il vostro lavoro (<code>README</code>,
docstrings…).</p></li>
<li><p>Imparate a usare una IDE appropriata!</p></li>
</ul>
</section>
<section id="codici-di-simulazione" class="slide level1">
<h1>Codici di simulazione</h1>
<ul>
<li><p>Nel caso specifico di codici di simulazione, scegliete bene il
vostro <a href="tomasi-ray-tracing-11b.html#algoritmi">generatore di
numeri casuali</a>!</p></li>
<li><p>È importante che l’utente del vostro codice possa specificare il
<em>seed</em> e, se il generatore lo prevede, l’identificatore della
sequenza: questo permette la ripetibilità delle simulazioni, e ciò aiuta
molto in fase di <em>debugging</em>.</p></li>
<li><p>Se si devono fare tante simulazioni, usate la possibilità dei
computer moderni di fare calcoli in parallelo. Nei casi più semplici è
sufficiente usare <a
href="tomasi-ray-tracing-11b.html#generare-animazioni">GNU
Parallel</a>.</p></li>
</ul>
</section>
<section id="estendibilità" class="slide level1">
<h1>Estendibilità</h1>
<ul>
<li><p>È molto probabile che gli utenti dei programmi che svilupperete
provino ad usarli in contesti che voi non avevate previsto.</p></li>
<li><p>È importante quindi che il proprio programma abbia un certo grado
di <em>versatilità</em>.</p></li>
<li><p>(Non bisogna però esagerare: più un programma è versatile, più e
complesso da scrivere, e rischiate quindi di non arrivare mai a
rilasciare la versione 1.0!)</p></li>
</ul>
</section>
<section id="io-usate-degli-standard" class="slide level1">
<h1>I/O: usate degli standard!</h1>
<ul>
<li><p>Nel nostro progetto abbiamo implementato la possibilità di
leggere la scena da un file. Questo è molto più versatile del semplice
comando <code>demo</code>!</p></li>
<li><p>In maniera analoga, alcuni di voi hanno fatto in modo che il
proprio programma salvasse immagini in più formati: non solo PFM, ma
anche PNG, JPEG, etc.</p></li>
<li><p>In generale, è bene fare affidamento su formati diffusi (PNG,
JPEG) piuttosto che su formati oscuri (PFM) o addirittura inventati da
soli! Quest’ultima opzione è percorribile solo se non esistono formati
adatti (è il caso del linguaggio per le scene che abbiamo inventato
noi).</p></li>
</ul>
</section>
<section id="possibili-approcci" class="slide level1">
<h1>Possibili approcci</h1>
<ul>
<li><p>La versatilità negli input/output di un programma si ottiene in
vari modi:</p>
<ol>
<li>Usare un formato di dati generico già disponibile;</li>
<li>Inventare un formato di dati <em>ad hoc</em> per il programma;</li>
<li>Incorporare il compilatore/interprete di un linguaggio nel proprio
programma;</li>
<li>Creare <em>bindings</em> al nostro codice in un linguaggio
interpretato (es. Python).</li>
</ol></li>
<li><p>Vediamo una ad una queste possibilità.</p></li>
</ul>
</section>
<section id="usare-un-formato-esistente" class="slide level1">
<h1>1. Usare un formato esistente</h1>
</section>
<section id="esempio" class="slide level1">
<h1>Esempio</h1>
<ul>
<li><p>Considerate un programma che fa una simulazione di un fenomeno
fisico, e stampa risultati a video:</p>
<pre><code>$ ./myprogram
Calculating...
Estimated temperature of the air: 296 K
The speed of the particle is 8.156 m/s²
Force: 156.0 N
$</code></pre></li>
<li><p>L’output del programma non è facilmente fruibile: i numeri sono
difficili da recuperare in mezzo al testo. Un output migliore è il
seguente:</p>
<pre><code>$ ./myprogram
&quot;Temperature [K]&quot;,296
&quot;Speed [m/s²]&quot;,8.156
&quot;Force [N]&quot;,156.0</code></pre></li>
</ul>
</section>
<section class="slide level1">

<p><asciinema-player src="cast/sc-im-84x19.cast" cols="84" rows="19" font-size="medium"></asciinema-player></p>
</section>
<section id="usare-un-formato-esistente-1" class="slide level1">
<h1>Usare un formato esistente</h1>
<ul>
<li><p>Il vantaggio di formati esistenti è che sono leggibili anche da
programmi diversi dal vostro: ad esempio, un file CSV è leggibile da
Microsoft Excel, LibreOffice, Gnumeric, etc. Ciò è molto comodo
soprattutto quando dovete condividere questi dati con altre
persone.</p></li>
<li><p>Se dovete solo salvare tabelle di numeri, le soluzioni migliori
sono probabilmente file CSV (di testo) o file Excel (binari). La
libreria Python <a
href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_excel.html">Pandas</a>
li supporta entrambi.</p></li>
<li><p>Formati più compatti che vanno bene per dati tabulari e
matriciali sono <a href="https://en.wikipedia.org/wiki/FITS">FITS</a>
(vecchio ma molto ben supportato) e <a
href="https://en.wikipedia.org/wiki/Hierarchical_Data_Format">HDF5</a>
(più nuovo ed efficiente, meno supportato).</p></li>
</ul>
</section>
<section id="formati-più-complessi" class="slide level1">
<h1>Formati più complessi</h1>
<ul>
<li><p>I formati CSV ed Excel vanno bene per <em>memorizzare</em> numeri
organizzati in tabelle, ma spesso si devono applicare filtri complessi e
calcoli a questi dati.</p></li>
<li><p>Un ottimo formato per questo scopo è <a
href="https://www.sqlite.org/index.html">sqlite3</a>: a differenza di
CSV ed Excel, offre eccellenti funzioni per fare ricerche e calcoli sui
dati, ed è ottimizzato per grandi volumi di dati (fino a
terabytes).</p></li>
<li><p>Se non è sufficiente un tipo tabellare, potete usare il formato
<a href="https://en.wikipedia.org/wiki/JSON">JSON</a>, <a
href="https://en.wikipedia.org/wiki/YAML">YAML</a> (che avete già usato
per le GitHub Actions) o <a
href="https://en.wikipedia.org/wiki/XML">XML</a>: sono in grado di
salvare tipi di dati molto diversi tra loro (persino liste e
dizionari!).</p></li>
<li><p>XML è il più complesso, ma implementa un sistema di controllo
della «sintassi» nel file (detto <a
href="https://en.wikipedia.org/wiki/XML_schema">XML schema</a>) che lo
rende molto più robusto (anche se più difficile da scrivere).</p></li>
</ul>
</section>
<section class="slide level1">

<p><asciinema-player src="cast/json-example-python-julia-78x20.cast" cols="78" rows="20" font-size="medium"></asciinema-player></p>
<p>Il vantaggio di usare un formato diffuso come JSON è che sono a
disposizioni molti strumenti per visualizzarlo e modificarlo: vedete ad
esempio <a href="https://stedolan.github.io/jq/">jq</a>.</p>
</section>
<section id="il-caso-del-nostro-ray-tracer" class="slide level1">
<h1>Il caso del nostro ray-tracer</h1>
<ul>
<li><p>Nel caso del nostro programma avremmo potuto usare il formato
JSON:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span> <span class="dt">&quot;camera&quot;</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">&quot;projection&quot;</span><span class="fu">:</span> <span class="st">&quot;perspective&quot;</span><span class="fu">,</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">&quot;transformations&quot;</span><span class="fu">:</span> <span class="ot">[</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>            <span class="fu">{</span> <span class="dt">&quot;type&quot;</span><span class="fu">:</span> <span class="st">&quot;rotation_z&quot;</span><span class="fu">,</span> <span class="dt">&quot;angle_deg&quot;</span><span class="fu">:</span> <span class="fl">30.0</span> <span class="fu">}</span><span class="ot">,</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>            <span class="fu">{</span> <span class="dt">&quot;type:&quot;</span> <span class="dt">&quot;translation&quot;</span><span class="fu">,</span> <span class="dt">&quot;vector&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="dv">-4</span><span class="ot">,</span> <span class="dv">0</span><span class="ot">,</span> <span class="dv">1</span><span class="ot">]</span> <span class="fu">}</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>        <span class="ot">]</span><span class="fu">,</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">&quot;distance&quot;</span><span class="fu">:</span> <span class="fl">1.0</span><span class="fu">,</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">&quot;aspect_ratio&quot;</span><span class="fu">:</span> <span class="fl">1.0</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">},</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    <span class="er">...</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div></li>
<li><p>Non serve un <em>lexer</em> e un <em>parser</em>, ma bisogna
comunque validare il contenuto (es., <code>camera</code> deve contenere
<code>projection</code>).</p></li>
</ul>
</section>
<section id="inventare-un-formato" class="slide level1">
<h1>2. Inventare un formato</h1>
</section>
<section id="inventare-un-formato-1" class="slide level1">
<h1>Inventare un formato</h1>
<ul>
<li><p>È la soluzione che abbiamo adottato per descrivere le scene
tridimensionali nel nostro programma.</p></li>
<li><p>Attività molto creativa, ma ha alcuni potenziali problemi:</p>
<ul>
<li><p>Rischia di richiedere molto tempo allo sviluppatore…</p></li>
<li><p>…e richiede che l’utente impari la sintassi e la semantica del
vostro linguaggio</p></li>
</ul></li>
<li><p>Noi l’abbiamo adottata a lezione per la sua valenza didattica
(comprensione del funzionamento dei compilatori, gestione degli errori,
…), e perché non è comunque facile usare un formato generico come JSON
in questo contesto particolare.</p></li>
</ul>
</section>
<section id="incorporare-un-linguaggio" class="slide level1">
<h1>3. Incorporare un linguaggio</h1>
</section>
<section id="incorporare-un-linguaggio-1" class="slide level1">
<h1>Incorporare un linguaggio</h1>
<ul>
<li><p>Una soluzione usata soprattutto per programmi vasti e complessi è
quella di incorporare un interprete di un linguaggio «semplice»
all’interno del proprio programma (questo tipo di interpreti è detto
<em>embedded</em>).</p></li>
<li><p>Esempi notevoli:</p>
<ul>
<li>Microsoft <a
href="https://en.wikipedia.org/wiki/Visual_Basic_for_Applications">Visual
Basic for Applications</a> (linguaggio BASIC incluso in Word, Excel e
molte altre);</li>
<li><a href="https://en.wikipedia.org/wiki/AutoLISP">AutoLISP</a>
(interprete LISP usato in AutoCAD);</li>
<li><a href="https://www.gnu.org/software/guile/">GNU Guile</a>
(interprete Scheme usato in <a
href="https://docs.gimp.org/en/gimp-concepts-script-fu.html">The
Gimp</a>, <a
href="https://lilypond.org/doc/v2.18/Documentation/extending/scheme-tutorial">Lilypond</a>,
etc.)</li>
<li>Python (usato in <a
href="https://docs.blender.org/manual/en/latest/advanced/scripting/introduction.html">Blender</a>,
<a
href="https://wiki.inkscape.org/wiki/index.php/Python_modules_for_extensions">Inkscape</a>,
<a href="https://www.gimp.org/docs/python/index.html">The Gimp</a>, <a
href="https://projects.raspberrypi.org/en/projects/getting-started-with-minecraft-pi/4">Minecraft</a>).</li>
</ul></li>
<li><p>Vedi <a
href="https://dspace.mit.edu/handle/1721.1/5980"><em>Programmable
Applications: Interpreter Meets Interface</em></a> (Eisenberg,
1995).</p></li>
</ul>
</section>
<section class="slide level1">

<center>
<img data-src="media/blender-python.webp" height="620" />
</center>
<p>In Blender è possibile aprire un terminale Python in cui lanciare
comandi per creare oggetti, modificarli, etc.</p>
</section>
<section id="logica-di-funzionamento" class="slide level1">
<h1>Logica di funzionamento</h1>
<ul>
<li><p>Il linguaggio incorporato nella applicazione è «esteso» con
funzioni specifiche per manipolare gli oggetti gestiti
dall’applicazione. Ad esempio, questo codice VBA può essere usato per
modificare la cella <code>A1</code> di un foglio Excel:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode monobasic"><code class="sourceCode monobasic"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">Sub </span>Macro1()</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    Worksheets(1).Range(<span class="st">&quot;A1&quot;</span>).Value = <span class="st">&quot;Wow!&quot;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    Worksheets(1).Range(<span class="st">&quot;A1&quot;</span>).Borders.LineStyle = xlDouble</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="kw">End Sub</span></span></code></pre></div></li>
<li><p>Comodo per automatizzare task ripetitivi (es. creare oggetti
ripetuti in programmi grafici come Blender).</p></li>
<li><p>Alcuni linguaggi (<a
href="https://www.gnu.org/software/guile/">GNU Guile</a>, <a
href="https://www.lua.org/">Lua</a>…) sono pensati principalmente per
usi <em>embedded</em>.</p></li>
</ul>
</section>
<section id="esempio-python" class="slide level1">
<h1>Esempio Python</h1>
<p>Questo programma C inizializza l’interprete Python ed esegue un
semplice script. Nella realtà, questo script potrebbe essere stato
digitato dall’utente in una finestra di dialogo del programma:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define PY_SSIZE_T_CLEAN</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;Python.h&gt;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>argv<span class="op">[])</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">wchar_t</span> <span class="op">*</span>program <span class="op">=</span> Py_DecodeLocale<span class="op">(</span>argv<span class="op">[</span><span class="dv">0</span><span class="op">],</span> NULL<span class="op">);</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>program <span class="op">==</span> NULL<span class="op">)</span> <span class="op">{</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>        fprintf<span class="op">(</span>stderr<span class="op">,</span> <span class="st">&quot;Fatal error: cannot decode argv[0]</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>        exit<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    Py_SetProgramName<span class="op">(</span>program<span class="op">);</span>  <span class="co">/* optional but recommended */</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    Py_Initialize<span class="op">();</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Run a simple Python program that prints the current date */</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    PyRun_SimpleString<span class="op">(</span><span class="st">&quot;from time import time,ctime</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>                       <span class="st">&quot;print(&#39;Today is&#39;, ctime(time()))</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>Py_FinalizeEx<span class="op">()</span> <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>        exit<span class="op">(</span><span class="dv">120</span><span class="op">);</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    PyMem_RawFree<span class="op">(</span>program<span class="op">);</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="registrare-funzioni" class="slide level1">
<h1>Registrare funzioni</h1>
<p>Si può estendere l’interprete Python perché riconosca nuove funzioni:
è in questo modo che si rendono disponibili le funzionalità del proprio
programma attraverso Python. Ecco un <a
href="https://docs.python.org/3/extending/embedding.html">esempio</a>:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">int</span> numargs<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="co">/* Return the number of arguments of the application command line */</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> PyObject<span class="op">*</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>emb_numargs<span class="op">(</span>PyObject <span class="op">*</span>self<span class="op">,</span> PyObject <span class="op">*</span>args<span class="op">)</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span><span class="op">(!</span>PyArg_ParseTuple<span class="op">(</span>args<span class="op">,</span> <span class="st">&quot;:numargs&quot;</span><span class="op">))</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> NULL<span class="op">;</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> PyLong_FromLong<span class="op">(</span>numargs<span class="op">);</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a><span class="co">/* This will enable the interpreter to understand the following script:</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a><span class="co"> *</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a><span class="co"> *     import emb</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a><span class="co"> *     print(emb.numargs())</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a><span class="co"> *</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> PyMethodDef EmbMethods<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span><span class="st">&quot;numargs&quot;</span><span class="op">,</span> emb_numargs<span class="op">,</span> METH_VARARGS<span class="op">,</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>     <span class="st">&quot;Return the number of arguments received by the process.&quot;</span><span class="op">},</span></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>NULL<span class="op">,</span> NULL<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> NULL<span class="op">}</span></span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> PyModuleDef EmbModule <span class="op">=</span> <span class="op">{</span></span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>    PyModuleDef_HEAD_INIT<span class="op">,</span> <span class="st">&quot;emb&quot;</span><span class="op">,</span> NULL<span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> EmbMethods<span class="op">,</span></span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a>    NULL<span class="op">,</span> NULL<span class="op">,</span> NULL<span class="op">,</span> NULL</span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-29"><a href="#cb26-29" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> PyObject<span class="op">*</span></span>
<span id="cb26-30"><a href="#cb26-30" aria-hidden="true" tabindex="-1"></a>PyInit_emb<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb26-31"><a href="#cb26-31" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb26-32"><a href="#cb26-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> PyModule_Create<span class="op">(&amp;</span>EmbModule<span class="op">);</span></span>
<span id="cb26-33"><a href="#cb26-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="il-caso-del-nostro-ray-tracer-1" class="slide level1">
<h1>Il caso del nostro ray-tracer</h1>
<ul>
<li><p>Avremmo potuto allora rendere disponibili in Python funzioni come
<code>create_sphere</code>, <code>create_brdf</code>, etc.</p></li>
<li><p>I file di input sarebbero stati normali script Python, che
potevano impiegare tutte le potenzialità del linguaggio (variabili,
funzioni, cicli <code>for</code>, etc.):</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co"># A custom type &quot;color&quot; is available alongside with the usual &quot;int&quot;, &quot;float&quot;, etc.</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>black <span class="op">=</span> color(<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>sphere_material <span class="op">=</span> create_material(</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    brdf<span class="op">=</span>diffuse_brdf(uniform_pigment(color(<span class="fl">0.7</span>, <span class="fl">0.5</span>, <span class="fl">1.0</span>))),</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    emitted_radiance<span class="op">=</span>uniform_pigment(black),</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Create many objects using a `for` loop</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> angle <span class="kw">in</span> [<span class="dv">0</span>, <span class="dv">90</span>, <span class="dv">180</span>, <span class="dv">270</span>]:</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>    create_sphere(sphere_material, rotation_x(angle) <span class="op">*</span> translation(vec(<span class="dv">10</span>, <span class="dv">0</span>, <span class="dv">0</span>)))</span></code></pre></div></li>
</ul>
</section>
<section id="creare-bindings" class="slide level1">
<h1>4. Creare <em>bindings</em></h1>
</section>
<section id="creare-bindings-1" class="slide level1">
<h1>Creare <em>bindings</em></h1>
<ul>
<li><p>Un approccio simile a quello degli interpreti <em>embedded</em> è
quello di rendere il proprio codice invocabile da un linguaggio esterno
(solitamente Python).</p></li>
<li><p>La differenza con la soluzione precedente è che in questo caso si
usa l’interprete Python installato nel sistema, e non un interprete
dedicato.</p></li>
<li><p>Il vantaggio è ovviamente che si possono combinare librerie già
installate con la nostra: la soluzione è molto più versatile, ed è
generalmente quella da preferire.</p></li>
<li><p>Questa soluzione è facilmente praticabile con linguaggi come C++,
Nim, Rust…; è decisamente più complessa per Julia, C# o Kotlin.</p></li>
</ul>
</section>
<section id="fine" class="slide level1">
<h1>Fine!</h1>
</section>
    </div>
  </div>

  <script src="https://unpkg.com/reveal.js@^4//dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="https://unpkg.com/reveal.js@^4//plugin/notes/notes.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/search/search.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/zoom/zoom.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: true,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'bottom-right',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'default',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'slide',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'fade',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

       // Parallax background image
       parallaxBackgroundImage: './media/background.png', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1440,

        height: 810,

        // reveal.js plugins
        plugins: [
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script src="js/asciinema-player.js"></script>
    <script src="https://cdn.plot.ly/plotly-1.58.4.min.js"></script>
    <script type="text/javascript" src="./js/quantization.js"></script>
    </body>
</html>
