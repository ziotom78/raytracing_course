<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Maurizio Tomasi maurizio.tomasi@unimi.it">
  <title>Lezione 6</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reset.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reveal.css">
  <style>
    .reveal .sourceCode {  /* see #7635 */
      /* overflow: visible; */
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/theme/white.css" id="theme">
  <link rel="stylesheet" href="./css/custom.css"/>
  <link rel="stylesheet" href="./css/asciinema-player.css"/>
  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Lezione 6</h1>
  <p class="subtitle">Calcolo numerico per la generazione di immagini
fotorealistiche</p>
  <p class="author">Maurizio Tomasi <a
href="mailto:maurizio.tomasi@unimi.it"
class="email">maurizio.tomasi@unimi.it</a></p>
</section>

<section id="animazioni" class="slide level1">
<h1>Animazioni</h1>
</section>
<section id="creazione-di-animazioni" class="slide level1">
<h1>Creazione di animazioni</h1>
<ul>
<li><p>La matematica delle trasformazioni che abbiamo introdotto nella
scorsa lezione permette di creare facilmente immagini
<em>statiche</em>.</p></li>
<li><p>Cosa cambierebbe se volessimo invece realizzare
<strong>animazioni</strong>?</p></li>
<li><p>Vediamo subito un esempio pratico.</p></li>
</ul>
</section>
<section id="trasformazioni-nel-tempo-12" class="slide level1">
<h1>Trasformazioni nel tempo (1/2)</h1>
<ul>
<li><p>Consideriamo un oggetto 3D centrato nell’origine.</p></li>
<li><p>Immaginiamo che al tempo <span class="math inline">t = 0</span>
dell’animazione l’oggetto debba essere alla posizione <span
class="math inline">\vec k_0</span>, e al tempo <span
class="math inline">t = 1</span> alla posizione <span
class="math inline">\vec k_1</span>.</p></li>
<li><p>Se voglio generare il fotogramma dell’oggetto al tempo generico
<span class="math inline">0 \leq t \leq 1</span>, la trasformazione
<span class="math inline">A</span> è banalmente</p>
<p><span class="math display">
A(t) = T_{\vec k_0 + (\vec k_1 - \vec k_0) t} =
\begin{pmatrix}
1&amp;0&amp;0&amp;k_{0x} + (k_{1x} - k_{0x})t\\
0&amp;1&amp;0&amp;k_{0y} + (k_{1y} - k_{0y})t\\
0&amp;0&amp;1&amp;k_{0z} + (k_{1z} - k_{0z})t\\
0&amp;0&amp;0&amp;1
\end{pmatrix}.
</span></p></li>
</ul>
</section>
<section id="trasformazioni-nel-tempo-22" class="slide level1">
<h1>Trasformazioni nel tempo (2/2)</h1>
<ul>
<li><p>Le trasformazioni di scala sono ugualmente facili da animare: per
scalare da <span class="math inline">s_0</span> a <span
class="math inline">s_1</span>, la trasformazione è</p>
<p><span class="math display">
A(t) = M_{s_0 + (s_1 - s_0) t} = \bigl(s_0 + (s_1 - s_0) t\bigr)
\begin{pmatrix}
1&amp;0&amp;0&amp;0\\
0&amp;1&amp;0&amp;0\\
0&amp;0&amp;1&amp;0\\
0&amp;0&amp;0&amp;1
\end{pmatrix}.
</span></p></li>
<li><p>Ma per le rotazioni non esiste alcuna formula semplice!</p></li>
</ul>
</section>
<section id="animare-rotazioni" class="slide level1">
<h1>Animare rotazioni</h1>
<ul>
<li><p>Non basta interpolare i coefficienti delle due matrici <span
class="math display">
R(0) = \begin{pmatrix}
m_{11}&amp;m_{12}&amp;m_{13}\\
m_{21}&amp;m_{22}&amp;m_{23}\\
m_{31}&amp;m_{32}&amp;m_{33}
\end{pmatrix},\ %
R(1) = \begin{pmatrix}
m&#39;_{11}&amp;m&#39;_{12}&amp;m&#39;_{13}\\
m&#39;_{21}&amp;m&#39;_{22}&amp;m&#39;_{23}\\
m&#39;_{31}&amp;m&#39;_{32}&amp;m&#39;_{33}
\end{pmatrix},\quad
</span> con la formula <span class="math inline">m_{ij} +
\bigl(m&#39;_{ij} - m_{ij}\bigr) t</span>, perché non è garantito che
l’interpolazione sia ancora ortogonale (<span class="math inline">R(t)
R(t)^t = I</span>).</p></li>
<li><p>Non esiste un modo semplice per interpolare le matrici di
rotazione!</p></li>
</ul>
</section>
<section id="esempio" class="slide level1">
<h1>Esempio</h1>
<iframe src="https://player.vimeo.com/video/538566733?title=0&amp;byline=0&amp;portrait=0&amp;speed=0&amp;badge=0&amp;autopause=0&amp;player_id=0&amp;app_id=58479" width="896" height="504" frameborder="0" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen title="Scanning strategy of a CMB spacecraft (LiteBIRD-like)">
</iframe>
</section>
<section id="esempio-1" class="slide level1">
<h1>Esempio</h1>
<ul>
<li><p>Il satellite <em>Planck</em> aveva a bordo uno <em>star
tracker</em> che identificava l’orientamento del satellite rispetto alle
stelle fisse.</p></li>
<li><p>L’orientamento (<em>attitude</em>) era misurato 10 volte al
secondo (i dati scientifici venivano campionati ~100 volte al secondo) e
trasmesso alla stazione di terra:</p>
<center>
<p><img data-src="./media/planck-attitude-quaternions.svg" /></p>
</center></li>
<li><p>A terra serve l’orientamento allo stesso campionamento del dato
scientifico, quindi è necessario interpolare.</p></li>
<li><p>Per fare ciò, la pipeline di <em>data reduction</em> di Planck
usava i <strong>quaternioni</strong>.</p></li>
</ul>
</section>
<section id="numeri-complessi-e-quaternioni" class="slide level1">
<h1>Numeri complessi e quaternioni</h1>
</section>
<section id="breve-panoramica-storica" class="slide level1">
<h1>Breve panoramica storica</h1>
<ul>
<li>Antica Grecia: primi esempi di regola del parallelogramma</li>
<li>Fine ’600: <a
href="https://en.wikipedia.org/wiki/Gottfried_Wilhelm_Leibniz">Leibniz</a>
sollecita la creazione di un modo per legare algebra e geometria</li>
<li>Fine ’700: <a
href="https://en.wikipedia.org/wiki/Caspar_Wessel">Wessel</a> introduce
la somma e il prodotto di numeri complessi, che lega a proprietà
geometriche, e ipotizza i quaternioni</li>
<li>1843: <a
href="https://en.wikipedia.org/wiki/William_Rowan_Hamilton">Hamilton</a>
pubblica il suo primo lavoro sui quaternioni</li>
<li>1844–1878: <a
href="https://en.wikipedia.org/wiki/Hermann_Grassmann">Grassmann</a> e
<a
href="https://en.wikipedia.org/wiki/William_Kingdon_Clifford">Clifford</a>
propongono l’algebra geometrica</li>
<li>1861: <a
href="https://en.wikipedia.org/wiki/James_Clerk_Maxwell">Maxwell</a>
formula le equazioni dell’elettromagnetismo, usando il formalismo dei
quaternioni di Hamilton</li>
<li>Fine ’800: <a
href="https://en.wikipedia.org/wiki/Josiah_Willard_Gibbs">Gibbs</a> ed
<a href="https://en.wikipedia.org/wiki/Oliver_Heaviside">Heavyside</a>
propongono il calcolo vettoriale moderno, che in pochi decenni diventa
il linguaggio dominante nella fisica</li>
</ul>
</section>
<section id="numeri-complessi-e-quaternioni-1" class="slide level1">
<h1>Numeri complessi e quaternioni</h1>
<ul>
<li><p>Nella scorsa lezione abbiamo espresso le rotazioni in forma
matriciale.</p></li>
<li><p>È possibile anche esprimere le rotazioni usando numeri complessi
(in 2D) o quaternioni (in 3D).</p></li>
<li><p>I quaternioni hanno molti vantaggi rispetto alle matrici di
rotazione 3D, e sono usati in molti ambiti. (Persino le equazioni di
Maxwell furono inizialmente espresse con i quaternioni).</p></li>
<li><p>Noi <strong>non</strong> useremo quaternioni nel nostro codice,
quindi questo argomento non sarà richiesto all’esame. Se volete
approfondire, due ottimi testi sono <a
href="https://www.amazon.com/Visualizing-Quaternions-Kaufmann-Interactive-Technology/dp/0120884003"><em>Visualizing
quaternions</em></a> (A. J. Hanson) e <a
href="https://link.springer.com/book/10.1007/978-0-85729-760-0"><em>Quaternions
for computer graphics</em></a> (J. A. Vince).</p></li>
</ul>
</section>
<section id="numeri-complessi" class="slide level1">
<h1>Numeri complessi</h1>
<ul>
<li><p>L’algebra ℂ dei numeri complessi contiene elementi <span
class="math inline">z = (\Re z, \Im z) = (x, y)</span>.</p></li>
<li><p>Il prodotto si definisce come</p>
<p><span class="math display">
z_1 \cdot z_2 = (\Re z_1\,\Re z_2 - \Im z_1\,\Im z_2, \Re z_1\,\Im z_2 +
\Im z_1\,\Re z_2).
</span></p></li>
<li><p>Introducendo <span class="math inline">i</span> tale che <span
class="math inline">i^2 = -1</span> e scrivendo i numeri complessi nella
forma <span class="math inline">z = x + i y</span>, la formula del
prodotto è più semplice da ricordare:</p>
<p><span class="math display">
(x_1 + i y_1) \cdot (x_2 + i y_2) = x_1 x_2 - y_1 y_2 + i \bigl(x_1 y_2
+ x_2 y_1\bigr).
</span></p></li>
</ul>
</section>
<section id="rotazioni-e-numeri-complessi" class="slide level1">
<h1>Rotazioni e numeri complessi</h1>
<ul>
<li><p>Sul piano è possibile codificare una rotazione <span
class="math inline">R(\theta)</span> attorno all’origine tramite il
numero complesso</p>
<p><span class="math display">
r(\theta) = e^{i \theta} = \cos\theta + i\sin\theta
</span></p>
<p>se si associa al vettore da ruotare <span class="math inline">\vec{v}
= x \hat e_x + y \hat e_z</span> il numero complesso</p>
<p><span class="math display">
z = x + iy.
</span></p>
<p>Sotto queste ipotesi, l’espressione <span
class="math inline">r(\theta) \cdot z</span> è equivalente a <span
class="math inline">R(\theta)\vec{v}</span>.</p></li>
<li><p>Anziché i 4 coefficienti della matrice <span
class="math inline">R(\theta)</span>, servono solo <span
class="math inline">\Re z</span> e <span class="math inline">\Im
z</span>.</p></li>
</ul>
</section>
<section id="da-2d-a-3d" class="slide level1">
<h1>Da 2D a 3D</h1>
<ul>
<li><p>I <a
href="https://en.wikipedia.org/wiki/Quaternion"><em>quaternioni</em></a>
generalizzano in 3D la capacità dei numeri complessi di codificare
rotazioni. Sono stati proposti da <a
href="https://en.wikipedia.org/wiki/William_Rowan_Hamilton">W. R. Hamilton</a>
(quello dell’Hamiltoniana) nel 1843 proprio per estendere ℂ (“inventato”
pochi decenni prima), e la loro algebra si indica con ℍ.</p></li>
<li><p>Se un numero complesso <span class="math inline">z</span> è
formato da due coefficienti (la parte reale <span
class="math inline">\Re z</span> e la parte immaginaria <span
class="math inline">\Im z</span>), un quaternione <span
class="math inline">q \in \mathbb{H}</span> è composto da
<strong>quattro</strong> coefficienti:</p>
<p><span class="math display">
q = (q_0, q_1, q_2, q_3) = \bigl(q_0, \vec{q}\bigr),
</span></p>
<p>Il termine <span class="math inline">q_0</span> è detto <em>parte
scalare</em>, mentre <span class="math inline">\vec{q} = (q_1\ q_2\
q_3)</span> è la <em>parte vettoriale</em>.</p></li>
</ul>
</section>
<section id="prodotto-di-quaternioni" class="slide level1">
<h1>Prodotto di quaternioni</h1>
<ul>
<li><p>Il prodotto <span class="math inline">p q</span> tra due
quaternioni è definito così:</p>
<p><span class="math display">
p q = \begin{pmatrix}
p_0 q_0 - p_1 q_1 - p_2 q_2 - p_3 q_3\\
p_1 q_0 + p_0 q_1 + p_2 q_3 - p_3 q_2\\
p_2 q_0 + p_0 q_2 + p_3 q_1 - p_1 q_3\\
p_3 q_0 + p_0 q_3 + p_1 q_2 - p_2 q_1
\end{pmatrix}.
</span></p></li>
<li><p>Questo prodotto soddisfa tutte le proprietà di un’algebra
associativa, ma <strong>non è commutativo</strong>: <span
class="math inline">p q \not= q p</span>. (Prima algebra di questo tipo
nella storia!).</p></li>
</ul>
</section>
<section id="notazione-per-i-quaternioni" class="slide level1">
<h1>Notazione per i quaternioni</h1>
<ul>
<li><p>Hamilton inventò una notazione molto comoda per i quaternioni:
<span class="math display">
q = q_0 + q_1 \mathbf{i} + q_2 \mathbf{j} + q_3 \mathbf{k}.
</span></p></li>
<li><p>Se si definiscono le seguenti regole, il prodotto tra quaternioni
della slide precedente deriva conseguentemente:</p>
<p><span class="math display">
\begin{aligned}
\mathbf{i} \mathbf{i} &amp;= -1, &amp;\mathbf{i} \mathbf{j}
&amp;=  \mathbf{k}, &amp;\quad\mathbf{j} \mathbf{i} = -\mathbf{k},\\
\mathbf{j} \mathbf{j} &amp;= -1, &amp;\mathbf{j} \mathbf{k}
&amp;=  \mathbf{i}, &amp;\quad\mathbf{k} \mathbf{j} = -\mathbf{i},\\
\mathbf{k} \mathbf{k} &amp;= -1, &amp;\mathbf{k} \mathbf{i}
&amp;=  \mathbf{j}, &amp;\quad\mathbf{i} \mathbf{k} = -\mathbf{j}.
\end{aligned}
</span></p></li>
</ul>
</section>
<section id="prodotto-interno" class="slide level1">
<h1>Prodotto interno</h1>
<ul>
<li><p>È possibile definire un prodotto interno tra quaternioni:</p>
<p><span class="math display">
p \cdot q = p_0 q_0 + p_1 q_1 + p_2 q_2 + p_3 q_3 = p_0 q_0 + \vec{p}
\cdot \vec{q},
</span></p>
<p>a cui è naturale associare una norma:</p>
<p><span class="math display">
\left\|q\right\| = \sqrt{q \cdot q} = \sqrt{q_0^2 + q_1^2 + q_2^2 +
q_3^2} = \sqrt{q_0^2 + \left\|\vec{q}\right\|}.
</span></p></li>
<li><p>È definita anche l’operazione di coniugazione:</p>
<p><span class="math display">
q^* = (q_0, -q_1, -q_2, -q_3) = (q_0, -\vec{q}).
</span></p></li>
</ul>
</section>
<section id="rotazioni-3d-con-quaternioni" class="slide level1">
<h1>Rotazioni 3D con quaternioni</h1>
<ul>
<li><p>Dato un vettore normalizzato <span class="math inline">\hat
n</span> e un angolo <span class="math inline">\theta</span>, ad esso si
associa il quaternione</p>
<p><span class="math display">
r(\theta, \hat n) = \left(\cos\frac\theta2, \sin\frac\theta2\,\hat
n\right),
</span></p>
<p>che rappresenta la rotazione di un angolo <span
class="math inline">\theta</span> intorno a <span
class="math inline">\hat n</span>.</p></li>
<li><p>Se <span class="math inline">\left\|\hat n\right\| = 1</span>,
vale ovviamente che <span class="math inline">\left\|r(\theta, \hat
n)\right\| = 1</span>.</p></li>
<li><p>Vediamo ora come rappresentare una rotazione 3D mediante <span
class="math inline">r(\theta, \hat n)</span>.</p></li>
</ul>
</section>
<section id="applicazione-della-rotazione." class="slide level1">
<h1>Applicazione della rotazione.</h1>
<ul>
<li><p>Un generico vettore <span class="math inline">\vec v</span> viene
ruotato in <span class="math inline">\vec v&#39;</span> tramite questo
prodotto di tre quaternioni:</p>
<p><span class="math display">
\vec v&#39; = r(\theta, \hat n) \cdot (0, \vec v) \cdot r^{-1}(\theta,
\hat n),
</span> dove <span class="math inline">(0, \vec v)</span> rappresenta il
quaternione associato a <span class="math inline">\vec
v</span>.</p></li>
<li><p>Intuitivamente, <span class="math inline">r(\theta, \hat
n)</span> compare <strong>due</strong> volte nella formula perché
dipende dall’angolo <span class="math inline">\theta/2</span>, e non
semplicemente dall’angolo <span
class="math inline">\theta</span>.</p></li>
<li><p>Dalla formula è evidente che <span class="math inline">r(\theta,
\hat n)</span> e <span class="math inline">-r(\theta, \hat n)</span>
rappresentano la medesima rotazione.</p></li>
</ul>
</section>
<section id="i-quaternioni-sono-efficienti" class="slide level1">
<h1>I quaternioni sono efficienti?</h1>
<ul>
<li><p>Una matrice di rotazione deve essere memorizzata salvando in
memoria 9 coefficienti, mentre un quaternione ne richiede appena
4.</p></li>
<li><p>Dovremmo quindi usare quaternioni per rappresentare le rotazioni
nel nostro codice?</p></li>
<li><p>In generale <strong>no</strong>! Se si scrive esplicitamente la
sequenza di operazioni necessaria per ruotare un vettore, si può
dimostrare che la rappresentazione matriciale richiede meno
calcoli.</p></li>
<li><p>A cosa sono utili allora i quaternioni?</p></li>
</ul>
</section>
<section id="slerp" class="slide level1">
<h1><em>Slerp</em></h1>
<ul>
<li><p>Col termine <em>slerp</em> si intende l’interpolazione <span
class="math inline">r(t)</span> tra due rotazioni <span
class="math inline">r_1</span> e <span
class="math inline">r_2</span>.</p></li>
<li><p>La formula di <span class="math inline">r(t) \in
\mathbb{H}</span> per <span class="math inline">t \in [0, 1]</span> è
banalmente</p>
<p><span class="math display">
r(t) = \frac{\sin(1 - t)\theta}{\sin\theta}r_1 + \frac{\sin
t\theta}{\sin\theta}r_2,
</span></p>
<p>dove <span class="math inline">\theta</span> è l’angolo tra i due
quaternioni <span class="math inline">r_1</span> e <span
class="math inline">r_2</span> (con <span
class="math inline">\left\|r_1\right\| = \left\|r_2\right\| =
1</span>):</p>
<p><span class="math display">
\theta = r_1 \cdot r_2.
</span></p></li>
<li><p>È facile dimostrare che <span class="math inline">r(t)</span>
rappresenta una rotazione <span class="math inline">\forall t\in [0,
1]</span>.</p></li>
</ul>
</section>
<section id="esempio-di-slerp" class="slide level1">
<h1>Esempio di slerp</h1>
<p>
<embed width="640px" height="640px" src="js/slerp.html"/>
</p>
</section>
<section id="animare-le-trasformazioni" class="slide level1">
<h1>Animare le trasformazioni</h1>
<ul>
<li><p>Rappresentare le rotazioni con i quaternioni riempie l’ultimo
“buco” che ci mancava: tutte le trasformazioni presentate nella lezione
precedente sono facilmente interpolabili:</p>
<ol type="1">
<li>Traslazioni;</li>
<li>Trasformazioni di scala;</li>
<li>Rotazioni 🥳.</li>
</ol></li>
<li><p>La pagina <a
href="https://enkimute.github.io/LookMaNoMatrices/">Look, Ma, No
Matrices!</a> mostra un simpatico esempio…</p></li>
<li><p>…che usa un’estensione del concetto di “quaternione”, i
<strong>multivettori</strong>, per generare gli effetti mostrati in
fondo alla pagina.</p></li>
<li><p>Vediamo quindi cosa sono i multivettori e le algebre di
Clifford.</p></li>
</ul>
</section>
<section id="algebre-di-clifford" class="slide level1">
<h1>Algebre di Clifford</h1>
</section>
<section id="limiti-della-geometria-classica" class="slide level1">
<h1>Limiti della geometria classica</h1>
<ul>
<li><p>Esistono vettori e pseudovettori, che seguono regole di
trasformazione diverse.</p></li>
<li><p>Per descrivere le rotazioni su un piano 2D è necessario usare
(pseudo)vettori 3D, come il <em>momento angolare</em> <span
class="math inline">\vec{L} = \vec{r} \times \vec{p}</span> o il
<em>momento torcente</em> <span class="math inline">\vec{\tau} = \vec r
\times \vec F</span>.</p></li>
<li><p>Il prodotto vettoriale è definibile solo per <span
class="math inline">\mathbb{R}^3</span> (e <span
class="math inline">\mathbb{R}^7</span>, <a
href="https://en.m.wikipedia.org/wiki/Seven-dimensional_cross_product">a
causa degli ottonioni</a>…), e ha unità strane: se <span
class="math inline">v</span> e <span class="math inline">w</span> sono
in metri, <span class="math inline">v \times w</span> è in m².</p></li>
<li><p>La rappresentazione delle rotazioni richiede algebre via via più
complicate man mano che aumentano le dimensioni (numeri complessi,
quaternioni…).</p></li>
<li><p>Non è possibile invertire i prodotti tra vettori: se <span
class="math inline">\vec a \times \vec x = \vec b</span> con <span
class="math inline">\vec a</span> e <span class="math inline">\vec
b</span> noti e <span class="math inline">x</span> vettore incognito,
non c’è modo di ricostruire univocamente <span class="math inline">\vec
x</span>.</p></li>
</ul>
</section>
<section id="algebra-geometrica" class="slide level1">
<h1>Algebra geometrica</h1>
<ul>
<li><p>Le <strong>algebre di Clifford</strong>, e in particolare
l’<em>algebra geometrica</em>, superano tutti i problemi elencati nella
slide precedente.</p></li>
<li><p>Si tratta di una branca della matematica che rifonda l’algebra
lineare classica, e fornisce un’interpretazione più intuitiva e coerente
di certe proprietà geometriche. <a
href="https://en.wikipedia.org/wiki/William_Kingdon_Clifford">Clifford</a>
la propose nel 1878.</p></li>
<li><p>L’<strong>algebra geometrica</strong> è l’applicazione delle
algebre di Clifford al caso di <span
class="math inline">\mathbb{R}^n</span>, ed è ciò che solitamente
interessa ai fisici. Noi ci limiteremo a queste.</p></li>
</ul>
</section>
<section id="il-prodotto-esterno-o-di-grassmann" class="slide level1">
<h1>Il prodotto esterno (o di Grassmann)</h1>
</section>
<section id="prodotto-tra-vettori" class="slide level1">
<h1>Prodotto tra vettori</h1>
<ul>
<li><p>Il problema del prodotto vettoriale <span
class="math inline">\times</span> è che è definito solo su ℝ³, mentre
noi desideriamo un’algebra generale!</p></li>
<li><p>Nel 1840, <a
href="https://en.wikipedia.org/wiki/Hermann_Grassmann">Hermann Günter
Grassmann</a> (1809–1877) definì il prodotto esterno <span
class="math inline">\vec v \wedge \vec w</span> tra due vettori <span
class="math inline">v</span> e <span class="math inline">w</span> (oggi
chiamato anche <em>prodotto di Grassmann</em>) come l’area orientata sul
piano <span class="math inline">\mathrm{Span}(\vec v, \vec w)</span> con
superficie</p>
<p><span class="math display">
\left\|\vec v\right\|\,\left\|\vec w\right\|\,\sin\theta.
</span></p>
<center>
<p><img data-src="./media/bivector.svg" height="160" /></p>
</center></li>
</ul>
</section>
<section id="aree-orientate" class="slide level1">
<h1>Aree orientate</h1>
<ul>
<li><p>Un’area orientata come <span class="math inline">\vec v \wedge
\vec w</span> si dice <strong>bivettore</strong>.</p></li>
<li><p>I bivettori sono orientati proprio come i comuni vettori:
cambiare segno a un bivettore significa invertirne il verso di
percorrenza (∧ è <strong>antisimmetrico</strong>).</p>
<center>
<p><img data-src="./media/bivector-anticommutativity.svg" /></p>
</center></li>
<li><p>Questo è analogo a quanto succede con un vettore: <span
class="math inline">\vec v \rightarrow - \vec v</span>.</p></li>
<li><p>Così come un vettore <span class="math inline">\vec v</span> non
dipende dal punto di applicazione, un bivettore non dipende dal suo
perimetro («forma»).</p></li>
</ul>
</section>
<section id="forma-del-prodotto-esterno" class="slide level1">
<h1>«Forma» del prodotto esterno</h1>
<center>
<img data-src="./media/bivectors-meaning.svg" />
</center>
<p>Può suonare strano! Però ciò garantisce che <span
class="math inline">(2\vec v) \wedge \vec w = \vec v \wedge (2\vec
w)</span>.</p>
</section>
<section id="significato-del-prodotto-esterno" class="slide level1">
<h1>Significato del prodotto esterno</h1>
<ul>
<li><p>Queste sono le informazioni che codifica un prodotto esterno
<span class="math inline">\vec v \wedge \vec w</span>:</p>
<ol>
<li>Estensione della superficie (es., 15 m²);</li>
<li>Inclinazione del piano su cui si trova la superficie;</li>
<li>Orientamento della superficie.</li>
</ol></li>
<li><p>Queste informazioni non sono invece codificate:</p>
<ol>
<li>Forma della superficie;</li>
<li>Posizione del piano rispetto all’origine degli assi.</li>
</ol></li>
<li><p>Vediamo ora che è possibile definire le operazioni di prodotto
scalare-bivettore e somma sui bivettori: ciò fa di essi uno
<strong>spazio vettoriale</strong>.</p></li>
</ul>
</section>
<section id="prodotto-scalare-bivettore" class="slide level1">
<h1>Prodotto scalare-bivettore</h1>
<ul>
<li><p>L’espressione <span class="math inline">\lambda \vec v \wedge
\vec w</span> con <span class="math inline">\lambda \in
\mathbb{R}</span> è ancora un bivettore.</p></li>
<li><p>L’area di <span class="math inline">\lambda \vec v \wedge \vec
w</span> è <span class="math inline">\left|\lambda\right|</span> volte
l’area di <span class="math inline">\vec v \wedge \vec
w</span>.</p></li>
<li><p>Se <span class="math inline">\lambda &lt; 0</span>, il verso si
inverte, altrimenti resta lo stesso.</p>
<center>
<p><img data-src="./media/bivector-scalar-product.svg" /></p>
</center></li>
</ul>
</section>
<section id="somma-di-bivettori" class="slide level1">
<h1>Somma di bivettori</h1>
<center>
<img data-src="./media/bivector-sum.svg" height="640" />
</center>
</section>
<section id="somma-di-bivettori-1" class="slide level1">
<h1>Somma di bivettori</h1>
<ul>
<li><p>Se due bivettori <span class="math inline">B_1</span> e <span
class="math inline">B_2</span> sono coplanari, allora:</p>
<ol>
<li><span class="math inline">B_1 + B_2</span> è un bivettore sul
medesimo piano;</li>
<li>La sua superficie è pari alla somma con segno delle due (dove il
segno è determinato dal verso).</li>
</ol></li>
<li><p>Se non sono coplanari, si considera un vettore <span
class="math inline">\vec w</span> allineato lungo la retta intersezione
dei due piani e si individuano <span class="math inline">\vec u</span> e
<span class="math inline">\vec v</span> tali che</p>
<p><span class="math display">
B_1 = \vec u \wedge \vec w,\quad B_2 = \vec v \wedge \vec w.
</span></p>
<p>Dalle proprietà di <span class="math inline">\wedge</span> segue che
<span class="math inline">B_1 + B_2 = (\vec u + \vec v) \wedge \vec
w</span>.</p></li>
</ul>
</section>
<section id="base-dei-bivettori" class="slide level1">
<h1>Base dei bivettori</h1>
<ul>
<li><p>La formula della somma appare complicata, ma permette di
costruire uno spazio vettoriale.</p></li>
<li><p>Essendo uno spazio vettoriale, l’insieme dei bivettori possiede
quindi delle basi, e la somma è più semplice da capire e calcolare se si
decompongono i bivettori in una base.</p></li>
<li><p>Possiamo definire la <strong>base canonica</strong> come
l’insieme dei tre bivettori di area unitaria sui piani <span
class="math inline">xy</span>, <span class="math inline">yz</span> e
<span class="math inline">xz</span>:</p>
<p><span class="math display">
\hat e_1 \wedge \hat e_2, \quad \hat e_2 \wedge \hat e_3, \quad \hat e_1
\wedge \hat e_3.
</span></p></li>
</ul>
</section>
<section id="base-dei-bivettori-1" class="slide level1">
<h1>Base dei bivettori</h1>
<p><embed width="640px" height="640px" src="pd-images/9d2243027ec07b44597cce27ca5fd907dcb396fb.html"
data-im_fname="bivector-basis" /></p>
</section>
<section id="somma-di-bivettori-2" class="slide level1">
<h1>Somma di bivettori</h1>
<ul>
<li><p>Se si hanno due bivettori</p>
<p><span class="math display">
\begin{aligned}
\vec v &amp;= 3 \hat e_1 \wedge \hat e_2 - \hat e_1 \wedge \hat e_3,\\
\vec w &amp;= 2 \hat e_1 \wedge \hat e_2 + 4\hat e_1 \wedge \hat e_3,\\
\end{aligned}
</span></p>
<p>allora la loro somma è</p>
<p><span class="math display">
\vec v + \vec w = 5\hat e_1 \wedge \hat e_2 + 3\hat e_1 \wedge \hat e_3.
</span></p></li>
<li><p>È quindi banale fare calcoli con bivettori!</p></li>
</ul>
</section>
<section id="multivettori" class="slide level1">
<h1>Multivettori</h1>
<ul>
<li><p>Il prodotto esterno può essere calcolato anche tra un bivettore e
un vettore, e possiamo sfruttare la proprietà associativa:</p>
<p><span class="math display">
\vec u \wedge \vec v \wedge \vec w = (\vec u \wedge \vec v) \wedge \vec
w = \vec u \wedge (\vec v \wedge \vec w)</span></p></li>
<li><p>Il trivettore <span class="math inline">\vec u \wedge \vec v
\wedge \vec w</span> rappresenta un <em>volume orientato</em>.</p></li>
<li><p>Applicando il prodotto esterno a ripetizione si possono generare
trivettori, quadrivettori, etc. (Ecco perché si chiama
<em>esterno</em>).</p></li>
<li><p>In generale, si parla di <em>multivettori</em>, o <span
class="math inline">k</span>-vettori: lo scalare è uno 0-vettore, i
vettori sono 1-vettori, i bivettori sono 2-vettori, etc.</p></li>
</ul>
</section>
<section id="esempi-di-calcolo" class="slide level1">
<h1>Esempi di calcolo</h1>
<ul>
<li><p>Consideriamo per esempio ℝ³ e la base canonica <span
class="math inline">\left\{\hat e_i\right\}</span>.</p></li>
<li><p>Questi sono alcuni esempi di trivettori e di calcoli associati ad
essi:</p>
<p><span class="math display">
\begin{aligned}
\hat e_1 \wedge \hat e_3 \wedge \hat e_2 &amp;= \hat e_1 \wedge (\hat
e_3 \wedge \hat e_2) = -\hat e_1 \wedge (\hat e_2 \wedge \hat e_3) =
-\hat e_1 \wedge \hat e_2 \wedge \hat e_3,\\
\hat e_2 \wedge \hat e_3 \wedge \hat e_1 &amp;= -\hat e_2 \wedge \hat
e_1 \wedge \hat e_3 = \hat e_1 \wedge \hat e_2 \wedge \hat e_3,\\
\hat e_1 \wedge \hat e_2 \wedge \hat e_3 \wedge \hat e_3 &amp;= \hat e_1
\wedge \hat e_2 \wedge (\hat e_3 \wedge \hat e_3) = 0,\\
\hat e_1 \wedge \hat e_2 \wedge \hat e_3 \wedge \hat e_2 &amp;= -\hat
e_1 \wedge (\hat e_2 \wedge \hat e_2) \wedge \hat e_3 = 0.\\
\end{aligned}
</span></p></li>
<li><p>Dagli ultimi due esempi è facile convincersi che il prodotto
esterno di quattro elementi della base si <strong>annulla
sempre</strong>.</p></li>
</ul>
</section>
<section id="numerosità-dei-multivettori" class="slide level1">
<h1>Numerosità dei multivettori</h1>
<ul>
<li><p>Non solo il prodotto esterno di quattro elementi della
<strong>base</strong> è nullo: anche se si prendono quattro vettori
qualsiasi in <span class="math inline">\mathbb{R}^3</span>, il loro
prodotto è zero.</p></li>
<li><p>È banale dimostrare che in uno spazio <span
class="math inline">\mathbb{R}^n</span> il massimo grado dei
multivettori è <span class="math inline">n</span></p></li>
<li><p>Di conseguenza, in <span class="math inline">\mathbb{R}^3</span>
solo i seguenti oggetti sono non banali:</p>
<ol>
<li>Gli 0-vettori (scalari);</li>
<li>I 1-vettori (vettori);</li>
<li>I 2-vettori (bivettori), chiamati anche <em>pseudovettori</em>;</li>
<li>I 3-vettori (trivettori), chiamati anche
<em>pseudoscalari</em>.</li>
</ol></li>
</ul>
</section>
<section id="il-prodotto-geometrico" class="slide level1">
<h1>Il prodotto geometrico</h1>
</section>
<section id="nascita-dellalgebra-geometrica" class="slide level1">
<h1>Nascita dell’algebra geometrica</h1>
<ul>
<li><p>Clifford partì dal prodotto esterno di Grassmann per definire un
<strong>prodotto tra vettori</strong>, che rende lo spazio vettoriale
<span class="math inline">\mathbb{R}^n</span>
un’<strong>algebra</strong>.</p></li>
<li><p>L’intuizione geniale di Clifford fu che il vecchio, “classico”
prodotto scalare e il “nuovo” prodotto esterno di Grassmann sono
intuitivamente legati tra loro, perché</p>
<p><span class="math display">
\vec{v} \cdot \vec{w} \propto \cos\theta, \quad \vec{v} \wedge \vec{w}
\propto \sin\theta,
</span></p>
<p>ed ovviamente <span class="math inline">\sin^2\theta + \cos^2\theta =
1</span>.</p></li>
</ul>
</section>
<section id="tabelle-di-moltiplicazione" class="slide level1">
<h1>Tabelle di moltiplicazione</h1>
<ul>
<li><p>La relazione si vede anche confrontando il modo in cui si
combinano gli elementi della base canonica di ℝ³:</p>
<p><span class="math display">
\begin{matrix}
\cdot&amp; e_1&amp; e_2&amp; e_3\\
e_1&amp; 1&amp; 0&amp; 0\\
e_2&amp; 0&amp; 1&amp; 0\\
e_3&amp; 0&amp; 0&amp; 1
\end{matrix}
\qquad\qquad
\begin{matrix}
\wedge&amp; e_1&amp; e_2&amp; e_3\\
e_1&amp; 0&amp; e_1 \wedge e_2&amp; e_1 \wedge e_3\\
e_2&amp; -e_1 \wedge e_2&amp; 0&amp; e_2 \wedge e_3\\
e_3&amp; -e_1 \wedge e_3&amp; -e_2 \wedge e_3&amp; 0
\end{matrix}
</span></p></li>
<li><p>È tentante l’idea di sommarli insieme, anche perché ciò ricorda
la formula</p>
<p><span class="math display">
z = \left|z\right|\bigl(\cos\theta + i\sin\theta\bigr).
</span></p></li>
</ul>
</section>
<section id="prodotto-geometrico" class="slide level1">
<h1>Prodotto geometrico</h1>
<ul>
<li><p>Il <strong>prodotto geometrico</strong> è la somma del prodotto
interno e del prodotto esterno:</p>
<p><span class="math display">
\vec v\,\vec w = \vec v \cdot \vec w + \vec v \wedge \vec w.
</span></p></li>
<li><p>Questo prodotto è definito su <span
class="math inline">\mathbb{R}^n</span>, per qualsiasi valore di <span
class="math inline">n \geq 1</span> (ma il caso <span
class="math inline">n = 1</span> è banale), perché lo stesso prodotto
esterno <span class="math inline">\vec v \wedge \vec w</span> è
facilmente generalizzabile a <span class="math inline">n</span>
dimensioni.</p></li>
<li><p>Il prodotto geometrico definisce un’algebra associativa sullo
spazio vettoriale.</p></li>
</ul>
</section>
<section id="prodotto-geometrico-1" class="slide level1">
<h1>Prodotto geometrico</h1>
<ul>
<li><p>Cosa significa sommare tra loro uno scalare come <span
class="math inline">\vec v \cdot \vec w</span> e un bivettore come <span
class="math inline">\vec v \wedge \vec w</span>?</p></li>
<li><p>La «somma» si deve intendere in un senso non letterale, proprio
come la somma della parte reale e immaginaria di un numero (<span
class="math inline">z = x + iy</span>).</p></li>
<li><p>In realtà <span class="math inline">z \in \mathbb{C}</span>
rappresenta una coppia <span class="math inline">(x, y)</span>, che si
scrive come <span class="math inline">x + iy</span> perché ciò è un
aiuto mnemonico quando si devono calcolare somme e prodotti di numeri
complessi.</p></li>
<li><p>Allo stesso modo la scrittura <span class="math inline">\vec v
\cdot \vec w + \vec v \wedge \vec w</span> è un aiuto mnemonico per
ricordare come si sommano e moltiplicano tra loro prodotti
geometrici.</p></li>
</ul>
</section>
<section id="esistenza-dellinversa" class="slide level1">
<h1>Esistenza dell’inversa</h1>
<ul>
<li><p>Calcoliamo <span class="math inline">\vec v^2</span> per un
generico vettore <span class="math inline">\vec v</span>:</p>
<p><span class="math display">
\vec v^2 = \vec v \vec v = \vec v \cdot \vec v + \vec v \wedge \vec v =
\left\|\vec v\right\|^2 + 0 = \left\|\vec v\right\|^2.
</span></p></li>
<li><p>Questo risultato implica che <span class="math inline">\vec v /
\left\|\vec v\right\|^2</span> sia l’inverso di <span
class="math inline">\vec v</span>:</p>
<p><span class="math display">
\vec v \frac{\vec v}{\left\|\vec v\right\|^2} = \frac{\vec v \vec
v}{\left\|\vec v\right\|^2} = 1,
</span></p>
<p>e quindi <span class="math inline">\vec v^{-1} = \vec v / \left\|\vec
v\right\|^2</span>: come ogni algebra che si rispetti, <strong>esiste
l’inversa</strong>!</p></li>
</ul>
</section>
<section id="altri-esempi" class="slide level1">
<h1>Altri esempi</h1>
<ul>
<li><p>Supponiamo che <span class="math inline">\vec v \perp \vec
w</span>. Allora</p>
<p><span class="math display">
\vec v \vec w = \vec v \cdot \vec w + \vec v \wedge \vec w = \vec v
\wedge \vec w.
</span></p>
<p>Per vettori perpendicolari, il prodotto geometrico coincide con
quello esterno.</p></li>
<li><p>La base canonica <span class="math inline">\left\{\hat
e_i\right\}</span> gode quindi delle seguenti proprietà:</p>
<p><span class="math display">
\hat e_i \hat e_i = \left\|\hat e_i\right\|^2 = 1, \quad \hat e_i \hat
e_j = \hat e_i \wedge \hat e_j = -\hat e_j \wedge \hat e_i = - \hat e_j
\hat e_i\ \text{se $i \not= j$}.
</span></p></li>
</ul>
</section>
<section id="prodotti-di-multivettori" class="slide level1">
<h1>Prodotti di multivettori</h1>
<ul>
<li><p>Abbiamo detto che in <span
class="math inline">\mathbb{R}^n</span> si possono avere multivettori di
grado fino a <span class="math inline">n</span>, perché il prodotto
esterno <span class="math inline">\wedge</span> di <span
class="math inline">n + 1</span> vettori si annulla.</p></li>
<li><p>Cosa succede al prodotto geometrico di quattro vettori
ortonormali in ℝ³?</p>
<p><span class="math display">
\begin{aligned}
\hat e_1 \hat e_2 \hat e_3 \hat e_3 &amp;= \hat e_1 \hat e_2 (\hat e_3
\hat e_3) = \hat e_1 \hat e_2\\
\hat e_1 \hat e_2 \hat e_3 \hat e_2 &amp;= -\hat e_1 \hat e_2 \hat e_2
\hat e_3 = -\hat e_1 (\hat e_2 \hat e_2) \hat e_3 = -\hat e_1 \hat
e_3,\\
\hat e_1 \hat e_2 \hat e_3 \hat e_1 &amp;= -\hat e_1 \hat e_2 \hat e_1
\hat e_3= \hat e_1 \hat e_1 \hat e_2 \hat e_3 = \hat e_2 \hat e_3.
\end{aligned}
</span></p></li>
<li><p>Otteniamo sempre bivettori!</p></li>
</ul>
</section>
<section id="esempi" class="slide level1">
<h1>Esempi</h1>
<ul>
<li><p>Se si sa operare sugli elementi di <span
class="math inline">\left\{\hat e_i\right\}</span>, è facile fare
calcoli su vettori arbitrari.</p></li>
<li><p>Prendiamo ad esempio i vettori</p>
<p><span class="math display">\vec v = 2\hat e_1 + \hat e_2,\quad \vec w
= -\hat e_2.</span></p>
<p>Allora:</p>
<p><span class="math display">
\begin{aligned}
\vec v \vec w &amp;= \bigl(2\hat e_1 + \hat e_2\bigr) \bigl(-\hat
e_2\bigr) = 2\hat e_1 \hat e_2 - \hat e_2^2 = 2\hat e_1 \hat e_2 - 1,\\
\vec v^2 &amp;= \vec v \vec v = \bigl(2\hat e_1 + \hat e_2\bigr)
\bigl(2\hat e_1 + \hat e_2\bigr) =\\
&amp;= 4\hat e_1^2  + 2 \hat e_2 \hat e_1 + 2\hat e_1\hat e_2 + \hat
e_2^2 = 5.\\
\end{aligned}
</span></p></li>
</ul>
</section>
<section id="algebra-geometrica-in-2d" class="slide level1">
<h1>Algebra geometrica in 2D</h1>
</section>
<section id="multivettore-generale-in-2d" class="slide level1">
<h1>Multivettore generale in 2D</h1>
<ul>
<li><p>In ℝ² si possono avere solo 0-vettori (scalari), 1-vettori e
2-vettori (bivettori).</p></li>
<li><p>La forma generica di un multivettore è quindi</p>
<p><span class="math display">
q = \alpha + \beta_1 \hat e_1 + \beta_2 \hat e_2 + \gamma \hat e_1 \hat
e_2.
</span></p></li>
<li><p>Abbiamo <strong>quattro</strong> gradi di libertà. Come si
comportano le sue quattro componenti?</p></li>
</ul>
</section>
<section id="sottoalgebre" class="slide level1">
<h1>Sottoalgebre</h1>
<ul>
<li><p>Notiamo innanzitutto che dalla scrittura</p>
<p><span class="math display">
q = \alpha + \beta_1 \hat e_1 + \beta_2 \hat e_2 + \gamma \hat e_1 \hat
e_2
</span></p>
<p>è possibile individuare quattro sottoinsiemi (sottoalgebre):</p>
<ol>
<li>Se <span class="math inline">\beta_1 = \beta_2 = \gamma = 0</span>,
il sottoinsieme è isomorfo a ℝ.</li>
<li>Se <span class="math inline">\alpha = \gamma = 0</span>, il
sottoinsieme è isomorfo allo spazio vettoriale <span
class="math inline">\mathbb{R}^2</span>.</li>
<li>Se <span class="math inline">\alpha = \beta_1 = \beta_2 = 0</span>,
il sottoinsieme sembra ancora isomorfo a ℝ; questi multivettori si
dicono <em>pseudoscalari</em>.</li>
</ol></li>
<li><p>A parte questi casi banali, esistono altre sottoalgebre
interessanti?</p></li>
</ul>
</section>
<section id="multivettori-e-numeri-complessi" class="slide level1">
<h1>Multivettori e numeri complessi</h1>
<ul>
<li><p>Lo pseudoscalare <span class="math inline">\hat e_1 \hat
e_2</span> si comporta come <span class="math inline">i</span>!</p>
<p><span class="math display">
\bigl(\hat e_1 \hat e_2\bigr)^2 = \hat e_1 \hat e_2 \hat e_1 \hat e_2 =
-\hat e_1 \hat e_2 \hat e_2 \hat e_1 = -1.
</span></p></li>
<li><p>Confrontiamo numeri complessi e multivettori con <span
class="math inline">\beta_1 = \beta_2 = 0</span>:</p>
<p><span class="math display">
\begin{aligned}
(3 + i) (1 - 2 i) &amp;= 3 + i - 6 i + 2 = 5 - 5i,\\
(3 + \hat e_1 \hat e_2) (1 - 2\hat e_1 \hat e_2) &amp;= 3 + \hat e_1
\hat e_2 - 6 \hat e_1 \hat e_2 + 2 = 5 - 5 \hat e_1 \hat e_2.
\end{aligned}
</span></p>
<p>Coincidono! L’algebra con <span class="math inline">\beta_1 = \beta_2
= 0</span> è isomorfa a ℂ, e si pone <span class="math inline">\hat e_1
\hat e_2 = i</span>.</p></li>
</ul>
</section>
<section id="multivettori-e-rotazioni-2d" class="slide level1">
<h1>Multivettori e rotazioni 2D</h1>
<ul>
<li><p>I numeri <span class="math inline">e^{i\theta}</span> ruotano
punti sul piano ℂ. Funziona anche con multivettori?</p></li>
<li><p>Vediamo innanzitutto una interessante proprietà del prodotto
geometrico:</p>
<p><span class="math display">
\begin{aligned}
\vec u \vec v &amp;= \vec u \cdot \vec v + \vec u \wedge \vec v =\\
&amp;= \left\|\vec u\right\| \cdot \left\|\vec v\right\| \cdot
\cos\theta +
   \left\|\vec u\right\| \cdot \left\|\vec u\right\| \cdot \sin\theta
\cdot \hat e_1 \hat e_2 =\\
&amp;= \left\|\vec u\right\| \cdot \left\|\vec v\right\| \cdot
   \bigl(\cos\theta + i\sin\theta\bigr) \equiv\\
&amp;\stackrel{\text{def.}}{\equiv} \left\|\vec u\right\| \cdot
\left\|\vec v\right\| \cdot e^{i\theta} = \left\|\vec u\right\| \cdot
\left\|\vec v\right\| \cdot e^{\theta \hat e_1 \hat e_2},
\end{aligned}
</span></p>
<p>che per <span class="math inline">\left\|\vec u\right\| = \left\|\vec
v\right\| = 1</span> porta a <span class="math inline">\vec u \vec v =
e^{i\theta}</span>, la rotazione per un angolo <span
class="math inline">\theta</span>!</p></li>
</ul>
</section>
<section id="multivettori-e-rotazione-2d" class="slide level1">
<h1>Multivettori e rotazione 2D</h1>
<ul>
<li><p>Per ruotare un vettore <span class="math inline">\vec v</span> di
un angolo θ attorno all’origine è sufficiente considerare due versori
<span class="math inline">\hat u_1</span> e <span
class="math inline">\hat u_2</span>, il cui angolo tra loro sia θ, e
calcolare il multivettore ruotato <span class="math inline">\vec
v&#39;</span> come</p>
<p><span class="math display">
\vec v&#39; = \hat u_1 \hat u_2 \vec v = e^{i\theta} \vec v =
\left(\cos\theta + i \sin\theta\right) \vec v.
</span></p></li>
<li><p>Questa formula vale solo nel caso 2D, ma si può riscrivere in
forma generale.</p></li>
</ul>
</section>
<section id="rotazione-2d-alternativa" class="slide level1">
<h1>Rotazione 2D alternativa</h1>
<ul>
<li><p>Il prodotto tra due numeri complessi commuta, e così è anche
nella sottoalgebra di Clifford che contiene multivettori nella forma
<span class="math inline">\alpha + \hat e_1 \hat e_2
\beta</span>.</p></li>
<li><p>Nella formula <span class="math inline">\vec v&#39; = e^{i\theta}
\vec v</span> però figura il <em>vettore</em> <span
class="math inline">\vec v</span>, che non fa parte della sottoalgebra:
in questo caso il prodotto non commuta!</p></li>
<li><p>Si può dimostrare che in 2D vale <span class="math inline">z \vec
v = \vec v z^*</span>, dove <span class="math inline">z^*</span> è il
complesso coniugato.</p></li>
<li><p>Se ci riconduciamo a una relazione simile a quella <a
href="tomasi-ray-tracing-07a-clifford-algebras.html#/applicazione-della-rotazione">vista
per i quaternioni</a>, ossia</p>
<p><span class="math display">
\vec v&#39; = e^{i\theta} \vec v = e^{i\theta/2} e^{i\theta/2} \vec v =
e^{i\theta/2}\vec v e^{-i\theta/2},
</span></p>
<p>vedremo che la formula ha un’applicazione molto più
generale.</p></li>
</ul>
</section>
<section id="algebra-geometrica-in-3d" class="slide level1">
<h1>Algebra geometrica in 3D</h1>
</section>
<section id="multivettori-in-ℝ³" class="slide level1">
<h1>Multivettori in ℝ³</h1>
<ul>
<li><p>Consideriamo la base canonica <span
class="math inline">\left\{\hat e_i\right\}</span> in ℝ³.</p></li>
<li><p>Il multivettore più generico che possiamo pensare deve avere
questa forma:</p>
<p><span class="math display">
\begin{aligned}
&amp;\alpha +\\
&amp;\beta_1 \hat e_1 + \beta_2 \hat e_2 + \beta_3 \hat e_3 +\\
&amp;\gamma_1 \hat e_1 \hat e_2 + \gamma_2 \hat e_2 \hat e_3 + \gamma_3
\hat e_3 \hat e_1 +\\
&amp;\delta \hat e_1 \hat e_2 \hat e_3.
\end{aligned}
</span></p></li>
<li><p>Abbiamo <strong>otto</strong> gradi di libertà: 1 per gli
scalari, 3 per i vettori, 3 per i bivettori e 1 per i trivettori
(pseudoscalari). Vale ancora che <span class="math inline">(\hat e_1
\hat e_2 \hat e_3)^2 = -1 \equiv i^2</span>.</p></li>
</ul>
</section>
<section id="multivettori-e-rotazioni-in-3d" class="slide level1">
<h1>Multivettori e rotazioni in 3D</h1>
<ul>
<li><p>Per specificare una rotazione in 3D occorre l’angolo e l’asse di
rotazione.</p></li>
<li><p>Ma nell’algebra geometrica non si specifica l’<em>asse</em>,
bensì il <em>piano</em> di rotazione: un bivettore!</p></li>
<li><p>Se il piano di rotazione è il bivettore <span
class="math inline">\hat I</span>, il vettore <span
class="math inline">\vec v</span> ruota in <span
class="math inline">\vec v&#39;</span> tramite</p>
<p><span class="math display">
\vec v&#39; = e^{-\hat I \theta/2} \vec v e^{\hat I \theta/2},
</span></p>
<p>che è l’espressione che <a
href="tomasi-ray-tracing-07a-clifford-algebras.html#/rotazione-2d-alternativa">avevamo
già visto</a> nel caso 2D, dove <span class="math inline">\hat I = i =
\hat e_1 \hat e_2</span>: era il piano complesso. Abbiamo
un’interpretazione geometrica della presenza di <span
class="math inline">i</span>!</p></li>
</ul>
</section>
<section id="meccanica-quantistica" class="slide level1">
<h1>Meccanica quantistica</h1>
<ul>
<li><p><a
href="https://en.wikipedia.org/wiki/David_Hestenes">D. Hestenes</a>, che
negli anni ’60-’70 ha riscoperto i lavori di Grassmann e Clifford, ha
mostrato che il termine <span class="math inline">i</span>
nell’equazione di Schrödinger <span class="math display">
H \left|\psi\right&gt; = i\hbar \frac{\mathrm{d}}{\mathrm{d}t}
\left|\psi\right&gt;,
</span> è legato alla medesima rotazione che nella teoria di Dirac-Pauli
rappresenta lo spin.</p></li>
<li><p><em>It is only in a theory with electron spin that one can see
why the wave function is complex […] spin is not a mere add-on in
quantum mechanics, [and] was inadvertently incorporated into the
original Schrödinger equation</em> (<a
href="https://geocalc.clas.asu.edu/pdf/OerstedMedalLecture.pdf">Hestenes
2002</a>)</p></li>
</ul>
</section>
<section id="multivettori-e-quaternioni" class="slide level1">
<h1>Multivettori e quaternioni</h1>
<ul>
<li><p>È facile dimostrare che</p>
<p><span class="math display">
(\hat e_1 \hat e_2)^2 = -1,\quad (\hat e_2 \hat e_3)^2 = -1,\quad (\hat
e_1 \hat e_3)^2 = -1,
</span></p>
<p>e quindi possiamo ottenere una sottoalgebra che è isomorfa
all’algebra ℍ dei quaternioni ponendo</p>
<p><span class="math display">
\mathbf{i} = \hat e_2 \hat e_3, \quad \mathbf{j} = \hat e_1 \hat
e_3,\quad \mathbf{k} = \hat e_1 \hat e_2.
</span></p></li>
<li><p>Com’è facile dimostrare, tutte le <a
href="tomasi-ray-tracing-07a-clifford-algebras.html#/notazione-per-i-quaternioni">proprietà
che avevamo elencato</a> continuano ad essere valide.</p></li>
</ul>
</section>
<section id="meccanica-quantistica-1" class="slide level1">
<h1>Meccanica quantistica</h1>
<ul>
<li><p>Ma le proprietà dei bivettori in ℝ³ sono le medesime che
definiscono le <strong>matrici di Pauli</strong>, usate per descrivere
l’accoppiamento tra lo spin e il campo e.m.:</p>
<p><span class="math display">
\sigma_1 = \begin{pmatrix}0&amp; 1\\1&amp; 0\end{pmatrix}, \quad
\sigma_2 = \begin{pmatrix}0&amp; -i\\i&amp; 0\end{pmatrix}, \quad
\sigma_3 = \begin{pmatrix}1&amp; 0\\0&amp; -1\end{pmatrix}.
</span></p></li>
<li><p>Nell’ottica dell’algebra geometrica, il divario tra fisica
classica e meccanica quantistica si riduce, perché quest’ultima si basa
su bivettori sul campo <strong>reale</strong> ℝ come nel caso della
meccanica classica (dove però i bivettori sono molto meno
pervasivi)</p></li>
</ul>
</section>
<section id="prodotto-vettoriale" class="slide level1">
<h1>Prodotto vettoriale</h1>
<ul>
<li><p>In 3D esiste il prodotto vettoriale <span
class="math inline">\vec u \times \vec v</span>. Cosa c’è di equivalente
nell’algebra geometrica?</p></li>
<li><p>La formula per il prodotto vettore nella geometria classica è</p>
<p><span class="math display">
\vec u \times \vec v = (u_2 v_3 - u_3 v_2) \hat e_1 + (u_3 v_1 - u_1
v_3) \hat e_2 + (u_1 v_2 - u_2 v_1) \hat e_3.
</span></p>
<p>Se scriviamo esplicitamente il prodotto esterno, otteniamo</p>
<p><span class="math display">
\vec u \wedge \vec v = (u_2 v_3 - u_3 v_2) \hat e_2 \hat e_3 + (u_3 v_1
- u_1 v_3) \hat e_3 \hat e_1 + (u_1 v_2 - u_2 v_1) \hat e_1 \hat e_2.
</span></p>
<p>Non è la stessa cosa, ma siamo molto vicini!</p></li>
</ul>
</section>
<section id="prodotto-esterno-e-vettoriale" class="slide level1">
<h1>Prodotto esterno e vettoriale</h1>
<ul>
<li><p>Se <span class="math inline">i = \hat e_1 \hat e_2 \hat
e_3</span>, si può verificare facilmente che</p>
<p><span class="math display">
i\vec u \times \vec v = \vec u \wedge \vec v,
</span></p>
<p>e questa formula può essere usata come spunto per convertire nel
formalismo dell’algebra geometrica le equazioni classiche che contengono
<span class="math inline">\times</span> .</p></li>
<li><p>Il prodotto esterno ha una serie di vantaggi su quello
vettoriale:</p>
<ol>
<li>È definito su <span class="math inline">\mathbb{R}^n</span> per
qualsiasi <span class="math inline">n</span>, mentre quello vettoriale
solo per <span class="math inline">n = 3</span>.</li>
<li>Il prodotto esterno è associativo, quello vettoriale no: <span
class="math inline">u \times (v \times w) \not= (u \times v) \times
w</span>. I calcoli sono quindi più semplici.</li>
</ol></li>
</ul>
</section>
<section id="leggi-della-fisica-e" class="slide level1">
<h1>Leggi della fisica e ∧</h1>
<ul>
<li><p>Il prodotto vettoriale compare in molte leggi della fisica:</p>
<ul>
<li><p>Dinamica del corpo rigido;</p></li>
<li><p>Equazioni di Maxwell;</p></li>
<li><p>Forza di Lorentz.</p></li>
</ul></li>
<li><p>In tutti questi casi è possibile modificare le definizioni e le
formule per usare il prodotto esterno anziché quello
vettoriale.</p></li>
</ul>
</section>
<section id="dinamica-rotazionale" class="slide level1">
<h1>Dinamica rotazionale</h1>
<ul>
<li><p>Il <em>momento angolare</em> può essere definito come il
bivettore <span class="math inline">\vec L = \vec r \wedge \vec
p</span>:</p>
<center>
<p><img data-src="./media/rigid-body-rotation.svg" /></p>
</center></li>
<li><p>A differenza della definizione tradizionale (<span
class="math inline">\vec L = \vec r \times \vec p</span>), qui <span
class="math inline">\vec L</span> rappresenta una sezione orientata di
piano, che è intuitivo: è il piano sul quale avviene la rotazione, e
l’orientamento corrisponde al verso.</p></li>
</ul>
</section>
<section id="riflessioni-e-momento-angolare" class="slide level1">
<h1>Riflessioni e momento angolare</h1>
<ul>
<li><p>Ricordate l’immagine che illustrava la riflessione di
pseudovettori?</p>
<center>
<p><img data-src="./media/auto-angular-momentum.svg" height="380" /></p>
</center></li>
<li><p>Se <span class="math inline">L</span> è un bivettore non c’è
problema! Il piano su cui gira la ruota è perpendicolare allo schermo, e
si riflette banalmente nello specchio.</p></li>
</ul>
</section>
<section id="equazioni-di-maxwell" class="slide level1">
<h1>Equazioni di Maxwell</h1>
<ul>
<li><p><span class="math inline">\vec E</span> è un vettore, ma <span
class="math inline">\vec B</span> è un bivettore!</p>
<center>
<p><img data-src="./media/B-pseudovector.svg" height="380" /></p>
</center></li>
<li><p>(Ma è più conveniente pensare in termini del multivettore <span
class="math inline">\vec F = \vec E + i c \vec B</span>).</p></li>
</ul>
</section>
<section id="multivettori-e-ray-tracing" class="slide level1">
<h1>Multivettori e ray-tracing?</h1>
<ul>
<li><p>L’algebra geometrica semplifica molto le equazioni geometriche
che servono nel nostro corso.</p></li>
<li><p>Ad esempio, scalari, vettori, piani e volumi potrebbero essere
codificati da un solo tipo <code>Multivector</code>, e le trasformazioni
(rotazioni, traslazioni, etc.) dovrebbero essere implementate una sola
volta: che meraviglia!</p></li>
<li><p>Però un multivettore in ℝ³ richiede ben 8 floating-point per
essere memorizzato: visto che in un ray-tracer servono soprattutto
vettori, ciò è uno spreco (la nostra struttura <code>Vec</code> richiede
appena 3 floating point).</p></li>
<li><p>È difficile (ma non impossibile) implementare programmi di
ray-tracing che usano l’algebra geometrica e che siano
efficienti.</p></li>
</ul>
</section>
<section id="approfondimenti-12" class="slide level1">
<h1>Approfondimenti (1/2)</h1>
<ul>
<li><p><a href="https://www.youtube.com/watch?v=60z_hpEAtD8">A swift
introduction to geometric algebra</a>: alcune idee e diagrammi di queste
slide sono state prese da qui (video su YouTube, di circa 40
minuti).</p></li>
<li><p><a
href="https://www.springer.com/gp/book/9783030017552"><em>Geometric
Multiplication of Vectors</em></a> (M. Josipović): molto chiaro, punta a
fornire un’idea intuitiva di come funzioni l’algebra
geometrica.</p></li>
<li><p><a
href="https://www.routledge.com/Understanding-Geometric-Algebra-Hamilton-Grassmann-and-Clifford-for-Computer/Kanatani/p/book/9780367575823"><em>Understanding
Geometric Algebra</em></a> (K. Kanatani): ha un taglio più sistematico
di Josipović; mostra il legame tra matrici omogenee e algebra
geometrica.</p></li>
<li><p><a
href="https://www.cambridge.org/core/books/geometric-algebra-for-physicists/FB8D3ACB76AB3AB10BA7F27505925091"><em>Geometric
Algebra for Physicists</em></a> (C. Doran, A. Lasenby): mostra in che
modo sia possibile riformulare le equazioni della fisica usando
l’algebra geometrica. I campi studiati sono: meccanica classica,
relatività speciale, elettromagnetismo, meccanica quantistica,
formalismo Lagrangiano, gravitazione, etc.</p></li>
</ul>
</section>
<section id="approfondimenti-22" class="slide level1">
<h1>Approfondimenti (2/2)</h1>
<ul>
<li><p><a
href="https://onlinelibrary.wiley.com/doi/book/10.1002/9781118078549"><em>Understanding
geometric algebra for electromagnetic theory</em></a> (J. W. Arthur): è
un testo di elettromagnetismo e relatività speciale che usa l’algebra
geometrica sin dal primo capitolo.</p></li>
<li><p><a
href="https://www.springer.com/gp/book/9781848823785"><em>Geometric
Algebra. An Algebraic System for Computer Games and Animation</em></a>
(J. A. Vince): mostra come le equazioni tipiche usate nella grafica
computerizzata (rotazioni, quaternioni, proiezioni, ray-tracing, etc.)
possano essere riformulate usando i multivettori.</p></li>
<li><p><a
href="https://en.wikipedia.org/wiki/A_History_of_Vector_Analysis"><em>A
history of vector analysis</em></a> (M. J. Crowe): descrive la storia
dell’analisi vettoriale, confrontando le algebre di Hamilton,
Grassmann/Clifford, e il sistema vettoriale di Gibbs/Heavyside (che è
quello «classico», nato però per ultimo).</p></li>
</ul>
</section>
    </div>
  </div>

  <script src="https://unpkg.com/reveal.js@^4//dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="https://unpkg.com/reveal.js@^4//plugin/notes/notes.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/search/search.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/zoom/zoom.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: true,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'bottom-right',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'default',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'slide',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'fade',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

       // Parallax background image
       parallaxBackgroundImage: './media/background.png', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1440,

        height: 810,

        // reveal.js plugins
        plugins: [
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script src="js/asciinema-player.js"></script>
    <script src="https://cdn.plot.ly/plotly-1.58.4.min.js"></script>
    <script type="text/javascript" src="./js/quantization.js"></script>
    </body>
</html>
