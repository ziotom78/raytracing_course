---
title: "Valutazioni degli studenti sui linguaggi usati"
author: "Maurizio Tomasi <[maurizio.tomasi@unimi.it](mailto:maurizio.tomasi@unimi.it)>"
css: ./css/github-pandoc.css
toc: true
fontsize: 12
geometry: "margin=1.5in"
mainfont: "EB Garamond"
sansfont: "Noto Sans"
monofont: "Noto Mono"
colorlinks: true
...

# A.A. 2021–2022

## Eleonora Gatti (Nim 2022-09-07)

Il linguaggio che ho scelto per il corso è NIM.

La mia idea era quella di scegliere un linguaggio che non fosse stato
scelto l'anno precedente e preferibilmente che non conoscevo. NIM è
stato il primo candidato poiché a prima vista mi è sembrato intuitivo
e dalla "guida" ai diversi linguaggi offerta dal prof. Tomasi mi è
parso avere un grande potenziale.

Io e il mio compagno di gruppo abbiamo iniziato ad avvicinarci a NIM
un paio di settimane prima dell'inizio del corso e ci siamo convinti
della nostra scelta: un linguaggio relativamente semplice da imparare,
con una sintassi simile al Python e soprattutto senza le grame dei
";".

Penso che la scelta di NIM ci sia stata utile per il corso. Nonostante
la complessità del codice che abbiamo dovuto scrivere, non abbiamo
quasi mai avuto grossi problemi a livello di linguaggio.

L'unica controindicazione che si può fare riguardo a NIM sono le
scarse risorse disponibili online. Essendo un linguaggio poco diffuso
è raro trovare qualcuno che abbia condiviso online problemi in cui ci
si può imbattere. Tuttavia, esiste una piccola community italiana
piuttosto attiva a cui abbiamo preso parte attraverso un canale
Telegram e che ci è stata di molto aiuto in un paio di occasioni.

Mi sento dunque di consigliare caldamente NIM come linguaggio per
questo corso. Inoltre imparare un nuovo linguaggio di programmazione è
divertente e stimolante e personalmente trovo soddisfacente conoscere
un linguaggio sconosciuto ai più.

## Anna Spanò, Jacopo Fera (Nim, 2022-09-05)

Dopo aver seguito la presentazione del corso abbiamo deciso di
imparare un nuovo linguaggio. Alla fine la scelta è ricaduta su Nim a
causa della curiosità verso la sintassi che ricorda molto quella di
Python e poiché era stato presentato come uno dei linguaggi che
riusciva a raggiungere la velocità del C++.

Se dovessimo presentare i vantaggi che più ci hanno convinto di Nim:
sintassi, velocità e potenzialità del linguaggio. Infatti se si
conosce Python è facilissimo imparare Nim e se si vede codice Python è
facilissimo "tradurlo" in Nim, con il vantaggio che i programmi hanno
tempi di esecuzione bassissimi. Inoltre Nim presenta numerose
funzionalità che vi faranno risparmiare un sacco di tempo nella
scrittura di nuovo codice.

Qual è allora il più grande svantaggio di Nim? La documentazione e in
generale gli esempi che si possono trovare su Internet. Alcuni moduli
che userete hanno pagine descrittive ridotte all'osso, con esempi poco
chiarificatori e che vi potrebbero costringere a leggere direttamente
il codice sorgente. Inoltre alcuni warning del compilatore potrebbero
essere difficili da comprendere e le risposte nel forum di Nim
(scordatevi Stack overflow) potrebbero non aiutare troppo. Per fortuna
alla fine si riesce sempre a risolvere tutto e l'aiuto del prof
dovrebbe essere sufficiente.

Con il senno di poi sceglieremmo ancora e consiglieremmo vivamente Nim
perché si impara facilmente, regala grandi soddisfazioni e la velocità
e traducibilità dal Python lo rendono utile anche per il futuro.

## Simone Boscolo (C\#, 2022-08-16)

Ho seguito il corso di Immagini Fotorealistiche nell'anno accademico
2021-2022 e ho scelto di utilizzare il linguaggio C#. Le motivazioni
della scelta iniziale sono semplici: C++ è un linguaggio che tutti del
gruppo sapevamo usare e volevamo imparare ad usare un linguaggio che
migliorasse alcune criticità del C++. Inoltre ci sembrava potesse
essere utile lavorativamente parlando il linguaggio C#. Un'altra
motivazione che ci ha spinto a scegliere C# è stato il consiglio di un
nostro amico che aveva già seguito il corso l'anno precedente e ci
aveva consigliato C#. Ci siamo trovati molto bene ad utilizzare il
linguaggio C# e rifarei la scelta fatta. E' un linguaggio totalmente
object-oriented ed è molto comodo perché ad esempio non ha bisogno di
un Makefile. Consiglio vivamente di utilizzare come IDE Jetbrains
Rider, che è implementato appositamente per C#. E' un IDE con
potenzialità grandissime, che guida il programmatore nelle varie
scelte e che aiuta a imparare il linguaggio e a gestire il codice.

Inoltre, il nostro gruppo era composto da 3 persone. Consiglio di
formare gruppi di tre persone, in quanto si riesce a dividere meglio
il lavoro e la questione relativa ai conflitti è più interessante.


## Francesco Andreetto (D, 2022-08-13)

Nella scelta iniziale del linguaggio io e il mio compagno abbiamo
adottato due criteri:

1.  Affrontare un linguaggio nuovo per entrambi (escludendo dunque
    **_C++_** e **_Python_**);

2.  Cimentarsi in qualcosa di stimolante, la cui complessità (possiby
    not cumbersome) potesse risultare utile a comprendere e risolvere
    al meglio i problemi che si possono riscontare scrivendo un codice
    vasto come quello sviluppato in questo corso.

Siamo rimasti molto colpiti dai linguaggi **_Rust_** e **_D_** e, dopo
aver consultato la pagina di confronto tra linguaggi messa a
disposizione dal Prof. Tomasi, abbiamo deciso di escludere **_Rust_**
visto il livello di difficoltà del linguaggio, forse eccessivo per il
nostro obiettivo didattico.

Il **_D_** si è dimostrato un linguaggio abbastanza comodo da imparare
per via di molti elementi di sintassi comuni al **_C++_** (punti e
virgole, funzioni, strutture, classi) con qualche eccezione ricorrente
che si impara facilmente. Sotto alcuni aspetti richiama anche la
libertà di scrittura intuitiva che si riscontra in **_Python_**, che
può risultare divertente.

Assolutamente nuovi per me i template e davvero interessante l'uso dei
_mixins_ utilizzati nella definizione di operatori `opBinary` (`+`,
`-` , `*`, `^`): l'eleganza del codice ne ha davvero giovato!

Sono da segnalare però un paio di aspetti, non necessariamente
negativi, ma di rilievo per chi volesse scegliere questo linguaggio
per il corso:

-   La **documentazione**, nonostante il linguaggio sia ben costruito
    e performante, non è vastissima: a parte la pagina di _Dlang_
    comprensiva di forum piuttosto attivo
    ([https://dlang.org/](https://dlang.org/)) non sono presenti molti
    esempi in rete: bisogna proprio un po' attivarsi ;)

-   La gestione di **file di testo** all'interno del codice non è
    intuitiva come per altri linguaggi proposti: soprattutto
    all'inizio può causare non pochi dubbi e rallentare il lavoro. Nel
    nostro caso, per questo motivo siamo rimasti indietro di una
    lezione che abbiamo poi recuperato nelle successive settimane.

Imparare ad utilizzare questo linguaggio è stato a posteriori utile,
interessante e divertente ~~_a tratti_~~ ma non so se lo risceglierei:
gli aspetti evidenziati sopra non mi hanno consentito di godere sempre
dell'esperienza del corso in serenità.

## Diana Barindelli (Nim, 2022-08-06)

1.  *Perché avete scelto questo linguaggio? Quali altre alternative
    avevate valutato, e perché le avete scartate?*

    Ho scelto Nim, in prima istanza perché volevo imparare un
    linguaggio nuovo, escludendo quindi C++. Inoltre, il prof. Tomasi
    lo aveva designato come linguaggio adatto per il corso e
    personalmente mi incuriosiva la sua applicabilità per creare
    pagine HTML. Avevo preso in considerazione anche Julia ma,
    valutando i pareri degli studenti dell’anno scorso, non mi ero
    convinta del tutto e quindi ho optato per seguire i consigli del
    professore.
    
2.  *Indipendentemente dal linguaggio scelto, quali sono stati i
    criteri che vi hanno aiutato a decidere? Come li giudicate col
    senno di poi?*

    Il principale criterio per la mia scelta è stato quello di voler
    imparare un linguaggio nuovo. Per la scelta mi sono basata sulle
    valutazioni degli altri studenti e sulla descrizione dei vari
    linguaggi fornita dal prof. Tomasi. Entrambi mi sono stati di
    grande aiuto per la scelta, anche se, nel mio caso, non c’era
    nessuno dell’anno precedente che avesse usato Nim e, quindi,
    nessun giudizio a riguardo.
    
3.  *Alla luce del lavoro di questo semestre, pensate sia stata una
    buona scelta?*

    Penso sia stata una buona scelta, in quanto non ho mai riscontrato
    grossi problemi per quanto riguarda l’implementazione del codice.
    Un grande svantaggio è la scarsissima documentazione disponibile,
    che, soprattutto all’inizio, potrebbe creare qualche difficoltà.
    Detto ciò, però, Nim è un linguaggio semplice da imparare (non ha
    una sintassi pesante), versatile e veloce, adatto a questo corso.
    
4.  *Se tornaste indietro, rifareste questa scelta? Perché?*

    Sì, o forse proverei con Julia… anche se gli svantaggi di un
    linguaggio moderno si ripresenterebbero. In ogni caso, posso dire
    che Nim “abbia fatto il suo dovere”, nel senso che ha permesso
    un’implementazione lineare, senza grossi stravolgimenti, delle
    funzionalità/classi ecc richieste a lezione.


## Francesca Ferrero, Matteo Di Mario (C\#, 2022-08-04)

Nel momento in cui ci siamo ritrovati a dover scegliere un linguaggio
di programmazione per questo corso, abbiamo dovuto decidere se
sperimentarne uno nuovo o utilizzare il C++ già conosciuto.

Leggendo la presentazione dei linguaggi fatta dal professor Tomasi e i
commenti degli studenti dell’anno precedente, abbiamo notato come il
C# fosse una buona via di mezzo: molto simile al C++ nella sintassi ma
con complicazioni in meno e novità da esplorare. Il C# inoltre:

-   È accompagnato da una documentazione molto bene fatta (fornita da
    Microsoft), che unita ai tutorial e agli esempi di cui spesso è
    fornita rende facile e immediata la consultazione, soprattutto
    quando (come è capitato nelle esercitazioni) c’è stato bisogno di
    usare “sul campo” strumenti e caratteristiche del linguaggio che
    ancora non conoscevamo;

-   È molto ben integrato con l’IDE Rider: un ambiente di
    programmazione (disponibile con licenza gratuita per gli studenti)
    che oltre ad avere il supporto classico di altri IDE (per es. Git
    e GitHub), è progettato e ottimizzato apposta per la
    programmazione in C#. Questo ha facilitato molto la parte di
    programmazione e gestione del codice durante il corso. Tra la
    varie funzionalità presenti, quella che più ci ha aiutato è stata
    il debugger, che ci ha permesso di imparare l’operazione di
    debugging (utilissima!!);
-   Non necessita di creare makefile e header file. Tutte le
    operazioni di compilazione ed esecuzione del programma, dalla
    creazione del progetto no alla produzione dell’applicazione
    eseguibile da linea di comando, sono gestite dalla piattaforma
    .NET, distribuita da Microsoft e scaricabile su tutti i sistemi
    operativi;
-   È un linguaggio molto diffuso, cercando su internet si trovano
    praticamente sempre informazioni e soluzioni date da altri utenti;
-   È spesso usato nella programmazione di videogiochi e entrambi
    eravamo interessati a conoscerlo per magari poter in seguito
    esplorare quell’ambito.

Siamo totalmente soddisfatti della scelta che abbiamo fatto, imparare
questo nuovo linguaggio è stato intuitivo e stimolante, rifaremmo
sicuramente questa scelta.

Una nota riguardo al corso: eravamo un po' spaventati prima di
iniziare, pensando avremmo fatto fatica a stare al passo di settimana
in settimana. In realtà il corso è organizzato molto bene e la mole di
lavoro è ben distribuita. Si imparano moltissime cose che non vengono
toccate da nessun altro corso, anche che riguardano ciò che sta
intorno ala creazione di un programma e lo sviluppo di un codice
complesso (es. utilizzo di Git e GitHub).

## Matteo Baratto (Nim, 2022-08-03)

Ho scelto come linguaggio di programmazione Nim. L'idea era quella di
imparare un nuovo linguaggio ed inizialmente eravamo indecisi tra
varie opzioni tra le quali Nim, Julia e C\#. Leggendo il pdf fornitoci
dal professor Tomasi, io e la mia compagna di gruppo ci siamo conviti
ad utilizzare Nim.

Nim è un linguaggio relativamente giovane ma non per questo meno
"potente". Ciò che più mi ha incuriosito è stata la sintassi semplice,
intuitiva ma allo stesso tempo rigorosa, unita al fatto che Nim
utilizza i compilatori di C e C++ per andare a creare l'eseguibile
finale: in sintesi racchiude la facilità di scrittura di python
insieme all'efficienza e potenza di C++. In generale se si ha già
avuto a che fare con Python imparare Nim sarà un gioco da ragazzi!

Va tenuto in conto che Nim utilizza un approccio più procedurale
rispetto ad altri linguaggi Object Oriented (ad esempio metodi e
costruttori di una classe non sono interni ad essa ma funzioni
separate). Personalmente non mi sono trovato male e mi sono da subito
abituato, va chiaramente detto che comunque Nim supporta una
programmazione più OOP attraverso varie features come ad esempio il
_dynamic dispatch_ oppure le _objects variants_ (emtrambi utili al
fine del corso e facili da capire).

L'aspetto che più mi preoccupava era senz'ombra di dubbio la
giovinezza di Nim e di conseguenza l'eventuale mancanza di una
community ampia e di una documentazione esaustiva. In realtà il
materiale che si trova online sul sito ufficile integrato con i libri
consigliati dal professor Tomasi sono più che sufficienti per iniziare
e nel caso si riscontrassero problemi la community è attiva sia sul
forum ufficiale che su vari gruppi telegram.

In conclusione, penso che sia un ottimo linguaggio per svolgere il
corso: moderno, elegante e facile da imparare. Dovessi tornare
indietro sceglierei ancora Nim in quanto mi ha colpito positivamente e
mi sono divertito molto nell'impararlo.


## Andrea Rossoni (Rust, 2022-07-25)

Premesso che, opinione personale, lo spirito del corso è trasmettere
tutte quelle metodologie per costruire, collaborare, mantenere codice
sicuro e condiviso aka insegnare al fisico medio un po' di **devops**
skills. E **non** risolvere un problema complesso numericamente o
imparare un nuovo linguaggio di programmazione, che saranno comunque
sia due piacevolissime conseguenze.

**`rust` è la scelta per ascendere a tale spirito (ed oltre)!**

Potrei avvalorare la mia tesi pedantemente, elencando tutti i pregi
del linguaggio, toolchain e progetti/servizi associati. Ma così
facendo, potrei barare scrivendo solamente ciò che mi conviene. Un
programmatore di un qualunque altro linguaggio potrebbe fare lo
stesso. Però sicuramente non potrebbe dire che:

-   è il linguaggio più amato dalla community di stack-overflow dal
    [2016](https://insights.stackoverflow.com/survey/2016#technology-most-loved-dreaded-and-wanted)
    ad
    [oggi](https://insights.stackoverflow.com/survey/2021#section-most-loved-dreaded-and-wanted-programming-scripting-and-markup-languages)
    (chiamalo poco)

-   è il linguaggio candidato a diventare secondo per numero di righe
    all'interno del [kernel
    linux](https://www.memorysafety.org/initiative/linux-kernel/) dopo
    `C`¹

Che sarà mai il kernel linux direte voi, bha non so diciamo che gira
su almeno ~1G di dispositivi!²

È quindi un linguaggio maturo a 360° per essere scelto in applicazioni
critiche che spaziano da browsers (mozilla sta riscrivendo interi
pezzi di firefox in `rust`, [servo](https://servo.org/) è un
web-engine sperimentale) a crypto libs
(`openssl`->[`rustls`](https://github.com/rustls/rustls)) fino al
kernel linux. Non potreste fare scelta migliore per capire come
eccelle nello sviluppo di software sicuro e condiviso.

Se invece il vostro obiettivo è capire qual è il miglior linguaggio di
programmazione per risolvere il problema numerico trattato durante il
corso. In tal caso `rust` non eccelle, non eccelle in generale (al
momento) per applicazioni numeriche, lo denota anche la scarsa
presenza di librerie di algebra lineare. L' overhead richiesto a volte
per sopperire a certe limitazioni native del linguaggio (assolutamente
volute, fondative, rivendicate tra le sue feats, cit. "son gli altri
linguaggi che vi hanno abituato male!") è notevole. Ad esempio, spesso
nel codice da sviluppare saranno necessari *abstract methods* e
*classes inheritance*, `rust` non ha niente di tutto ciò. Ci sono due
modi tuttavia, a mio parere un po' troppo noiosi, per aggirare il
problema:

-   in **heap** usando [`Box<dyn
    _>`](https://doc.rust-lang.org/book/ch17-02-trait-objects.html) ed
    a cascata [lifetime
    parameters](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html)

-  in **stack** usando `enum`, anche se un po' "abusati" in questa
   circostanza, si sono rivelati dei buoni alleati

> La gestione degli errori³ o dei null values attraverso l'utilizzo degli `enum` è spettacolare! Ne sentirò sicuramente la mancanza

Ah, la distinzione netta tra **heap** e **stack** non è casuale, è
fondamentale in `rust`. Un buon sviluppatore dovrebbe sempre tenerne
conto, quindi involontariamente`rust` fa di voi dei buoni
sviluppatori.

Cheers and may the 🦀 be with you!

¹ [first merge inside linux kernel](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=8aebac82933ff1a7c8eede18cab11e1115e2062b), where all began ...

² senza troppo contare i dispositivi **android**

³ [thiserror](https://github.com/dtolnay/thiserror) consigliatissima


# A.A. 2020–2021


## Paolo Galli (Julia, 2022-02-05)

Ho scelto Julia perché ne avevo sentito parlare da un po' di persone
tra professori e studenti e la cosa mi aveva incuriosito. Le cose che
ho trovato maggiormente interessanti in fase di scelta sono state:

-   il fatto che si ponga come un linguaggio pensato apposta per il
    calcolo e l'ambiente scientifico;
-   il fatto che sia un linguaggio sia compilato che interpretato,
    cosa che unisce per esempio la semplicità di uso di Python per dei
    conti e analisi veloci da linea di comando interattiva (la REPL di
    Julia) e la velocità di esecuzione simile a un codice C++ (proprio
    perché il codice viene precompilato);
-   il fatto che sia un linguaggio nuovo.

Avevo valutato anche C++ che già conoscevo in modo da approfondirlo,
ma alla fine ho preferito approfittare dell'occasione per imparare un
nuovo linguaggio in un modo che altrimenti mi sarebbe stato difficile,
ovvero un in progetto complesso ma guidato. Secondo me una cosa da
tenere presente (e che per me è stato uno dei principali impatti) è
che Julia è un linguaggio funzionale, non esiste il concetto di
classe, cosa che almeno nel mio caso mi ha costretto a ripensare a
certi approcci al problema. Inoltre, essendo un linguaggio che sotto
certi versi ricorda Python, se si conosce quest'ultimo viene spontaneo
soprattutto all'inizio approcciarsi in modo "pythonistico", cosa da
evitare poiché i due linguaggi sono in realtà profondamente
differenti. Una delle difficoltà maggiori di Julia che ho trovato è
che ci sono molti modi per risolvere uno stesso problema (ad esempio
usando cicli for, broadcasting, map, …) e ognuno di questi può portare
a performance estremamente diversificate a causa di come il linguaggio
e il suo compilatore interpretano e ottimizzano ciò che c'è scritto:
serve quindi porre una buona quantità di attenzione e tempo
nell'analisi delle performance dei vari metodi e nell'ottimizzazione
del codice. Ho trovato però molto belli altri aspetti: l'eleganza del
codice, il metodo di typing, la potenzialità del multiple dispatch, il
metaprogramming, … tutte cose che permettono di liberare molto la
creatività. Rifarei questa scelta perché sviluppare con questo
linguaggio è stato divertente; a tratti complesso, ma divertente.


## Elisa Legnani (C++, 2022-01-04)

Ho scelto il C++ perché era un linguaggio che conoscevo già e volevo
rispolverare. Non mi sembrava di aver imparato ad usarlo con
scioltezza nei corsi precedenti, tanto che parte della sintassi di
esempio mi era nuova e mi aveva incuriosito. Non l’ho scelto tanto per
comodità, quanto per poterlo approfondire: nella descrizione dei
linguaggi fornita dal professore a inizio corso era chiaramente
indicato quanto potesse risultare complicato usarlo per questo
progetto e quanto invece altri linguaggi più recenti come Julia e
Kotlin fossero più maneggevoli. E questo è stato evidente fin dalle
prime lezioni, durante le quali, mentre altri imparavano un nuovo
linguaggio, noi abbiamo faticato a risolvere vari problemi, molti dei
quali aventi a che fare con l’utilizzo di librerie esterne e sistemi
operativi diversi (io ho lavorato con Linux e la mia compagna con
MacOS), oppure ad implementare test automatici da zero o ad imparare
nuovi strumenti per la compilazione. L’esperienza del professore e la
vastità di risorse ed esempi online ci hanno però aiutato molto in
questo senso.

A posteriori posso dire che è grazie a questo corso che ho ottenuto
una buona familiarità con il C++ e con i suoi standard più recenti. Mi
sento solo ora in grado di scrivere autonomamente un programma
complesso usando questo linguaggio, ed è per questo che sono
soddisfatta della scelta che ho fatto. Avevo valutato come alternativa
anche Julia, la cui semplicità e possibile utilizzo nel campo
dell’astrofisica (il professore aveva presentato il linguaggio anche
in una lezione di Astronomia 1) mi avevano interessato. Tornando
indietro rifarei la stessa scelta, sono dell’idea che scontrarsi
contro i problemi ed imparare un metodo per risolverli sia importante
nell’apprendimento di qualsiasi materia.
 
A prescindere dal linguaggio scelto, il corso in generale è molto utile: 

-   si impara a scrivere del codice per descrivere un fenomeno fisico
    non banale in un unico grande progetto;
-   è fondamentale usare sistemi di controllo delle versioni quando si
    scrive codice complesso, e prima di questo corso non avevo avuto
    modo di approfondire l’argomento e di apprezzarne l’utilità;
-   non avevo mai scritto codice collaborando veramente con qualcun
    altro;
-   è importante scrivere codice fruibile da altri - ora che sto
    lavorando alla tesi mi accorgo che spesso il codice in ambito di
    ricerca è poco documentato e/o testato e per questo difficile da
    utilizzare.

Esprimo anche un giudizio del tutto personale, ma credo anche
condiviso dagli altri studenti che hanno frequentato il corso. Si
tratta di un corso divertente. Oltre ad essere un utile strumento di
debugging, poter ottenere risultati visivi dopo vari mesi di duro
lavoro di programmazione dà una grande soddisfazione. Tanto che viene
voglia di implementare anche le parti facoltative, con il rischio di
non finire mai di continuare ad aggiustare e migliorare il programma.


## Tommaso Armadillo (C\#, 2021-06-23)

All’inizio del corso mi sono trovato a dover scegliere un linguaggio
di programmazione. Personalmente volevo imparare un nuovo linguaggio,
per questo motivo ho escluso fin da subito il C++. Per prima cosa ho
letto il pdf scritto dal professor Tomasi in cui fa una panoramica su
diversi linguaggi consigliati, tra questi mi hanno colpito il C# e
Julia. Il primo per la sua sintassi molto simile al C++, ma al tempo
stesso molto più leggera e il secondo perchè mi ha dato l’impressione
di essere un linguaggio molto versatile e innovativo. Alla fine ho
scelto il C# sia perchè rispetto a Julia si trova più materiale
online, sia perchè il C# è molto utilizzato nell’industria videoludica
(grazie al motore grafico Unity) che è un qualcosa che mi ha sempre
interessato e che ho sempre voluto approfondire un po’.

Personalmente sono molto contento della scelta che ho fatto. Il C# è
un linguaggio estremamente versatile e facile da imparare se si
conosce già il C++. La sintassi è identica per tutti i costrutti
principali, tuttavia elimina tutte le difficoltà e le complicazioni
del C++. Ad esempio non c’è bisogno né di creare file `.h` né di dover
scrivere esplicitamente un `makefile` per compilare il codice, ma è
possibile compilare ed eseguire semplicemente con il comando `dotnet
run` (dotnet è il compilatore C# fornito liberamente da Microsoft). C#
è supportato egregiamente da Visual Studio che permette con estrema
facilità di avviare il debugger per risolvere bug all’interno del
codice. Il linguaggio inoltre non prevede poi l’utilizzo di puntatori
e reference come il C++, rendendolo molto più facile e leggibile.
Esistono poi molte librerie fornite direttamente da Microsoft che
permettono di ottenere risultati interessanti in pochissimo tempo. Ad
esempio è possibile parallelizzare l’esecuzione di un ciclo `for`
semplicemente facendo un include di una libreria di sistema e
sostituendo il `for` con `Parallel.For`. Fare un’operazione del genere
in C++ richiede invece l’installazione di librerie esterne, che in
generale è un’operazione più lunga e che può portare a problemi nel
caso in cui altre persone vogliano utilizzare il nostro codice. Infine
un’ultima cosa da non sottovalutare, è il fatto che esiste una
documentazione, molto ben fatta, fornita direttamente da Microsoft ed
essendo poi un linguaggio molto diffuso su StackOverFlow si trovano
parecchie risorse utili.

## Matteo Foglieni (Julia, 2021-06-30)

Per quanto riguarda il mio messaggio per gli studenti del futuro, è
molto semplice: scegliete Julia; sarà molto faticoso all’inizio, ma ne
varrà la pena.

La scelta di Julia per me si è basata su due soli elementi: il pdf
reso disponibile dal professore su alcuni dei vari linguaggi che
consigliava e una lezione facoltativa di Astronomia 1 nella quale lui
stesso presentava un piccolo lavoretto computazionale fatto proprio
con Julia; un po' poco forse con il senno di poi, diciamo che avevo
posto molta fiducia sull’opinione che il professore stesso ha su
questo linguaggio.

Le mie alternative erano C++ (per andare sul sicuro, anche se mi
immaginavo avrei dovuto tribolare parecchio, e un mio compagno che lo
ha scelto me lo ha infatti confermato) o C# (per "uscire dal seminato
ma senza esagerare"); ho scelto Julia per un elemento in particolare:
questo corso è una occasione più unica che rara a fisica di imparare
un linguaggio di programmazione nuovo (= diverso da C++ e Python).

A posteriori, risceglierei questo linguaggio con molta più
consapevolezza e sicurezza:

1.  La sintassi di Julia è relativamente facile da imparare
    (soprattutto se si ha una infarinatura di Python da lab astronomia
    o dalla tesi triennale) ed intuitiva una volta che si entra
    nell’ottica giusta;
2.  Il linguaggio è concepito per il calcolo scientifico, quindi anche
    la scrittura "a mano" di una qualsiasi funzione ha una ottima
    performance: le ottimizzazioni "serie" ovviamente vi sono da fare
    se uno ha tempo ed è interessato, ma anche senza di esse il
    programma ha tempi di esecuzione accettabilissimi; inoltre, avendo
    noi una formazione da fisici, la mentalità di usare e implementare
    funzioni penso venga proprio naturale;
3.  Julia è un linguaggio modernissimo, quindi varie funzionalità che,
    soprattutto verso la fine del corso, vanno rese nel programma
    (come i *sum types* per i tokens, o la possibilità di scrivere
    codice anche molto complesso per i costruttori) vengono supportate
    senza problemi;
4.  Il *multiple dispatch* è comodissimo, si adatta perfettamente per
    le varie shapes da implementare;

La scelta di Julia ha due principali problemi, che è bene sempre
tenere a mente:

1.  Per quanto simile a Python, resta un linguaggio nuovo da imparare
    da zero: soprattutto nelle fasi iniziali, ciò può essere molto
    frustrante, dato che ci si imbatte spesso nel voler fare una cosa
    ma non sapere come farla; se si vuole vedere il lato positivo,
    sicuramente si allenano capacità di improvvisazione e
    perseveranza;
2.  Come già detto nei pregi, Julia è un linguaggio molto moderno. Di
    conseguenza, non di rado si presentano problemi nel codice che non
    si riescono a capire e/o risolvere a causa di scarsa
    documentazione (soprattutto nella prima parte del corso, vedi
    problema 1), o a causa di veri e propri bug (mi sono capitati dei
    problemi con la funzione `string` che ancora non ho capito).
    Inoltre, essendo ancora relativamente poco diffuso (proprio perché
    neo-entrato nel panorama dei linguaggi), cercare su internet il
    messaggio di errore ottenuto e/o parole chiave sul problema
    riscontrato non assicura affatto che si ottenga una soluzione (per
    C++ è invece praticamente impossible che qualcun altro non abbia
    fatto la stessa domanda in precedenza)

NB: terrei comunque a sottolineare che Julia è sotto pesante sviluppo
e improvements; potrebbe quindi anche essere che tra un anno questi
problemi di documentazione e bugs risultino risolti o comunque molto
mitigati.

In conclusione, se avete voglia di impegnarvi e investirci molto
tempo, Julia non vi deluderà di certo!

Ultimissima cosa: a prescindere dal linguaggio scelto, il corso
richiede notevole impegno: non rinunciate a Julia per vertere su C++
solo per evitare di faticare, potreste avere brutte sorprese.


## Simone Pirota (C++, 2021-07-01)

1.  Perché avete scelto questo linguaggio? Quali altre alternative
    avevate valutato, e perché le avete scartate?

    Io ho scelto il C++, principalmente perchè già lo conoscevo, e un
    po' perchè la mia prima scelta (il linguaggio Rust) non era
    condivisa da nessun altro studente.

2.  Indipendentemente dal linguaggio scelto, quali sono stati i
    criteri che vi hanno aiutato a decidere? Come li giudicate col
    senno di poi?

    Principalmente la scelta del linguaggio è stata basata sulla
    curiosità e voglia di imparare un nuovo linguaggio di
    programmazione. Questo potrebbe risultare un criterio che esclude
    il C++, in quanto è già affrontato dai corsi di informatica della
    triennale, ma la grande differenza rispetto a quei corsi è che in
    questo lo si vede non in maniera didattica, ma dal punto di vista
    produttivo, come nella vita vera.
    
    Quindi, se avete voglia di imparare un nuovo linguaggio di
    programmazione (magari anche il più esotico tra quelli proposti) e
    se c'è un altro collega che vi segue non esitate; se invece come
    nel mio caso siete l'unico pazzo del gruppo e siete "obbligati" a
    "ripiegare" sul C++, non scoraggiatevi, perchè lo vedrete sotto
    tutta un'altra luce.
    
    Riassumendo, secondo me i criteri sono:
    
	-   voglia e curiosità di imparare un nuovo linguaggio
    
	-   voglia di approfondire un linguaggio che già si conosce
	
3.  Alla luce del lavoro di questo semestre, pensate sia stata una
    buona scelta?

    È stata una buonissima scelta, perchè come accennato prima, ho
    approfondito e imparato cose che in C++ manco sapevo si potessero
    fare, e soprattutto sono molto più sicuro quando vado a spulciare
    la STL in cerca di risposta, oppure se sto scrivendo una
    funzione/classe/etc etc o la sto copiando da una risposta di
    stackoverflow, ho abbastanza senso critico da capire se lo sto
    facendo nel migliore dei modi o meno.

4.  Se tornaste indietro, rifareste questa scelta? Perché?

    Rifarei la stessa scelta, o meglio, invece di tuffarmi sul Rust,
    sceglierei direttamente il C++, perchè credo sia indispensabile
    conoscerlo e sbatterci la testa il più possibile finché siamo
    studenti (se fosse per me riseguirei questo corso diverse volte,
    ogni volta con un linguaggio diverso, sì, se te lo stai chiedendo,
    questo è davvero un bel corso).


## Giacomo Rivolta (Julia, 2021-07-01)

1.  Perché avete scelto questo linguaggio? Quali altre alternative
    avevate valutato, e perché le avete scartate?

    Noi abbiamo scelto il linguaggio Julia. Le possibilità che avevamo
    erano:
    
    -   rispolverare il molto impolverato C++;
    
    -   riprendere il Python (meno impolverato ma vietato!);
    
    -   imparare un nuovo linguaggio, moderno e semplice da usare.
    
    Visto che per riprendere in mano il C++ in maniera decente avrebbe
    impiegato lo stesso tempo di imparare un nuovo linguaggio, abbiamo
    deciso di impararne uno nuovo. Abbiamo scelto proprio Julia
    (suggeritoci dal prof. Tomasi) perché ci è sembrato moderno,
    semplice, versatile e veloce.
    
2.  Indipendentemente dal linguaggio scelto, quali sono stati i
    criteri che vi hanno aiutato a decidere? Come li giudicate col
    senno di poi?

    Come detto sopra, cercavamo un linguaggio moderno (consapevoli dei
    rischi che comporta, cioè poca documentazione e molti problemi non
    ancora risolti), semplice da imparare (cioè con una sintassi
    facile da apprendere e non pesante), versatile e veloce.
    
    Con il senno di poi direi che questi criteri e la scelta
    conseguente sono stati azzeccati.
    
3.  Alla luce del lavoro di questo semestre, pensate sia stata una
    buona scelta?

    Sì, penso che scegliere Julia sia stata una buona scelta, al di là
    di un po' di problemi "di gioventù" incontrati. Sicuramente la
    versatilità di Julia (cito solo il *multiple dispatch*), la sua
    semplice sintassi, la sua velocità e modernità lo hanno reso
    un'ottima scelta. Sicuramente alcuni problemi riguardo a
    funzionalità non ancora implementate e mancanza di documentazione
    (anche banalmente la risoluzione di qualche problema su
    StackOverflow) verranno aggiustati con il tempo.
    
4.  Se tornaste indietro, rifareste questa scelta? Perché?

    Sì, rifarei sia la scelta di scegliere Julia, sia quella di
    imparare un nuovo linguaggio perché è sempre utile e interessante.


## Federico Pellegatta (C++, 2021-07-05)

### Scelta del linguaggio

All'inizio del corso la mia intenzione era di imparare a programmare
in JavaScript, che già conoscevo in parte. Purtroppo però non ho
trovato un compagno che avesse lo stesso interesse e quindi ho dovuto
ripiegare sul sempiterno C++.

Con il senno di poi, avrei comunque preferito fare un piccolo sforzo
iniziale in più per imparare un linguaggio nuovo. Infatti, la scelta
del C++, se all'inizio mi sembrava la più comoda, in certi casi si è
rivelata piuttosto faticosa rispetto ad altri compagni che hanno
deciso di imparare un nuovo linguaggio. Probabilmente però non mi
sarei comunque buttato completamente in un nuovissimo linguaggio senza
aver dedicato qualche momento a "giocarci" prima di incominciare il
corso.

In ogni caso mi è stato utile la panoramica *A comparison between a
few programming languages* messa a disposizione dal Prof. Tomasi sul
sito Ariel del corso (nella sezione "Informazioni sul corso").

### Pareri generali sul corso

Il corso è molto divertente e stimolante: anche per chi sceglierà il
C++ scoprirà un sacco di cose nuove (che probabilmente ve lo faranno
odiare!). Le lezioni sono interessanti e il materiale didattico
preparato dal Prof è eccellente. È molto soddisfacente avere un
risultato visivo dopo mesi di lavoro: l'appagamento e il risultato
sono direttamente proporzionali all'impegno durante i mesi di corso.

Nonostante nelle presentazioni del corso il Prof. Tomasi abbia
sottolineato che si hanno delle scadenze ogni settimana, il carico di
lavoro mi è sembrato in linea con quello richiesto da altri corsi di
laboratorio. Chiaramente è fondamentale che il lavoro sia finito di
settimana in settimana, ma se anche si arrivi all'esercitazione
successiva con qualche dettaglio non ancora implementato, o qualche
cosa ancora da sistemare, si può velocemente recuperare chiedendo
aiuto al Prof. Inoltre può capitare che alcune settimane ci sia un po'
più di lavoro rispetto ad altre: l'importante è organizzarsi con il
proprio compagno di laboratorio.

In conclusione, ritengo che frequentare questo corso sia stata
un'ottima scelta che rifarei in futuro. Oltre a imparare ad utilizzare
strumenti come Git e GitHub per la programmazione in team, si
implementa un codice numerico complesso che approssimi un modello di
un fenomeno fisico non banale (cose non mostrate in altri corsi).

Puoi avere una panoramica del lavoro svolto e del risultato che io e
il mio compagno di laboratorio abbiamo ottenuto andando a sbirciare
[la nostra repo](https://github.com/federicopellegatta/raytracing).


## Daniele Zambetti (Julia, 2021-07-07)

Ho scelto di utilizzare Julia come linguaggio di programmazione perché
mi era stato presentato velocemente durante una lezione di Astronomia
1 sempre dal professor Tomasi e fin da subito mi era parso molto
comprensibile da leggere come linguaggio. La chiarezza con cui è
possibile esprimere formule matematiche complesse (praticamente con lo
stesso formalismo con cui si scriverebbero su un foglio di carta) è
sorprendente, inoltre la grande flessibilità con cui vengono gestiti i
tipi delle variabili è comodissima. Leggendo il materiale messo a
disposizione del professore mi ha convinto vedere che nonostante sia
un linguaggio formalmente così alto, abbia tempi di compilazione
veramente rapidi.

Un criterio forse banale con cui ho deciso di imparare da capo un
nuovo linguaggio è anche che l’unico linguaggio che conoscevo utile
per fare questo corso, il C++, non lo usavo da moltissimo tempo quindi
la fatica di riprendere la sintassi (rigidissima del C++) sarebbe
stata di poco inferiore alla fatica di iniziare da capo con un nuovo
linguaggio.

Sono molto soddisfatto della scelta fatta, sia perché Julia si è
rilevato un linguaggio flessibile e davvero innovativo, sia perché ho
imparato ad essere molto autonomo nella ricerca di documentazione e di
esempi (la community di Julia è abbastanza attiva) su come si utilizza
questo linguaggio.

In laboratorio il lavoro non è stato particolarmente rallentato dal
dover imparare qiuesto nuovo linguaggio soprattutto perché, come
suggerito dal professore, per prendere dimestichezza con la sintassi
ho svolto prima dell’inizio del corso una decina di esercizi proposti
dal sito [Project Euler](https://projecteuler.net/).


## Matteo Zeccoli Marazzini (C++, 2021-07-09)

Ho scelto il linguaggio C++ perché tra quelli suggeriti era l'unico
che avevo già utilizzato, e ne ho approfittato per studiarlo meglio
usandolo in un progetto complesso. Avevo valutato anche il linguaggio
C, che conosco meglio, ma ho dovuto scartarlo perché nessun altro
l'aveva considerato e non avrei potuto lavorare in gruppo.

Il criterio più importante è stata la familiarità con il linguaggio:
per affrontare un lavoro così complicato, ho pensato che fosse troppo
difficile utilizzare uno strumento mai visto in precedenza. Con il
senno di poi, credo che sia stato un criterio utile: utilizzare ad
esempio Julia sarebbe stato sicuramente stimolante, ma non credo che
sarei riuscito a lavorare in modo altrettanto proficuo. Sono
soddisfatto della scelta: l'alternativa che avevo considerato (il C)
sarebbe stata interessante da usare, ma avrebbe reso alcune cose molto
più complicate da gestire. Ad esempio, funzioni che prendono argomenti
generici sono più rigide e difficili da implementare, e nel corso ne
abbiamo fatto largo uso. Inoltre, sono contento perché ho avuto
l'opportunità di imparare ad utilizzare il C++ in un modo diverso
rispetto a quello a cui ero abituato: ho potuto usare strumenti più
moderni come gli `shared_ptr`, le *lambda functions*, le *initializer
list*. Alla luce di queste riflessioni, credo che sceglierei
nuovamente il C++, soprattutto perché ho potuto imparare ad usarlo
molto meglio rispetto a prima del corso.


## Andrea Sala (C\#, 2021-07-14)

Ho seguito il corso *Calcolo Numerico per la Generazione di Immagini
Fotorealistiche* nell'anno accademico 2020-2021 e ho scelto di
sviluppare il mio progetto in C#.

Quando ho letto la guida ai linguaggi di programmazioni redatta dal
Prof. Tomasi, sono subito rimasto incuriosito dal fatto che esistesse
un linguaggio simile al C++ ma che risolvesse alcune sue criticità.
Così e stato; i vantaggi del C# che ho sperimentato in prima persona
sono:

-   Uso più assennato dei punti e virgola
-   Linguaggio totalmente *object-oriented*: non c'è più quello strano
    mix di funzioni definite al di fuori del main e classi contenenti
    i loro methodi (in questo è molto utile la keyword `static`)
-   Molto ben integrato con l'IDE Visual Studio Code
-   Non c'è bisogno di puntatori
-   È molto comodo usare alcune classi predefinite del linguaggio
    (`List`, `Matrix4x4`, `Dictionary`, …)
-   Non c'è bisogno di scrivere il `Makefile`, ma compilazione ed
    esecuzione sono racchiuse nello stesso comando `dotnet run`
-   Gli errori sono documentati molto bene (codice `CS####`) sul sito
    di Microsoft
-   Ereditarietà concepita in modo più lineare rispetto al C++
-   Parallelizzare il codice è molto molto semplice

Ci sono anche (pochi) svantaggi nell'uso del C#. Ecco quelli che ho
riscontrato:

-   Command Line Interface non facilissima da implementare; abbiamo
    dovuto cercare un po' di librerie diverse prima di trovarne una
    soddisfacente
-   Quando si fa il parsing di un oggetto che può essere una delle
    tante classi figlie di una certa classe madre, è scomodo chiamare
    un datamembro presente in una sola delle classi figlie. Faccio un
    esempio:

    ```csharp
	Token tok = readToken();
	if (tok == SymbolToken)
	{
		string s = tok.symbol; 
	}
    ```

    Questo codice non è ammesso dal C#! Anche se io sono sicuro che
    quel token è un SymbolToken grazie al controllo, non posso
    accedere direttamente al data membro `symbol`, ma devo fare un
    casting un po' scomodo:

    ```csharp
	Token tok = readToken();
	if (tok == SymbolToken)
	{
		string s = ((SymbolToken)tok).symbol;
	}
    ```

- Leggermente meno performante del C++, ma per quello che ho fatto
  durante il corso non ho avuto problemi di lentezza.


## Anna Pivetta (Kotlin, 2021-07-26)

Kotlin. La scelta di questo linguaggio da parte mia sinceramente non è
stata molto ragionata: ero curiosa di imparare un linguaggio nuovo e
ho scelto questo anche insieme al mio compagno di gruppo.

Il primo criterio per me è stato semplicemente che fosse un linguaggio
nuovo, inoltre sapevo che utilizzando Kotlin avrei avuto a che fare
con una bella IDE e mi sembra che anche imparare a interfacciarsi con
uno strumento del genere sia importante per qualcuno a cui piace
programmare.

Kotlin ha alcuni aspetti molto belli: per esempio la possibilità di
usare funzioni implicite rende il codice molto elegante. Inoltre,
esistono molte librerie che rendono alcuni passaggi molto semplici,
per esempio scrivere un’immagine ldr (png, jpeg…) è facilissimo in
Kotlin.

Ovviamente ci sono anche alcuni aspetti negativi, ne segnalo uno in
particolare. Se sceglierete Kotlin userete sicuramente la IDE
IntellijIDEA e il gestore di pacchetti gradle: sono entrambi strumenti
potenti e per certi versi molto comodi ma vanno usati con cautela e
più coscienza di quanto abbiamo fatto noi. IntellijIDEA vi offre
un’interfaccia grafica attraverso la quale potete dialogare con github
senza passare dalla linea di comando: questo è comodo ma bisogna fare
attenzione a cosa committate su github e cosa no. Ci sono alcuni file
che descrivono come è fatto il workspace o come sono le impostazioni
di gradle che se modificati possono crearvi alcuni impicci. Noi
abbiamo usato questi strumenti in modo un po’ sportivo, senza grande
consapevolezza di cosa stavamo facendo; sicuramente se farete qualche
ricerca iniziale su come funzionano gradle e intellijIDEA (non è
necessario un approfondimento esagerato, ma solo avere un minimo di
coscienza su questi strumenti) vi potrete risparmiare qualche
problema.

Complessivamente io sono contenta di aver scelto kotlin e rifarei
questa scelta: è un linguaggio molto elegante e gli strumenti che
mette a disposizione sono veramente tanti. Inoltre, la IDE
intellijIDEA aiuta veramente molto nella scrittura del codice.

In generale penso sia utile cimentarsi nell’imparare un linguaggio
nuovo e impratichirsi un po’ nella lettura della documentazione in
vista del futuro, anche per esempio del lavoro di tesi, dove spesso
bisogna utilizzare un linguaggio che non si conosce. Forse iniziare il
corso non conoscendo il linguaggio che si userà può sembrare una
complicazione in più, ma le esercitazioni delle prime settimane sono
molto semplici e avrete sicuramente il tempo di iniziare a
familiarizzare con il vostro linguaggio.
